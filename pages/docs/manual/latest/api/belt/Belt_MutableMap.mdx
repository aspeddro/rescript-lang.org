# Belt_MutableMap

### undefined


```res sig
module Int = Belt_MutableMapInt
```

### undefined


```res sig
module String = Belt_MutableMapString
```

### t


```res sig
type t<'k, 'v, 'id>
```

### id


```res sig
type id<'key, 'id> = Belt_Id.comparable<'key, 'id>
```

### make


```res sig
let make: (~id: id<'k, 'id>) => t<'k, 'a, 'id>
```

### clear


```res sig
let clear: t<'a, 'b, 'c> => unit
```

### isEmpty


```res sig
let isEmpty: t<'a, 'b, 'c> => bool
```

### has


```res sig
let has: (t<'k, 'a, 'b>, 'k) => bool
```

### cmpU


```res sig
let cmpU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, (. 'a, 'a) => int) => int
```

### cmp
`cmp(m1, m2, cmp)` First compare by size, if size is the same, compare by
    key, value pair.

```res sig
let cmp: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => int) => int
```

### eqU


```res sig
let eqU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, (. 'a, 'a) => bool) => bool
```

### eq
`eq(m1, m2, eqf)` tests whether the maps `m1` and `m2` are equal, that is,
    contain equal keys and associate them with equal data. `eqf` is the
    equality predicate used to compare the data associated with the keys.

```res sig
let eq: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => bool) => bool
```

### forEachU


```res sig
let forEachU: (t<'k, 'a, 'id>, (. 'k, 'a) => unit) => unit
```

### forEach
`forEach(m, f)` applies f to all bindings in map `m`. `f` receives the `'k`
    as first argument, and the associated value as second argument. The
    bindings are passed to `f` in increasing order with respect to the ordering
    over the type of the keys.

```res sig
let forEach: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit
```

### reduceU


```res sig
let reduceU: (t<'k, 'a, 'id>, 'b, (. 'b, 'k, 'a) => 'b) => 'b
```

### reduce
`reduce(m, a, f), computes`(f(kN, dN) ... (f(k1, d1, a))...)`, where`k1 ...
    kN`are the keys of all bindings in`m`(in increasing order), and`d1 ... dN`
    are the associated data.

```res sig
let reduce: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b
```

### everyU


```res sig
let everyU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool
```

### every
`every(m, p)` checks if all the bindings of the map satisfy the predicate
    `p`.

```res sig
let every: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool
```

### someU


```res sig
let someU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool
```

### some
`some(m, p)` checks if at least one binding of the map satisfy the
    predicate `p`.

```res sig
let some: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool
```

### size


```res sig
let size: t<'k, 'a, 'id> => int
```

### toList
In increasing order.

```res sig
let toList: t<'k, 'a, 'id> => list<('k, 'a)>
```

### toArray


```res sig
let toArray: t<'k, 'a, 'id> => array<('k, 'a)>
```

### fromArray


```res sig
let fromArray: (array<('k, 'a)>, ~id: id<'k, 'id>) => t<'k, 'a, 'id>
```

### keysToArray


```res sig
let keysToArray: t<'k, 'a, 'b> => array<'k>
```

### valuesToArray


```res sig
let valuesToArray: t<'a, 'a0, 'b> => array<'a0>
```

### minKey


```res sig
let minKey: t<'k, 'a, 'b> => option<'k>
```

### minKeyUndefined


```res sig
let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>
```

### maxKey


```res sig
let maxKey: t<'k, 'a, 'b> => option<'k>
```

### maxKeyUndefined


```res sig
let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>
```

### minimum


```res sig
let minimum: t<'k, 'a, 'b> => option<('k, 'a)>
```

### minUndefined


```res sig
let minUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>
```

### maximum


```res sig
let maximum: t<'k, 'a, 'b> => option<('k, 'a)>
```

### maxUndefined


```res sig
let maxUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>
```

### get


```res sig
let get: (t<'k, 'a, 'id>, 'k) => option<'a>
```

### getUndefined


```res sig
let getUndefined: (t<'k, 'a, 'id>, 'k) => Js.undefined<'a>
```

### getWithDefault


```res sig
let getWithDefault: (t<'k, 'a, 'id>, 'k, 'a) => 'a
```

### getExn


```res sig
let getExn: (t<'k, 'a, 'id>, 'k) => 'a
```

### checkInvariantInternal
Raise when invariant is not held.

```res sig
let checkInvariantInternal: t<'a, 'b, 'c> => unit
```

### remove
`remove(m, x)` do the in-place modification.

```res sig
let remove: (t<'k, 'a, 'id>, 'k) => unit
```

### removeMany


```res sig
let removeMany: (t<'k, 'a, 'id>, array<'k>) => unit
```

### set
`set(m, x, y)` do the in-place modification

```res sig
let set: (t<'k, 'a, 'id>, 'k, 'a) => unit
```

### updateU


```res sig
let updateU: (t<'k, 'a, 'id>, 'k, (. option<'a>) => option<'a>) => unit
```

### update


```res sig
let update: (t<'k, 'a, 'id>, 'k, option<'a> => option<'a>) => unit
```

### mergeMany


```res sig
let mergeMany: (t<'k, 'a, 'id>, array<('k, 'a)>) => unit
```

### mapU


```res sig
let mapU: (t<'k, 'a, 'id>, (. 'a) => 'b) => t<'k, 'b, 'id>
```

### map
`map(m, f)` returns a map with same domain as `m`, where the associated
    value a of all bindings of `m` has been replaced by the result of the
    application of `f` to `a`. The bindings are passed to `f` in increasing
    order with respect to the ordering over the type of the keys.

```res sig
let map: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>
```

### mapWithKeyU


```res sig
let mapWithKeyU: (t<'k, 'a, 'id>, (. 'k, 'a) => 'b) => t<'k, 'b, 'id>
```

### mapWithKey


```res sig
let mapWithKey: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>
```
