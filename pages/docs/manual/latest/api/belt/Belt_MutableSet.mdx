# Belt_MutableSet

A **mutable** sorted set module which allows customized compare behavior.
  The implementation uses balanced binary trees, and therefore searching and insertion take time logarithmic in the size of the map.

  It also has two specialized inner modules [Belt.MutableSet.Int](mutable-set-int) and [Belt.MutableSet.String](mutable-set-string) - This module separates data from function which is more verbose but slightly more efficient

  ```res example
  module PairComparator = Belt.Id.MakeComparable({
    type t = (int, int)
    let cmp = ((a0, a1), (b0, b1)) =>
      switch Pervasives.compare(a0, b0) {
      | 0 => Pervasives.compare(a1, b1)
      | c => c
      }
  })

  let mySet = Belt.MutableSet.make(~id=module(PairComparator))
  mySet->Belt.MutableSet.add((1, 2))
  ```

### undefined
Specialized when key type is `int`, more efficient
    than the generic type

```res sig
module Int = Belt_MutableSetInt
```

### undefined
Specialized when key type is `string`, more efficient
    than the generic type

```res sig
module String = Belt_MutableSetString
```

### t
`'value` is the element type

  `'identity` the identity of the collection

```res sig
type t<'value, 'identity>
```

### id
The identity needed for making a set from scratch

```res sig
type id<'value, 'id> = Belt_Id.comparable<'value, 'id>
```

### make
Creates a new set by taking in the comparator

```res sig
let make: (~id: id<'value, 'id>) => t<'value, 'id>
```

### fromArray
Creates new set from array of elements.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([1, 3, 2, 4], ~id=module(IntCmp))

  s0->Belt.MutableSet.toArray /* [1, 2, 3, 4] */
  ```

```res sig
let fromArray: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>
```

### fromSortedArrayUnsafe
The same as [fromArray][#fromarray] except it is after assuming the input array is already sorted.

```res sig
let fromSortedArrayUnsafe: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>
```

### copy
Returns copy of a set.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([1, 3, 2, 4], ~id=module(IntCmp))

  let copied = s0->Belt.MutableSet.copy
  copied->Belt.MutableSet.toArray /* [1, 2, 3, 4] */
  ```

```res sig
let copy: t<'value, 'id> => t<'value, 'id>
```

### isEmpty
Checks if set is empty.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let empty = Belt.MutableSet.fromArray([], ~id=module(IntCmp))
  let notEmpty = Belt.MutableSet.fromArray([1], ~id=module(IntCmp))

  Belt.MutableSet.isEmpty(empty) /* true */
  Belt.MutableSet.isEmpty(notEmpty) /* false */
  ```

```res sig
let isEmpty: t<'a, 'b> => bool
```

### has
Checks if element exists in set.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let set = Belt.MutableSet.fromArray([1, 4, 2, 5], ~id=module(IntCmp))

  set->Belt.MutableSet.has(3) /* false */
  set->Belt.MutableSet.has(1) /* true */
  ```

```res sig
let has: (t<'value, 'id>, 'value) => bool
```

### add
Adds element to set. If element existed in set, value is unchanged.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.make(~id=module(IntCmp))
  s0->Belt.MutableSet.add(1)
  s0->Belt.MutableSet.add(2)
  s0->Belt.MutableSet.add(2)

  s0->Belt.MutableSet.toArray /* [1, 2] */
  ```

```res sig
let add: (t<'value, 'id>, 'value) => unit
```

### addCheck


```res sig
let addCheck: (t<'value, 'id>, 'value) => bool
```

### mergeMany
Adds each element of array to set.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let set = Belt.MutableSet.make(~id=module(IntCmp))

  set->Belt.MutableSet.mergeMany([5, 4, 3, 2, 1])
  set->Belt.MutableSet.toArray /* [1, 2, 3, 4, 5] */
  ```

```res sig
let mergeMany: (t<'value, 'id>, array<'value>) => unit
```

### remove
Removes element from set. If element did not exist in set, value is unchanged.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([2, 3, 1, 4, 5], ~id=module(IntCmp))
  s0->Belt.MutableSet.remove(1)
  s0->Belt.MutableSet.remove(3)
  s0->Belt.MutableSet.remove(3)

  s0->Belt.MutableSet.toArray /* [2,4,5] */
  ```

```res sig
let remove: (t<'value, 'id>, 'value) => unit
```

### removeCheck


```res sig
let removeCheck: (t<'value, 'id>, 'value) => bool
```

### removeMany
Removes each element of array from set.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let set = Belt.MutableSet.fromArray([1, 2, 3, 4], ~id=module(IntCmp))

  set->Belt.MutableSet.removeMany([5, 4, 3, 2, 1])
  set->Belt.MutableSet.toArray /* [] */
  ```

```res sig
let removeMany: (t<'value, 'id>, array<'value>) => unit
```

### union
Returns union of two sets.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))
  let union = Belt.MutableSet.union(s0, s1)
  union->Belt.MutableSet.toArray /* [1,2,3,4,5,6] */
  ```

```res sig
let union: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>
```

### intersect
Returns intersection of two sets.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))
  let intersect = Belt.MutableSet.intersect(s0, s1)
  intersect->Belt.MutableSet.toArray /* [2,3,5] */
  ```

```res sig
let intersect: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>
```

### diff
Returns elements from first set, not existing in second set.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))
  Belt.MutableSet.toArray(Belt.MutableSet.diff(s0, s1)) /* [6] */
  Belt.MutableSet.toArray(Belt.MutableSet.diff(s1, s0)) /* [1,4] */
  ```

```res sig
let diff: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>
```

### subset
Checks if second set is subset of first set.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))
  let s2 = Belt.MutableSet.intersect(s0, s1)
  Belt.MutableSet.subset(s2, s0) /* true */
  Belt.MutableSet.subset(s2, s1) /* true */
  Belt.MutableSet.subset(s1, s0) /* false */
  ```

```res sig
let subset: (t<'value, 'id>, t<'value, 'id>) => bool
```

### cmp
Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compares size first and then iterates over each element following the order of elements.

```res sig
let cmp: (t<'value, 'id>, t<'value, 'id>) => int
```

### eq
Checks if two sets are equal.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([5, 2, 3], ~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([3, 2, 5], ~id=module(IntCmp))

  Belt.MutableSet.eq(s0, s1) /* true */
  ```

```res sig
let eq: (t<'value, 'id>, t<'value, 'id>) => bool
```

### forEachU
Same as [forEach](##forEach) but takes uncurried functon.

```res sig
let forEachU: (t<'value, 'id>, (. 'value) => unit) => unit
```

### forEach
Applies function `f` in turn to all elements of set in increasing order.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))
  let acc = ref(list{})
  s0->Belt.MutableSet.forEach(x => acc := Belt.List.add(acc.contents, x))
  acc /* [6,5,3,2] */
  ```

```res sig
let forEach: (t<'value, 'id>, 'value => unit) => unit
```

### reduceU


```res sig
let reduceU: (t<'value, 'id>, 'a, (. 'a, 'value) => 'a) => 'a
```

### reduce
Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an “accumulator”, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))
  s0->Belt.MutableSet.reduce(list{}, (acc, element) => acc->Belt.List.add(element)) /* [6,5,3,2] */
  ```

```res sig
let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a
```

### everyU


```res sig
let everyU: (t<'value, 'id>, (. 'value) => bool) => bool
```

### every
Checks if all elements of the set satisfy the predicate. Order unspecified.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let isEven = x => mod(x, 2) == 0

  let s0 = Belt.MutableSet.fromArray([2, 4, 6, 8], ~id=module(IntCmp))
  s0->Belt.MutableSet.every(isEven) /* true */
  ```

```res sig
let every: (t<'value, 'id>, 'value => bool) => bool
```

### someU


```res sig
let someU: (t<'value, 'id>, (. 'value) => bool) => bool
```

### some
Checks if at least one element of the set satisfies the predicate.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let isOdd = x => mod(x, 2) != 0

  let s0 = Belt.MutableSet.fromArray([1, 2, 4, 6, 8], ~id=module(IntCmp))
  s0->Belt.MutableSet.some(isOdd) /* true */
  ```

```res sig
let some: (t<'value, 'id>, 'value => bool) => bool
```

### keepU


```res sig
let keepU: (t<'value, 'id>, (. 'value) => bool) => t<'value, 'id>
```

### keep
Returns the set of all elements that satisfy the predicate.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let isEven = x => mod(x, 2) == 0

  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))
  let s1 = s0->Belt.MutableSet.keep(isEven)

  s1->Belt.MutableSet.toArray /* [2, 4] */
  ```

```res sig
let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>
```

### partitionU


```res sig
let partitionU: (t<'value, 'id>, (. 'value) => bool) => (t<'value, 'id>, t<'value, 'id>)
```

### partition
```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let isOdd = x => mod(x, 2) != 0

  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))
  let (s1, s2) = s0->Belt.MutableSet.partition(isOdd)

  s1->Belt.MutableSet.toArray /* [1,3,5] */
  s2->Belt.MutableSet.toArray /* [2,4] */
  ```

```res sig
let partition: (t<'value, 'id>, 'value => bool) => (t<'value, 'id>, t<'value, 'id>)
```

### size
Returns size of the set.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4], ~id=module(IntCmp))

  s0->Belt.MutableSet.size /* 4 */
  ```

```res sig
let size: t<'value, 'id> => int
```

### toList
Returns list of ordered set elements.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))

  s0->Belt.MutableSet.toList /* [1,2,3,5] */
  ```

```res sig
let toList: t<'value, 'id> => list<'value>
```

### toArray
Returns array of ordered set elements.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))

  s0->Belt.MutableSet.toArray /* [1,2,3,5] */
  ```

```res sig
let toArray: t<'value, 'id> => array<'value>
```

### minimum
Returns minimum value of the collection. `None` if collection is empty.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.make(~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))

  s0->Belt.MutableSet.minimum /* None */
  s1->Belt.MutableSet.minimum /* Some(1) */
  ```

```res sig
let minimum: t<'value, 'id> => option<'value>
```

### minUndefined
Returns minimum value of the collection. `undefined` if collection is empty.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.make(~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))

  s0->Belt.MutableSet.minUndefined /* undefined */
  s1->Belt.MutableSet.minUndefined /* 1 */
  ```

```res sig
let minUndefined: t<'value, 'id> => Js.undefined<'value>
```

### maximum
Returns maximum value of the collection. `None` if collection is empty.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.make(~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))

  s0->Belt.MutableSet.maximum /* None */
  s1->Belt.MutableSet.maximum /* Some(5) */
  ```

```res sig
let maximum: t<'value, 'id> => option<'value>
```

### maxUndefined
Returns maximum value of the collection. `undefined` if collection is empty.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.make(~id=module(IntCmp))
  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))

  s0->Belt.MutableSet.maxUndefined /* undefined */
  s1->Belt.MutableSet.maxUndefined /* 5 */
  ```

```res sig
let maxUndefined: t<'value, 'id> => Js.undefined<'value>
```

### get
Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))

  s0->Belt.MutableSet.get(3) /* Some(3) */
  s0->Belt.MutableSet.get(20) /* None */
  ```

```res sig
let get: (t<'value, 'id>, 'value) => option<'value>
```

### getUndefined
Same as [get](#get) but returns `undefined` when element does not exist.

```res sig
let getUndefined: (t<'value, 'id>, 'value) => Js.undefined<'value>
```

### getExn
Same as [get](#get) but raise when element does not exist.

```res sig
let getExn: (t<'value, 'id>, 'value) => 'value
```

### split
Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.

  ```res example
  module IntCmp = Belt.Id.MakeComparable({
    type t = int
    let cmp = Pervasives.compare
  })

  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))

  let ((smaller, larger), present) = s0->Belt.MutableSet.split(3)

  present /* true */
  smaller->Belt.MutableSet.toArray /* [1,2] */
  larger->Belt.MutableSet.toArray /* [4,5] */
  ```

```res sig
let split: (t<'value, 'id>, 'value) => ((t<'value, 'id>, t<'value, 'id>), bool)
```

### checkInvariantInternal
**raise** when invariant is not held

```res sig
let checkInvariantInternal: t<'a, 'b> => unit
```
