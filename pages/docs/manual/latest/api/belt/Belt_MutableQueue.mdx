# Belt_MutableQueue

A FIFO (first in first out) queue data structure.

### t
The type of queues containing elements of `type('a)`.

```res sig
type t<'a>
```

### make
Returns a new queue, initially empty.

```res sig
let make: unit => t<'a>
```

### clear
Discard all elements from the queue.

```res sig
let clear: t<'a> => unit
```

### isEmpty
Returns `true` if the given queue is empty, `false` otherwise.

```res sig
let isEmpty: t<'a> => bool
```

### fromArray
`fromArray` a is equivalent to `Array.forEach(a, add(q, a));`

```res sig
let fromArray: array<'a> => t<'a>
```

### add
`add(q, x)` adds the element `x` at the end of the queue `q`.

```res sig
let add: (t<'a>, 'a) => unit
```

### peek
`peekOpt(q)` returns the first element in queue `q`, without removing it from the queue.

```res sig
let peek: t<'a> => option<'a>
```

### peekUndefined
`peekUndefined(q)` returns `undefined` if not found.

```res sig
let peekUndefined: t<'a> => Js.undefined<'a>
```

### peekExn
raise an exception if `q` is empty

```res sig
let peekExn: t<'a> => 'a
```

### pop
`pop(q)` removes and returns the first element in queue `q`.

```res sig
let pop: t<'a> => option<'a>
```

### popUndefined
`popUndefined(q)` removes and returns the first element in queue `q`. it will return `undefined` if it is already empty.

```res sig
let popUndefined: t<'a> => Js.undefined<'a>
```

### popExn
`popExn(q)` raise an exception if q is empty.

```res sig
let popExn: t<'a> => 'a
```

### copy
`copy(q)` returns a fresh queue.

```res sig
let copy: t<'a> => t<'a>
```

### size
Returns the number of elements in a queue.

```res sig
let size: t<'a> => int
```

### mapU


```res sig
let mapU: (t<'a>, (. 'a) => 'b) => t<'b>
```

### map


```res sig
let map: (t<'a>, 'a => 'b) => t<'b>
```

### forEachU


```res sig
let forEachU: (t<'a>, (. 'a) => unit) => unit
```

### forEach
`forEach(q, f) applies`f`in turn to all elements of`q`, from the least
  recently entered to the most recently entered. The queue itself is unchanged.

```res sig
let forEach: (t<'a>, 'a => unit) => unit
```

### reduceU


```res sig
let reduceU: (t<'a>, 'b, (. 'b, 'a) => 'b) => 'b
```

### reduce
`reduce(q, accu, f)` is equivalent to `List.reduce(l, accu, f)`, where `l` is the list of `q`'s elements. The queue remains unchanged.

```res sig
let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b
```

### transfer
`transfer(q1, q2)` adds all of `q1`'s elements at the end of the queue `q2`, then clears `q1`. It is equivalent to the sequence `forEach((x) => add(x, q2), q1);`; clear `q1`, but runs in constant time.

```res sig
let transfer: (t<'a>, t<'a>) => unit
```

### toArray
First added will be in the beginning of the array.

```res sig
let toArray: t<'a> => array<'a>
```
