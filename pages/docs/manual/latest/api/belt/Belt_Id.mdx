# Belt_Id

[`Belt.Id`]()

  Provide utiliites to create identified comparators or hashes for
  data structures used below.

  It create a unique identifer per module of functions so that different data structures with slightly different
  comparison functions won't mix.

### hash
`('a, 'id) hash`

  Its runtime represenation is a `hash` function, but signed with a
  type parameter, so that different hash functions type mismatch

```res sig
type hash<'a, 'id>
```

### eq
`('a, 'id) eq`

  Its runtime represenation is an `eq` function, but signed with a
  type parameter, so that different hash functions type mismatch

```res sig
type eq<'a, 'id>
```

### cmp
`('a,'id) cmp`

  Its runtime representation is a `cmp` function, but signed with a
  type parameter, so that different hash functions type mismatch

```res sig
type cmp<'a, 'id>
```

### comparable
`('key, 'id) cmparable` is a module of functions, here it only includes `cmp`.

  Unlike normal functions, when created, it comes with a unique identity (guaranteed
  by the type system).

  It can be created using function [`comparableU`]() or [`comparable`]().

  The idea of a unique identity when created is that it makes sure two sets would type
  mismatch if they use different comparison function

```res sig
type comparable<'key, 'id> = module(Comparable with type identity = 'id)
type t = 'key
```

## MakeComparableU



### identity


```res sig
type identity
```
### t


```res sig
type t = M.t
```
### cmp


```res sig
let cmp: cmp<t, identity>
```

## MakeComparable



### identity


```res sig
type identity
```
### t


```res sig
type t = M.t
```
### cmp


```res sig
let cmp: cmp<t, identity>
```

### comparableU


```res sig
let comparableU: (~cmp: (. 'a, 'a) => int) => module(Comparable with type t = 'a)
```

### comparable
```
  module C = (
    val Belt.Id.comparable ~cmp:(compare : int -> int -> int)
  )
  let m = Belt.Set.make(module C)
  ```

  Note that the name of C can not be ignored

```res sig
let comparable: (~cmp: ('a, 'a) => int) => module(Comparable with type t = 'a)
```

### hashable
`('key, 'id) hashable` is a module of functions, here it only includes `hash`, `eq`.

  Unlike normal functions, when created, it comes with a unique identity (guaranteed
  by the type system).

  It can be created using function [`hashableU`]() or [`hashable`]().

  The idea of a unique identity when created is that it makes sure two hash sets would type
  mismatch if they use different comparison function

```res sig
type hashable<'key, 'id> = module(Hashable with type identity = 'id)
type t = 'key
```

## MakeHashableU



### identity


```res sig
type identity
```
### t


```res sig
type t = M.t
```
### hash


```res sig
let hash: hash<t, identity>
```
### eq


```res sig
let eq: eq<t, identity>
```

## MakeHashable



### identity


```res sig
type identity
```
### t


```res sig
type t = M.t
```
### hash


```res sig
let hash: hash<t, identity>
```
### eq


```res sig
let eq: eq<t, identity>
```

### hashableU


```res sig
let hashableU: (~hash: (. 'a) => int, ~eq: (. 'a, 'a) => bool) => module(Hashable with type t = 'a)
```

### hashable


```res sig
let hashable: (~hash: 'a => int, ~eq: ('a, 'a) => bool) => module(Hashable with type t = 'a)
```

### getHashInternal


```res sig
let getHashInternal: hash<'a, 'id> => (. 'a) => int
```

### getEqInternal


```res sig
let getEqInternal: eq<'a, 'id> => (. 'a, 'a) => bool
```

### getCmpInternal


```res sig
let getCmpInternal: cmp<'a, 'id> => (. 'a, 'a) => int
```
