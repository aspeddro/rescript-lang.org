# Belt_HashSet

A **mutable** Hash set which allows customized `hash` behavior.

  All data are parameterized by not its only type but also a unique identity in
  the time of initialization, so that two _HashSets of ints_ initialized with
  different _hash_ functions will have different type.

  For example:

  ```res prelude
  module I0 = unpack(
    Belt.Id.hashableU(
      ~hash=(. a: int) => land(a, 65535),
      ~eq=(. a, b) => a == b,
    )
  )

  let s0 = Belt.HashSet.make(~id=module(I0), ~hintSize=40)

  module I1 = unpack(
    Belt.Id.hashableU(
      ~hash=(. a: int) => land(a, 255),
      ~eq=(. a, b) => a == b,
    )
  )

  let s1 = Belt.HashSet.make(~id=module(I1), ~hintSize=40)

  Belt.HashSet.add(s1, 0)
  Belt.HashSet.add(s1, 1)
  ```

  The invariant must be held: for two elements who are equal, their hashed
  value should be the same.

  Here the compiler would infer `s0` and `s1` having different type so that it
  would not mix.

  ```res sig
  let s0: Belt.HashSet.t<int, I0.identity>
  let s1: Belt.HashSet.t<int, I1.identity>
  ```

  We can add elements to the collection (see last two lines in the example
  above). Since this is an mutable data structure, `s1` will contain two pairs.

## Int

```res sig
module Int = Belt_HashSetInt
```
Specalized when key type is `int`, more efficient
    than the generic type

## String

```res sig
module String = Belt_HashSetString
```
Specalized when key type is `string`, more efficient
    than the generic type

## t

```res sig
type t<'a, 'id>
```


## id

```res sig
type id<'a, 'id> = Belt_Id.hashable<'a, 'id>
```
The type of hash tables from type `'a` to type `'b`.

## make

```res sig
let make: (~hintSize: int, ~id: id<'a, 'id>) => t<'a, 'id>
```


## clear

```res sig
let clear: t<'a, 'id> => unit
```


## isEmpty

```res sig
let isEmpty: t<'a, 'b> => bool
```


## add

```res sig
let add: (t<'a, 'id>, 'a) => unit
```


## copy

```res sig
let copy: t<'a, 'id> => t<'a, 'id>
```


## has

```res sig
let has: (t<'a, 'id>, 'a) => bool
```


## remove

```res sig
let remove: (t<'a, 'id>, 'a) => unit
```


## forEachU

```res sig
let forEachU: (t<'a, 'id>, (. 'a) => unit) => unit
```


## forEach

```res sig
let forEach: (t<'a, 'id>, 'a => unit) => unit
```
Order unspecified.

## reduceU

```res sig
let reduceU: (t<'a, 'id>, 'c, (. 'c, 'a) => 'c) => 'c
```


## reduce

```res sig
let reduce: (t<'a, 'id>, 'c, ('c, 'a) => 'c) => 'c
```
Order unspecified.

## size

```res sig
let size: t<'a, 'id> => int
```


## logStats

```res sig
let logStats: t<'a, 'b> => unit
```


## toArray

```res sig
let toArray: t<'a, 'id> => array<'a>
```


## fromArray

```res sig
let fromArray: (array<'a>, ~id: id<'a, 'id>) => t<'a, 'id>
```


## mergeMany

```res sig
let mergeMany: (t<'a, 'id>, array<'a>) => unit
```


## getBucketHistogram

```res sig
let getBucketHistogram: t<'a, 'b> => array<int>
```

