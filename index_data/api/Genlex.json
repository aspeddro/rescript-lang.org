{
  "name": "Genlex",
  "docstrings": [],
  "items": [
    {
      "id": "Genlex.token",
      "kind": "type",
      "name": "token",
      "signature": "type token =\\n  | Kwd(string)\\n  | Ident(string)\\n  | Int(int)\\n  | Float(float)\\n  | String(string)\\n  | Char(char)",
      "docstrings": [
        "The type of tokens. The lexical classes are: [Int] and [Float]\n   for integer and floating-point numbers; [String] for\n   string literals, enclosed in double quotes; [Char] for\n   character literals, enclosed in single quotes; [Ident] for\n   identifiers (either sequences of letters, digits, underscores\n   and quotes, or sequences of 'operator characters' such as\n   [+], [*], etc); and [Kwd] for keywords (either identifiers or\n   single 'special characters' such as [(], [}], etc)."
      ],
      "detail": {
        "kind": "variant",
        "constructorDocs": [
          {
            "constructorName": "Kwd",
            "docstrings": [],
            "signature": "Kwd(string)"
          },
          {
            "constructorName": "Ident",
            "docstrings": [],
            "signature": "Ident(string)"
          },
          {
            "constructorName": "Int",
            "docstrings": [],
            "signature": "Int(int)"
          },
          {
            "constructorName": "Float",
            "docstrings": [],
            "signature": "Float(float)"
          },
          {
            "constructorName": "String",
            "docstrings": [],
            "signature": "String(string)"
          },
          {
            "constructorName": "Char",
            "docstrings": [],
            "signature": "Char(char)"
          }
        ]
      }
    },
    {
      "id": "Genlex.make_lexer",
      "kind": "value",
      "name": "make_lexer",
      "signature": "let make_lexer: (list<string>, Stream.t<char>) => Stream.t<token>",
      "docstrings": [
        "Construct the lexer function. The first argument is the list of\n   keywords. An identifier [s] is returned as [Kwd s] if [s]\n   belongs to this list, and as [Ident s] otherwise.\n   A special character [s] is returned as [Kwd s] if [s]\n   belongs to this list, and cause a lexical error (exception\n   {!Stream.Error} with the offending lexeme as its parameter) otherwise.\n   Blanks and newlines are skipped. Comments delimited by [(*] and [*)]\n   are skipped as well, and can be nested. A {!Stream.Failure} exception\n   is raised if end of stream is unexpectedly reached."
      ]
    }
  ]
}