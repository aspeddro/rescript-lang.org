{
  "name": "Belt_MutableSetInt",
  "docstrings": [
    "This module is [`Belt.MutableSet`]() specialized with key type to be a primitive type.\n\n  It is more efficient in general, the  API is the same with [`Belt.MutableSet`]() except its key type is fixed,\n  and identity is not needed(using the built-in one)\n\n  **See** [`Belt.MutableSet`]()"
  ],
  "items": [
    {
      "id": "Belt_MutableSetInt.value",
      "kind": "type",
      "name": "value",
      "signature": "type value = int",
      "docstrings": [
        "The type of the set elements."
      ]
    },
    {
      "id": "Belt_MutableSetInt.t",
      "kind": "type",
      "name": "t",
      "signature": "type t",
      "docstrings": [
        "The type of sets."
      ]
    },
    {
      "id": "Belt_MutableSetInt.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<value> => t",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.fromSortedArrayUnsafe",
      "kind": "value",
      "name": "fromSortedArrayUnsafe",
      "signature": "let fromSortedArrayUnsafe: array<value> => t",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t => t",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t, value) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t, value) => unit",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.addCheck",
      "kind": "value",
      "name": "addCheck",
      "signature": "let addCheck: (t, value) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t, array<value>) => unit",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t, value) => unit",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.removeCheck",
      "kind": "value",
      "name": "removeCheck",
      "signature": "let removeCheck: (t, value) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.removeMany",
      "kind": "value",
      "name": "removeMany",
      "signature": "let removeMany: (t, array<value>) => unit",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.union",
      "kind": "value",
      "name": "union",
      "signature": "let union: (t, t) => t",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.intersect",
      "kind": "value",
      "name": "intersect",
      "signature": "let intersect: (t, t) => t",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.diff",
      "kind": "value",
      "name": "diff",
      "signature": "let diff: (t, t) => t",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.subset",
      "kind": "value",
      "name": "subset",
      "signature": "let subset: (t, t) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t, t) => int",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t, t) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t, (. value) => unit) => unit",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t, value => unit) => unit",
      "docstrings": [
        "In increasing order"
      ]
    },
    {
      "id": "Belt_MutableSetInt.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a",
      "docstrings": [
        "Iterate in increasing order."
      ]
    },
    {
      "id": "Belt_MutableSetInt.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t, (. value) => bool) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t, value => bool) => bool",
      "docstrings": [
        "`every p s` checks if all elements of the set\n  satisfy the predicate `p`. Order unspecified."
      ]
    },
    {
      "id": "Belt_MutableSetInt.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t, (. value) => bool) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t, value => bool) => bool",
      "docstrings": [
        "`some p s` checks if at least one element of\n  the set satisfies the predicate `p`. Oder unspecified."
      ]
    },
    {
      "id": "Belt_MutableSetInt.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (t, (. value) => bool) => t",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (t, value => bool) => t",
      "docstrings": [
        "`keep s p` returns a fresh copy of the set of all elements in `s`\n  that satisfy predicate `p`."
      ]
    },
    {
      "id": "Belt_MutableSetInt.partitionU",
      "kind": "value",
      "name": "partitionU",
      "signature": "let partitionU: (t, (. value) => bool) => (t, t)",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t, value => bool) => (t, t)",
      "docstrings": [
        "`partition s p` returns a fresh copy pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."
      ]
    },
    {
      "id": "Belt_MutableSetInt.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t => int",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.toList",
      "kind": "value",
      "name": "toList",
      "signature": "let toList: t => list<value>",
      "docstrings": [
        "In increasing order with respect"
      ]
    },
    {
      "id": "Belt_MutableSetInt.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t => array<value>",
      "docstrings": [
        "In increasing order with respect"
      ]
    },
    {
      "id": "Belt_MutableSetInt.minimum",
      "kind": "value",
      "name": "minimum",
      "signature": "let minimum: t => option<value>",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.minUndefined",
      "kind": "value",
      "name": "minUndefined",
      "signature": "let minUndefined: t => Js.undefined<value>",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.maximum",
      "kind": "value",
      "name": "maximum",
      "signature": "let maximum: t => option<value>",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.maxUndefined",
      "kind": "value",
      "name": "maxUndefined",
      "signature": "let maxUndefined: t => Js.undefined<value>",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t, value) => option<value>",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.getUndefined",
      "kind": "value",
      "name": "getUndefined",
      "signature": "let getUndefined: (t, value) => Js.undefined<value>",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t, value) => value",
      "docstrings": []
    },
    {
      "id": "Belt_MutableSetInt.split",
      "kind": "value",
      "name": "split",
      "signature": "let split: (t, value) => ((t, t), bool)",
      "docstrings": [
        "`split s key` return a fresh copy of each"
      ]
    },
    {
      "id": "Belt_MutableSetInt.checkInvariantInternal",
      "kind": "value",
      "name": "checkInvariantInternal",
      "signature": "let checkInvariantInternal: t => unit",
      "docstrings": [
        "**raise** when invariant is not held"
      ]
    }
  ]
}