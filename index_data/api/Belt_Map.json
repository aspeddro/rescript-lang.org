{
  "name": "Belt_Map",
  "docstrings": [
    "The top level provides generic immutable map operations.\n\n    It also has three specialized inner modules `Belt.Map.Int`,\n    `Belt.Map.String` and `Belt.Map.Dict`."
  ],
  "items": [
    {
      "id": "Belt_Map.Belt_MapInt",
      "kind": "moduleAlias",
      "docstrings": [],
      "signature": "module Int = Belt_MapInt"
    },
    {
      "id": "Belt_Map.Belt_MapString",
      "kind": "moduleAlias",
      "docstrings": [],
      "signature": "module String = Belt_MapString"
    },
    {
      "id": "Belt_Map.Belt_MapDict",
      "kind": "moduleAlias",
      "docstrings": [],
      "signature": "module Dict = Belt_MapDict"
    },
    {
      "id": "Belt_Map.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'key, 'value, 'identity>",
      "docstrings": [
        "`'key` is the field type\n\n    `'value` is the element type\n\n    `'identity` the identity of the collection"
      ]
    },
    {
      "id": "Belt_Map.id",
      "kind": "type",
      "name": "id",
      "signature": "type id<'key, 'id> = Belt_Id.comparable<'key, 'id>",
      "docstrings": [
        "The identity needed for making an empty map."
      ]
    },
    {
      "id": "Belt_Map.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (~id: id<'k, 'id>) => t<'k, 'v, 'id>",
      "docstrings": [
        "`make(~id)` creates a new map by taking in the comparator.\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let m = Belt.Map.make(~id=module(IntCmp))\n\n    Belt.Map.set(m, 0, \"a\")\n    ```"
      ]
    },
    {
      "id": "Belt_Map.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a, 'b, 'c> => bool",
      "docstrings": [
        "`isEmpty(m)` checks whether a map m is empty.\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.isEmpty(Belt.Map.fromArray([(1, \"1\")], ~id=module(IntCmp))) == false\n    ```"
      ]
    },
    {
      "id": "Belt_Map.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'k, 'v, 'id>, 'k) => bool",
      "docstrings": [
        "`has(m, k)` checks whether `m` has the key `k`.\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.has(Belt.Map.fromArray([(1, \"1\")], ~id=module(IntCmp)), 1) == true\n    ```"
      ]
    },
    {
      "id": "Belt_Map.cmpU",
      "kind": "value",
      "name": "cmpU",
      "signature": "let cmpU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, (. 'v, 'v) => int) => int",
      "docstrings": []
    },
    {
      "id": "Belt_Map.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => int) => int",
      "docstrings": [
        "`cmp(m0, m1, vcmp);`\n\n    Total ordering of map given total ordering of value function.\n\n    It will compare size first and each element following the order one by one."
      ]
    },
    {
      "id": "Belt_Map.eqU",
      "kind": "value",
      "name": "eqU",
      "signature": "let eqU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, (. 'v, 'v) => bool) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_Map.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => bool) => bool",
      "docstrings": [
        "`eq(m1, m2, veq)` tests whether the maps `m1` and `m2` are equal, that is,\n    contain equal keys and associate them with equal data. `veq` is the\n    equality predicate used to compare the data associated with the keys."
      ]
    },
    {
      "id": "Belt_Map.findFirstByU",
      "kind": "value",
      "name": "findFirstByU",
      "signature": "let findFirstByU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => option<('k, 'v)>",
      "docstrings": []
    },
    {
      "id": "Belt_Map.findFirstBy",
      "kind": "value",
      "name": "findFirstBy",
      "signature": "let findFirstBy: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>",
      "docstrings": [
        "`findFirstBy(m, p)` uses function `f` to find the first key value pair to\n    match predicate `p`.\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"\")])\n\n    Belt.Map.findFirstBy(s0, (k, v) => k == 4) /* (4, \"4\") */\n    ```"
      ]
    },
    {
      "id": "Belt_Map.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'k, 'v, 'id>, (. 'k, 'v) => unit) => unit",
      "docstrings": []
    },
    {
      "id": "Belt_Map.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'k, 'v, 'id>, ('k, 'v) => unit) => unit",
      "docstrings": [
        "`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the\n    `'k` as first argument, and the associated value as second argument. The\n    bindings are passed to `f` in increasing order with respect to the ordering\n    over the type of the keys.\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"\")])\n\n    let acc = ref(list{})\n\n    Belt.Map.forEach(s0, (k, v) => acc := list{(k, v), ...acc.contents})\n\n    acc.contents == list{(4, \"4\"), (3, \"3\"), (2, \"2\"), (1, \"1\")}\n    ```"
      ]
    },
    {
      "id": "Belt_Map.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'k, 'v, 'id>, 'acc, (. 'acc, 'k, 'v) => 'acc) => 'acc",
      "docstrings": []
    },
    {
      "id": "Belt_Map.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'k, 'v, 'id>, 'acc, ('acc, 'k, 'v) => 'acc) => 'acc",
      "docstrings": [
        "`reduce(m, a, f)` computes `(f(kN, dN) ... (f(k1, d1, a))...)`, where `k1\n    ... kN` are the keys of all bindings in m (in increasing order), and `d1\n    ... dN` are the associated data.\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"3\")])\n\n    Belt.Map.reduce(s0, list{}, (acc, k, v) => list{\n      (k, v),\n      ...acc,\n    }) /* [(4, \"4\"), (3, \"3\"), (2, \"2\"), (1, \"1\"), 0] */\n    ```"
      ]
    },
    {
      "id": "Belt_Map.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_Map.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool",
      "docstrings": [
        "`every(m, p)` checks if all the bindings of the map satisfy the predicate\n    `p`. Order unspecified"
      ]
    },
    {
      "id": "Belt_Map.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_Map.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool",
      "docstrings": [
        "`some(m, p)` checks if at least one binding of the map satisfy the\n    predicate `p`. Order unspecified"
      ]
    },
    {
      "id": "Belt_Map.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'k, 'v, 'id> => int",
      "docstrings": [
        "`size(s)`\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.size(Belt.Map.fromArray([(2, \"2\"), (2, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == 2\n    ```"
      ]
    },
    {
      "id": "Belt_Map.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'k, 'v, 'id> => array<('k, 'v)>",
      "docstrings": [
        "`toArray(s)`\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.toArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        (1, \"1\"),\n        (2, \"2\"),\n        (3, \"3\"),\n      ]\n    ```"
      ]
    },
    {
      "id": "Belt_Map.toList",
      "kind": "value",
      "name": "toList",
      "signature": "let toList: t<'k, 'v, 'id> => list<('k, 'v)>",
      "docstrings": [
        "In increasing order.\n\n    See `Belt.Map.toArray`"
      ]
    },
    {
      "id": "Belt_Map.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: (array<('k, 'v)>, ~id: id<'k, 'id>) => t<'k, 'v, 'id>",
      "docstrings": [
        "`fromArray(kvs, ~id);`\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.toArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        (1, \"1\"),\n        (2, \"2\"),\n        (3, \"3\"),\n      ]\n    ```"
      ]
    },
    {
      "id": "Belt_Map.keysToArray",
      "kind": "value",
      "name": "keysToArray",
      "signature": "let keysToArray: t<'k, 'v, 'id> => array<'k>",
      "docstrings": [
        "`keysToArray(s);`\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.keysToArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        1,\n        2,\n        3,\n      ]\n    ```"
      ]
    },
    {
      "id": "Belt_Map.valuesToArray",
      "kind": "value",
      "name": "valuesToArray",
      "signature": "let valuesToArray: t<'k, 'v, 'id> => array<'v>",
      "docstrings": [
        "`valuesToArray(s);`\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.valuesToArray(\n      Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)),\n    ) == [\"1\", \"2\", \"3\"]\n    ```"
      ]
    },
    {
      "id": "Belt_Map.minKey",
      "kind": "value",
      "name": "minKey",
      "signature": "let minKey: t<'k, 'a, 'b> => option<'k>",
      "docstrings": [
        "`minKey(s)` returns the minimum key, None if not exist."
      ]
    },
    {
      "id": "Belt_Map.minKeyUndefined",
      "kind": "value",
      "name": "minKeyUndefined",
      "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>",
      "docstrings": [
        "See `Belt.Map.minKey`"
      ]
    },
    {
      "id": "Belt_Map.maxKey",
      "kind": "value",
      "name": "maxKey",
      "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>",
      "docstrings": [
        "`maxKey(s)` returns the maximum key, None if not exist."
      ]
    },
    {
      "id": "Belt_Map.maxKeyUndefined",
      "kind": "value",
      "name": "maxKeyUndefined",
      "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>",
      "docstrings": [
        "See `Belt.Map.maxKey`"
      ]
    },
    {
      "id": "Belt_Map.minimum",
      "kind": "value",
      "name": "minimum",
      "signature": "let minimum: t<'k, 'v, 'a> => option<('k, 'v)>",
      "docstrings": [
        "`minimum(s)` returns the minimum key value pair, None if not exist."
      ]
    },
    {
      "id": "Belt_Map.minUndefined",
      "kind": "value",
      "name": "minUndefined",
      "signature": "let minUndefined: t<'k, 'v, 'a> => Js.undefined<('k, 'v)>",
      "docstrings": [
        "See `Belt.Map.minimum`"
      ]
    },
    {
      "id": "Belt_Map.maximum",
      "kind": "value",
      "name": "maximum",
      "signature": "let maximum: t<'k, 'v, 'a> => option<('k, 'v)>",
      "docstrings": [
        "`maximum(s)` returns the maximum key value pair, None if not exist."
      ]
    },
    {
      "id": "Belt_Map.maxUndefined",
      "kind": "value",
      "name": "maxUndefined",
      "signature": "let maxUndefined: t<'k, 'v, 'a> => Js.undefined<('k, 'v)>",
      "docstrings": [
        "See `Belt.Map.maximum`"
      ]
    },
    {
      "id": "Belt_Map.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'k, 'v, 'id>, 'k) => option<'v>",
      "docstrings": [
        "`get(s, k)`\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.get(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)), 2) ==\n      Some(\"2\")\n\n    Belt.Map.get(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)), 2) == None\n    ```"
      ]
    },
    {
      "id": "Belt_Map.getUndefined",
      "kind": "value",
      "name": "getUndefined",
      "signature": "let getUndefined: (t<'k, 'v, 'id>, 'k) => Js.undefined<'v>",
      "docstrings": [
        "See `Belt.Map.get`\n\n    Returns `undefined` when not found"
      ]
    },
    {
      "id": "Belt_Map.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "signature": "let getWithDefault: (t<'k, 'v, 'id>, 'k, 'v) => 'v",
      "docstrings": [
        "`getWithDefault(s, k, default)`\n\n    See `Belt.Map.get`\n\n    Returns default when `k` is not found."
      ]
    },
    {
      "id": "Belt_Map.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'k, 'v, 'id>, 'k) => 'v",
      "docstrings": [
        "`getExn(s, k)`\n\n    See `Belt.Map.getExn`\n\n    raise when `k` not exist"
      ]
    },
    {
      "id": "Belt_Map.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'k, 'v, 'id>, 'k) => t<'k, 'v, 'id>",
      "docstrings": [
        "`remove(m, x)` when `x` is not in `m`, `m` is returned reference unchanged.\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))\n\n    let s1 = Belt.Map.remove(s0, 1)\n\n    let s2 = Belt.Map.remove(s1, 1)\n\n    s1 === s2\n\n    Belt.Map.keysToArray(s1) == [2, 3]\n    ```"
      ]
    },
    {
      "id": "Belt_Map.removeMany",
      "kind": "value",
      "name": "removeMany",
      "signature": "let removeMany: (t<'k, 'v, 'id>, array<'k>) => t<'k, 'v, 'id>",
      "docstrings": [
        "`removeMany(s, xs)`\n\n    Removing each of `xs` to `s`, note unlike `Belt.Map.remove`, the reference\n    of return value might be changed even if none in `xs` exists `s`."
      ]
    },
    {
      "id": "Belt_Map.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'k, 'v, 'id>, 'k, 'v) => t<'k, 'v, 'id>",
      "docstrings": [
        "`set(m, x, y)` returns a map containing the same bindings as `m`, with a\n    new binding of `x` to `y`. If `x` was already bound in `m`, its previous\n    binding disappears.\n\n    ```res example\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))\n\n    let s1 = Belt.Map.set(s0, 2, \"3\")\n\n    Belt.Map.valuesToArray(s1) == [\"1\", \"3\", \"3\"]\n    ```"
      ]
    },
    {
      "id": "Belt_Map.updateU",
      "kind": "value",
      "name": "updateU",
      "signature": "let updateU: (t<'k, 'v, 'id>, 'k, (. option<'v>) => option<'v>) => t<'k, 'v, 'id>",
      "docstrings": []
    },
    {
      "id": "Belt_Map.update",
      "kind": "value",
      "name": "update",
      "signature": "let update: (t<'k, 'v, 'id>, 'k, option<'v> => option<'v>) => t<'k, 'v, 'id>",
      "docstrings": [
        "`update(m, x, f)` returns a map containing the same bindings as `m`, except\n    for the binding of `x`. Depending on the value of `y` where `y` is\n    `f(get(m, x))`, the binding of `x` is added, removed or updated. If `y` is\n    `None`, the binding is removed if it exists; otherwise, if `y` is `Some(z)`\n    then `x` is associated to `z` in the resulting map."
      ]
    },
    {
      "id": "Belt_Map.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t<'k, 'v, 'id>, array<('k, 'v)>) => t<'k, 'v, 'id>",
      "docstrings": [
        "`mergeMany(s, xs)`\n\n    Adding each of `xs` to `s`, note unlike `add`, the reference of return\n    value might be changed even if all values in `xs` exist `s`."
      ]
    },
    {
      "id": "Belt_Map.mergeU",
      "kind": "value",
      "name": "mergeU",
      "signature": "let mergeU: (\\n  t<'k, 'v, 'id>,\\n  t<'k, 'v2, 'id>,\\n  (. 'k, option<'v>, option<'v2>) => option<'v3>,\\n) => t<'k, 'v3, 'id>",
      "docstrings": []
    },
    {
      "id": "Belt_Map.merge",
      "kind": "value",
      "name": "merge",
      "signature": "let merge: (\\n  t<'k, 'v, 'id>,\\n  t<'k, 'v2, 'id>,\\n  ('k, option<'v>, option<'v2>) => option<'v3>,\\n) => t<'k, 'v3, 'id>",
      "docstrings": [
        "`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\n    and of `m2`. The presence of each such binding, and the corresponding\n    value, is determined with the function `f`."
      ]
    },
    {
      "id": "Belt_Map.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => t<'k, 'v, 'id>",
      "docstrings": []
    },
    {
      "id": "Belt_Map.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (t<'k, 'v, 'id>, ('k, 'v) => bool) => t<'k, 'v, 'id>",
      "docstrings": [
        "`keep(m, p)` returns the map with all the bindings in m that satisfy\n    predicate `p`."
      ]
    },
    {
      "id": "Belt_Map.partitionU",
      "kind": "value",
      "name": "partitionU",
      "signature": "let partitionU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => (t<'k, 'v, 'id>, t<'k, 'v, 'id>)",
      "docstrings": []
    },
    {
      "id": "Belt_Map.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t<'k, 'v, 'id>, ('k, 'v) => bool) => (t<'k, 'v, 'id>, t<'k, 'v, 'id>)",
      "docstrings": [
        "`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains\n    all the bindings of `s` that satisfy the predicate `p`, and `m2` is the map\n    with all the bindings of `s` that do not satisfy `p`."
      ]
    },
    {
      "id": "Belt_Map.split",
      "kind": "value",
      "name": "split",
      "signature": "let split: (t<'k, 'v, 'id>, 'k) => ((t<'k, 'v, 'id>, t<'k, 'v, 'id>), option<'v>)",
      "docstrings": [
        "`split(x, m)` returns a tuple `(l, r)`, data, where `l` is the map with all\n    the bindings of `m` whose 'k is strictly less than `x`; `r` is the map with\n    all the bindings of m whose 'k is strictly greater than `x`; `data` is\n    `None` if `m` contains no binding for `x`, or `Some(v)` if `m` binds `v` to\n    `x`."
      ]
    },
    {
      "id": "Belt_Map.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (t<'k, 'v, 'id>, (. 'v) => 'v2) => t<'k, 'v2, 'id>",
      "docstrings": []
    },
    {
      "id": "Belt_Map.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'k, 'v, 'id>, 'v => 'v2) => t<'k, 'v2, 'id>",
      "docstrings": [
        "`map(m, f) returns a map with same domain as`m`, where the associated\n    value`a`of all bindings of`m`has been replaced by the result of the\n    application of`f`to`a`. The bindings are passed to`f` in increasing order\n    with respect to the ordering over the type of the keys."
      ]
    },
    {
      "id": "Belt_Map.mapWithKeyU",
      "kind": "value",
      "name": "mapWithKeyU",
      "signature": "let mapWithKeyU: (t<'k, 'v, 'id>, (. 'k, 'v) => 'v2) => t<'k, 'v2, 'id>",
      "docstrings": []
    },
    {
      "id": "Belt_Map.mapWithKey",
      "kind": "value",
      "name": "mapWithKey",
      "signature": "let mapWithKey: (t<'k, 'v, 'id>, ('k, 'v) => 'v2) => t<'k, 'v2, 'id>",
      "docstrings": [
        "`mapWithKey(m, f)`\n\n    The same as `Belt.Map.map` except that `f` is supplied with one more\n    argument: the key."
      ]
    },
    {
      "id": "Belt_Map.getData",
      "kind": "value",
      "name": "getData",
      "signature": "let getData: t<'k, 'v, 'id> => Belt_MapDict.t<'k, 'v, 'id>",
      "docstrings": [
        "`getData(s0)`\n\n    Advanced usage only\n\n    Returns the raw data (detached from comparator), but its type is still\n    manifested, so that user can pass identity directly without boxing."
      ]
    },
    {
      "id": "Belt_Map.getId",
      "kind": "value",
      "name": "getId",
      "signature": "let getId: t<'k, 'v, 'id> => id<'k, 'id>",
      "docstrings": [
        "Advanced usage only\n\n    Returns the identity of s0."
      ]
    },
    {
      "id": "Belt_Map.packIdData",
      "kind": "value",
      "name": "packIdData",
      "signature": "let packIdData: (~id: id<'k, 'id>, ~data: Belt_MapDict.t<'k, 'v, 'id>) => t<'k, 'v, 'id>",
      "docstrings": [
        "`packIdData(~id, ~data)`\n\n    Advanced usage only\n\n    Returns the packed collection."
      ]
    },
    {
      "id": "Belt_Map.checkInvariantInternal",
      "kind": "value",
      "name": "checkInvariantInternal",
      "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit",
      "docstrings": [
        "**raise** when invariant is not held"
      ]
    }
  ]
}