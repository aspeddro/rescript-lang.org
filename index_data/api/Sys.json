{
  "name": "Sys",
  "docstrings": [],
  "items": [
    {
      "id": "Sys.argv",
      "kind": "value",
      "name": "argv",
      "signature": "let argv: array<string>",
      "docstrings": [
        "The command line arguments given to the process.\n   The first element is the command name used to invoke the program.\n   The following elements are the command-line arguments\n   given to the program."
      ]
    },
    {
      "id": "Sys.executable_name",
      "kind": "value",
      "name": "executable_name",
      "signature": "let executable_name: string",
      "docstrings": [
        "The name of the file containing the executable currently running."
      ]
    },
    {
      "id": "Sys.file_exists",
      "kind": "value",
      "name": "file_exists",
      "signature": "let file_exists: string => bool",
      "docstrings": [
        "Test if a file with the given name exists."
      ]
    },
    {
      "id": "Sys.is_directory",
      "kind": "value",
      "name": "is_directory",
      "signature": "let is_directory: string => bool",
      "docstrings": [
        "Returns [true] if the given name refers to a directory,\n    [false] if it refers to another kind of file.\n    Raise [Sys_error] if no file exists with the given name.\n    @since 3.10.0"
      ]
    },
    {
      "id": "Sys.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: string => unit",
      "docstrings": [
        "Remove the given file name from the file system."
      ]
    },
    {
      "id": "Sys.rename",
      "kind": "value",
      "name": "rename",
      "signature": "let rename: (string, string) => unit",
      "docstrings": [
        "Rename a file.  [rename oldpath newpath] renames the file\n    called [oldpath], giving it [newpath] as its new name,\n    moving it between directories if needed.  If [newpath] already\n    exists, its contents will be replaced with those of [oldpath].\n    Depending on the operating system, the metadata (permissions,\n    owner, etc) of [newpath] can either be preserved or be replaced by\n    those of [oldpath].\n   @since 4.06 concerning the \"replace existing file\" behavior"
      ]
    },
    {
      "id": "Sys.getenv",
      "kind": "value",
      "name": "getenv",
      "signature": "let getenv: string => string",
      "docstrings": [
        "Return the value associated to a variable in the process\n   environment. Raise [Not_found] if the variable is unbound."
      ]
    },
    {
      "id": "Sys.getenv_opt",
      "kind": "value",
      "name": "getenv_opt",
      "signature": "let getenv_opt: string => option<string>",
      "docstrings": [
        "Return the value associated to a variable in the process\n    environment or [None] if the variable is unbound.\n    @since 4.05"
      ]
    },
    {
      "id": "Sys.command",
      "kind": "value",
      "name": "command",
      "signature": "let command: string => int",
      "docstrings": [
        "Execute the given shell command and return its exit code."
      ]
    },
    {
      "id": "Sys.time",
      "kind": "value",
      "name": "time",
      "signature": "let time: unit => float",
      "docstrings": [
        "Return the processor time, in seconds, used by the program\n   since the beginning of execution."
      ]
    },
    {
      "id": "Sys.chdir",
      "kind": "value",
      "name": "chdir",
      "signature": "let chdir: string => unit",
      "docstrings": [
        "Change the current working directory of the process."
      ]
    },
    {
      "id": "Sys.getcwd",
      "kind": "value",
      "name": "getcwd",
      "signature": "let getcwd: unit => string",
      "docstrings": [
        "Return the current working directory of the process."
      ]
    },
    {
      "id": "Sys.readdir",
      "kind": "value",
      "name": "readdir",
      "signature": "let readdir: string => array<string>",
      "docstrings": [
        "Return the names of all files present in the given directory.\n   Names denoting the current directory and the parent directory\n   ([\".\"] and [\"..\"] in Unix) are not returned.  Each string in the\n   result is a file name rather than a complete path.  There is no\n   guarantee that the name strings in the resulting array will appear\n   in any specific order; they are not, in particular, guaranteed to\n   appear in alphabetical order."
      ]
    },
    {
      "id": "Sys.interactive",
      "kind": "value",
      "name": "interactive",
      "signature": "let interactive: ref<bool>",
      "docstrings": [
        "This reference is initially set to [false] in standalone\n   programs and to [true] if the code is being executed under\n   the interactive toplevel system [ocaml]."
      ]
    },
    {
      "id": "Sys.os_type",
      "kind": "value",
      "name": "os_type",
      "signature": "let os_type: string",
      "docstrings": [
        "Operating system currently executing the OCaml program. One of\n-  [\"Unix\"] (for all Unix versions, including Linux and Mac OS X),\n-  [\"Win32\"] (for MS-Windows, OCaml compiled with MSVC++ or Mingw),\n-  [\"Cygwin\"] (for MS-Windows, OCaml compiled with Cygwin)."
      ]
    },
    {
      "id": "Sys.backend_type",
      "kind": "type",
      "name": "backend_type",
      "signature": "type backend_type = Native | Bytecode | Other(string)",
      "docstrings": [
        "Currently, the official distribution only supports [Native] and\n    [Bytecode], but it can be other backends with alternative\n    compilers, for example, javascript.\n\n    @since 4.04.0"
      ],
      "detail": {
        "kind": "variant",
        "constructorDocs": [
          {
            "constructorName": "Native",
            "docstrings": [],
            "signature": "Native"
          },
          {
            "constructorName": "Bytecode",
            "docstrings": [],
            "signature": "Bytecode"
          },
          {
            "constructorName": "Other",
            "docstrings": [],
            "signature": "Other(string)"
          }
        ]
      }
    },
    {
      "id": "Sys.backend_type",
      "kind": "value",
      "name": "backend_type",
      "signature": "let backend_type: backend_type",
      "docstrings": [
        "Backend type  currently executing the OCaml program.\n    @since 4.04.0"
      ]
    },
    {
      "id": "Sys.unix",
      "kind": "value",
      "name": "unix",
      "signature": "let unix: bool",
      "docstrings": [
        "True if [Sys.os_type = \"Unix\"].\n    @since 4.01.0"
      ]
    },
    {
      "id": "Sys.win32",
      "kind": "value",
      "name": "win32",
      "signature": "let win32: bool",
      "docstrings": [
        "True if [Sys.os_type = \"Win32\"].\n    @since 4.01.0"
      ]
    },
    {
      "id": "Sys.cygwin",
      "kind": "value",
      "name": "cygwin",
      "signature": "let cygwin: bool",
      "docstrings": [
        "True if [Sys.os_type = \"Cygwin\"].\n    @since 4.01.0"
      ]
    },
    {
      "id": "Sys.word_size",
      "kind": "value",
      "name": "word_size",
      "signature": "let word_size: int",
      "docstrings": [
        "Size of one word on the machine currently executing the OCaml\n   program, in bits: 32 or 64."
      ]
    },
    {
      "id": "Sys.int_size",
      "kind": "value",
      "name": "int_size",
      "signature": "let int_size: int",
      "docstrings": [
        "Size of an int.  It is 31 bits (resp. 63 bits) when using the\n    OCaml compiler on a 32 bits (resp. 64 bits) platform.  It may\n    differ for other compilers, e.g. it is 32 bits when compiling to\n    JavaScript.\n    @since 4.03.0"
      ]
    },
    {
      "id": "Sys.big_endian",
      "kind": "value",
      "name": "big_endian",
      "signature": "let big_endian: bool",
      "docstrings": [
        "Whether the machine currently executing the Caml program is big-endian.\n    @since 4.00.0"
      ]
    },
    {
      "id": "Sys.max_string_length",
      "kind": "value",
      "name": "max_string_length",
      "signature": "let max_string_length: int",
      "docstrings": [
        "Maximum length of strings and byte sequences."
      ]
    },
    {
      "id": "Sys.max_array_length",
      "kind": "value",
      "name": "max_array_length",
      "signature": "let max_array_length: int",
      "docstrings": [
        "Maximum length of a normal array.  The maximum length of a float\n    array is [max_array_length/2] on 32-bit machines and\n    [max_array_length] on 64-bit machines."
      ]
    },
    {
      "id": "Sys.runtime_variant",
      "kind": "value",
      "name": "runtime_variant",
      "signature": "let runtime_variant: unit => string",
      "docstrings": [
        "Return the name of the runtime variant the program is running on.\n    This is normally the argument given to [-runtime-variant] at compile\n    time, but for byte-code it can be changed after compilation.\n    @since 4.03.0"
      ]
    },
    {
      "id": "Sys.runtime_parameters",
      "kind": "value",
      "name": "runtime_parameters",
      "signature": "let runtime_parameters: unit => string",
      "docstrings": [
        "Return the value of the runtime parameters, in the same format\n    as the contents of the [OCAMLRUNPARAM] environment variable.\n    @since 4.03.0"
      ]
    },
    {
      "id": "Sys.signal_behavior",
      "kind": "type",
      "name": "signal_behavior",
      "signature": "type signal_behavior =\\n  | Signal_default\\n  | Signal_ignore\\n  | Signal_handle(int => unit)",
      "docstrings": [
        "What to do when receiving a signal:\n   - [Signal_default]: take the default behavior\n     (usually: abort the program)\n   - [Signal_ignore]: ignore the signal\n   - [Signal_handle f]: call function [f], giving it the signal\n   number as argument."
      ],
      "detail": {
        "kind": "variant",
        "constructorDocs": [
          {
            "constructorName": "Signal_default",
            "docstrings": [],
            "signature": "Signal_default"
          },
          {
            "constructorName": "Signal_ignore",
            "docstrings": [],
            "signature": "Signal_ignore"
          },
          {
            "constructorName": "Signal_handle",
            "docstrings": [
              ""
            ],
            "signature": "Signal_handle(int => unit)"
          }
        ]
      }
    },
    {
      "id": "Sys.signal",
      "kind": "value",
      "name": "signal",
      "signature": "let signal: (int, signal_behavior) => signal_behavior",
      "docstrings": [
        "Set the behavior of the system on receipt of a given signal.  The\n   first argument is the signal number.  Return the behavior\n   previously associated with the signal. If the signal number is\n   invalid (or not available on your system), an [Invalid_argument]\n   exception is raised."
      ]
    },
    {
      "id": "Sys.set_signal",
      "kind": "value",
      "name": "set_signal",
      "signature": "let set_signal: (int, signal_behavior) => unit",
      "docstrings": [
        "Same as {!Sys.signal} but return value is ignored."
      ]
    },
    {
      "id": "Sys.sigabrt",
      "kind": "value",
      "name": "sigabrt",
      "signature": "let sigabrt: int",
      "docstrings": [
        "Abnormal termination"
      ]
    },
    {
      "id": "Sys.sigalrm",
      "kind": "value",
      "name": "sigalrm",
      "signature": "let sigalrm: int",
      "docstrings": [
        "Timeout"
      ]
    },
    {
      "id": "Sys.sigfpe",
      "kind": "value",
      "name": "sigfpe",
      "signature": "let sigfpe: int",
      "docstrings": [
        "Arithmetic exception"
      ]
    },
    {
      "id": "Sys.sighup",
      "kind": "value",
      "name": "sighup",
      "signature": "let sighup: int",
      "docstrings": [
        "Hangup on controlling terminal"
      ]
    },
    {
      "id": "Sys.sigill",
      "kind": "value",
      "name": "sigill",
      "signature": "let sigill: int",
      "docstrings": [
        "Invalid hardware instruction"
      ]
    },
    {
      "id": "Sys.sigint",
      "kind": "value",
      "name": "sigint",
      "signature": "let sigint: int",
      "docstrings": [
        "Interactive interrupt (ctrl-C)"
      ]
    },
    {
      "id": "Sys.sigkill",
      "kind": "value",
      "name": "sigkill",
      "signature": "let sigkill: int",
      "docstrings": [
        "Termination (cannot be ignored)"
      ]
    },
    {
      "id": "Sys.sigpipe",
      "kind": "value",
      "name": "sigpipe",
      "signature": "let sigpipe: int",
      "docstrings": [
        "Broken pipe"
      ]
    },
    {
      "id": "Sys.sigquit",
      "kind": "value",
      "name": "sigquit",
      "signature": "let sigquit: int",
      "docstrings": [
        "Interactive termination"
      ]
    },
    {
      "id": "Sys.sigsegv",
      "kind": "value",
      "name": "sigsegv",
      "signature": "let sigsegv: int",
      "docstrings": [
        "Invalid memory reference"
      ]
    },
    {
      "id": "Sys.sigterm",
      "kind": "value",
      "name": "sigterm",
      "signature": "let sigterm: int",
      "docstrings": [
        "Termination"
      ]
    },
    {
      "id": "Sys.sigusr1",
      "kind": "value",
      "name": "sigusr1",
      "signature": "let sigusr1: int",
      "docstrings": [
        "Application-defined signal 1"
      ]
    },
    {
      "id": "Sys.sigusr2",
      "kind": "value",
      "name": "sigusr2",
      "signature": "let sigusr2: int",
      "docstrings": [
        "Application-defined signal 2"
      ]
    },
    {
      "id": "Sys.sigchld",
      "kind": "value",
      "name": "sigchld",
      "signature": "let sigchld: int",
      "docstrings": [
        "Child process terminated"
      ]
    },
    {
      "id": "Sys.sigcont",
      "kind": "value",
      "name": "sigcont",
      "signature": "let sigcont: int",
      "docstrings": [
        "Continue"
      ]
    },
    {
      "id": "Sys.sigstop",
      "kind": "value",
      "name": "sigstop",
      "signature": "let sigstop: int",
      "docstrings": [
        "Stop"
      ]
    },
    {
      "id": "Sys.sigtstp",
      "kind": "value",
      "name": "sigtstp",
      "signature": "let sigtstp: int",
      "docstrings": [
        "Interactive stop"
      ]
    },
    {
      "id": "Sys.sigttin",
      "kind": "value",
      "name": "sigttin",
      "signature": "let sigttin: int",
      "docstrings": [
        "Terminal read from background process"
      ]
    },
    {
      "id": "Sys.sigttou",
      "kind": "value",
      "name": "sigttou",
      "signature": "let sigttou: int",
      "docstrings": [
        "Terminal write from background process"
      ]
    },
    {
      "id": "Sys.sigvtalrm",
      "kind": "value",
      "name": "sigvtalrm",
      "signature": "let sigvtalrm: int",
      "docstrings": [
        "Timeout in virtual time"
      ]
    },
    {
      "id": "Sys.sigprof",
      "kind": "value",
      "name": "sigprof",
      "signature": "let sigprof: int",
      "docstrings": [
        "Profiling interrupt"
      ]
    },
    {
      "id": "Sys.sigbus",
      "kind": "value",
      "name": "sigbus",
      "signature": "let sigbus: int",
      "docstrings": [
        "Bus error\n    @since 4.03"
      ]
    },
    {
      "id": "Sys.sigpoll",
      "kind": "value",
      "name": "sigpoll",
      "signature": "let sigpoll: int",
      "docstrings": [
        "Pollable event\n    @since 4.03"
      ]
    },
    {
      "id": "Sys.sigsys",
      "kind": "value",
      "name": "sigsys",
      "signature": "let sigsys: int",
      "docstrings": [
        "Bad argument to routine\n    @since 4.03"
      ]
    },
    {
      "id": "Sys.sigtrap",
      "kind": "value",
      "name": "sigtrap",
      "signature": "let sigtrap: int",
      "docstrings": [
        "Trace/breakpoint trap\n    @since 4.03"
      ]
    },
    {
      "id": "Sys.sigurg",
      "kind": "value",
      "name": "sigurg",
      "signature": "let sigurg: int",
      "docstrings": [
        "Urgent condition on socket\n    @since 4.03"
      ]
    },
    {
      "id": "Sys.sigxcpu",
      "kind": "value",
      "name": "sigxcpu",
      "signature": "let sigxcpu: int",
      "docstrings": [
        "Timeout in cpu time\n    @since 4.03"
      ]
    },
    {
      "id": "Sys.sigxfsz",
      "kind": "value",
      "name": "sigxfsz",
      "signature": "let sigxfsz: int",
      "docstrings": [
        "File size limit exceeded\n    @since 4.03"
      ]
    },
    {
      "id": "Sys.catch_break",
      "kind": "value",
      "name": "catch_break",
      "signature": "let catch_break: bool => unit",
      "docstrings": [
        "[catch_break] governs whether interactive interrupt (ctrl-C)\n   terminates the program or raises the [Break] exception.\n   Call [catch_break true] to enable raising [Break],\n   and [catch_break false] to let the system\n   terminate the program on user interrupt."
      ]
    },
    {
      "id": "Sys.ocaml_version",
      "kind": "value",
      "name": "ocaml_version",
      "signature": "let ocaml_version: string",
      "docstrings": [
        "[ocaml_version] is the version of OCaml.\n    It is a string of the form [\"major.minor[.patchlevel][+additional-info]\"],\n    where [major], [minor], and [patchlevel] are integers, and\n    [additional-info] is an arbitrary string. The [[.patchlevel]] and\n    [[+additional-info]] parts may be absent."
      ]
    },
    {
      "id": "Sys.enable_runtime_warnings",
      "kind": "value",
      "name": "enable_runtime_warnings",
      "signature": "let enable_runtime_warnings: bool => unit",
      "docstrings": [
        "Control whether the OCaml runtime system can emit warnings\n    on stderr.  Currently, the only supported warning is triggered\n    when a channel created by [open_*] functions is finalized without\n    being closed.  Runtime warnings are enabled by default.\n\n    @since 4.03.0"
      ]
    },
    {
      "id": "Sys.runtime_warnings_enabled",
      "kind": "value",
      "name": "runtime_warnings_enabled",
      "signature": "let runtime_warnings_enabled: unit => bool",
      "docstrings": [
        "Return whether runtime warnings are currently enabled.\n\n    @since 4.03.0"
      ]
    },
    {
      "id": "Sys.opaque_identity",
      "kind": "value",
      "name": "opaque_identity",
      "signature": "let opaque_identity: 'a => 'a",
      "docstrings": [
        "For the purposes of optimization, [opaque_identity] behaves like an\n    unknown (and thus possibly side-effecting) function.\n\n    At runtime, [opaque_identity] disappears altogether.\n\n    A typical use of this function is to prevent pure computations from being\n    optimized away in benchmarking loops.  For example:\n    {[\n      for _round = 1 to 100_000 do\n        ignore (Sys.opaque_identity (my_pure_computation ()))\n      done\n    ]}\n\n    @since 4.03.0"
      ]
    }
  ]
}