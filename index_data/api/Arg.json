{
  "name": "Arg",
  "docstrings": [
    "Parsing of command line arguments.\n\n   This module provides a general mechanism for extracting options and\n   arguments from the command line to the program.\n\n   Syntax of command lines:\n    A keyword is a character string starting with a [-].\n    An option is a keyword alone or followed by an argument.\n    The types of keywords are: [Unit], [Bool], [Set], [Clear],\n    [String], [Set_string], [Int], [Set_int], [Float], [Set_float],\n    [Tuple], [Symbol], and [Rest].\n    [Unit], [Set] and [Clear] keywords take no argument. A [Rest]\n    keyword takes the remaining of the command line as arguments.\n    Every other keyword takes the following word on the command line\n    as argument.  For compatibility with GNU getopt_long, [keyword=arg]\n    is also allowed.\n    Arguments not preceded by a keyword are called anonymous arguments.\n\n   Examples ([cmd] is assumed to be the command name):\n-   [cmd -flag           ](a unit option)\n-   [cmd -int 1          ](an int option with argument [1])\n-   [cmd -string foobar  ](a string option with argument [\\\"foobar\\\"])\n-   [cmd -float 12.34    ](a float option with argument [12.34])\n-   [cmd a b c           ](three anonymous arguments: [\\\"a\\\"], [\\\"b\\\"], and [\\\"c\\\"])\n-   [cmd a b -- c d      ](two anonymous arguments and a rest option with\n                           two arguments)"
  ],
  "items": [
    {
      "id": "Arg.spec",
      "kind": "type",
      "name": "spec",
      "signature": "type spec =\\n  | Unit(unit => unit)\\n  | Bool(bool => unit)\\n  | Set(ref<bool>)\\n  | Clear(ref<bool>)\\n  | String(string => unit)\\n  | Set_string(ref<string>)\\n  | Int(int => unit)\\n  | Set_int(ref<int>)\\n  | Float(float => unit)\\n  | Set_float(ref<float>)\\n  | Tuple(list<spec>)\\n  | Symbol(list<string>, string => unit)\\n  | Rest(string => unit)\\n  | Expand(string => array<string>)",
      "docstrings": [
        "The concrete type describing the behavior associated\n   with a keyword."
      ],
      "detail": {
        "kind": "variant",
        "constructorDocs": [
          {
            "constructorName": "Unit",
            "docstrings": [
              "Call the function with unit argument"
            ],
            "signature": "Unit(unit => unit)"
          },
          {
            "constructorName": "Bool",
            "docstrings": [
              "Call the function with a bool argument"
            ],
            "signature": "Bool(bool => unit)"
          },
          {
            "constructorName": "Set",
            "docstrings": [
              "Set the reference to true"
            ],
            "signature": "Set(ref<bool>)"
          },
          {
            "constructorName": "Clear",
            "docstrings": [
              "Set the reference to false"
            ],
            "signature": "Clear(ref<bool>)"
          },
          {
            "constructorName": "String",
            "docstrings": [
              "Call the function with a string argument"
            ],
            "signature": "String(string => unit)"
          },
          {
            "constructorName": "Set_string",
            "docstrings": [
              "Set the reference to the string argument"
            ],
            "signature": "Set_string(ref<string>)"
          },
          {
            "constructorName": "Int",
            "docstrings": [
              "Call the function with an int argument"
            ],
            "signature": "Int(int => unit)"
          },
          {
            "constructorName": "Set_int",
            "docstrings": [
              "Set the reference to the int argument"
            ],
            "signature": "Set_int(ref<int>)"
          },
          {
            "constructorName": "Float",
            "docstrings": [
              "Call the function with a float argument"
            ],
            "signature": "Float(float => unit)"
          },
          {
            "constructorName": "Set_float",
            "docstrings": [
              "Set the reference to the float argument"
            ],
            "signature": "Set_float(ref<float>)"
          },
          {
            "constructorName": "Tuple",
            "docstrings": [
              "Take several arguments according to the\n                                   spec list"
            ],
            "signature": "Tuple(list<spec>)"
          },
          {
            "constructorName": "Symbol",
            "docstrings": [
              "Take one of the symbols as argument and\n                                   call the function with the symbol"
            ],
            "signature": "Symbol(list<string>, string => unit)"
          },
          {
            "constructorName": "Rest",
            "docstrings": [
              "Stop interpreting keywords and call the\n                                   function with each remaining argument"
            ],
            "signature": "Rest(string => unit)"
          },
          {
            "constructorName": "Expand",
            "docstrings": [
              "If the remaining arguments to process\n                                           are of the form\n                                           [[\\\"-foo\\\"; \\\"arg\\\"] @ rest] where \\\"foo\\\" is\n                                           registered as [Expand f], then the\n                                           arguments [f \\\"arg\\\" @ rest] are\n                                           processed. Only allowed in\n                                           [parse_and_expand_argv_dynamic]."
            ],
            "signature": "Expand(string => array<string>)"
          }
        ]
      }
    },
    {
      "id": "Arg.key",
      "kind": "type",
      "name": "key",
      "signature": "type key = string",
      "docstrings": []
    },
    {
      "id": "Arg.doc",
      "kind": "type",
      "name": "doc",
      "signature": "type doc = string",
      "docstrings": []
    },
    {
      "id": "Arg.usage_msg",
      "kind": "type",
      "name": "usage_msg",
      "signature": "type usage_msg = string",
      "docstrings": []
    },
    {
      "id": "Arg.anon_fun",
      "kind": "type",
      "name": "anon_fun",
      "signature": "type anon_fun = string => unit",
      "docstrings": []
    },
    {
      "id": "Arg.parse",
      "kind": "value",
      "name": "parse",
      "signature": "let parse: (list<(key, spec, doc)>, anon_fun, usage_msg) => unit",
      "docstrings": [
        "[Arg.parse speclist anon_fun usage_msg] parses the command line.\n    [speclist] is a list of triples [(key, spec, doc)].\n    [key] is the option keyword, it must start with a ['-'] character.\n    [spec] gives the option type and the function to call when this option\n    is found on the command line.\n    [doc] is a one-line description of this option.\n    [anon_fun] is called on anonymous arguments.\n    The functions in [spec] and [anon_fun] are called in the same order\n    as their arguments appear on the command line.\n\n    If an error occurs, [Arg.parse] exits the program, after printing\n    to standard error an error message as follows:\n-   The reason for the error: unknown option, invalid or missing argument, etc.\n-   [usage_msg]\n-   The list of options, each followed by the corresponding [doc] string.\n    Beware: options that have an empty [doc] string will not be included in the\n    list.\n\n    For the user to be able to specify anonymous arguments starting with a\n    [-], include for example [(\\\"-\\\", String anon_fun, doc)] in [speclist].\n\n    By default, [parse] recognizes two unit options, [-help] and [--help],\n    which will print to standard output [usage_msg] and the list of\n    options, and exit the program.  You can override this behaviour\n    by specifying your own [-help] and [--help] options in [speclist]."
      ]
    },
    {
      "id": "Arg.parse_dynamic",
      "kind": "value",
      "name": "parse_dynamic",
      "signature": "let parse_dynamic: (ref<list<(key, spec, doc)>>, anon_fun, usage_msg) => unit",
      "docstrings": [
        "Same as {!Arg.parse}, except that the [speclist] argument is a reference\n    and may be updated during the parsing. A typical use for this feature\n    is to parse command lines of the form:\n-     command subcommand [options]\n    where the list of options depends on the value of the subcommand argument.\n    @since 4.01.0"
      ]
    },
    {
      "id": "Arg.parse_argv",
      "kind": "value",
      "name": "parse_argv",
      "signature": "let parse_argv: (\\n  ~current: ref<int>=?,\\n  array<string>,\\n  list<(key, spec, doc)>,\\n  anon_fun,\\n  usage_msg,\\n) => unit",
      "docstrings": [
        "[Arg.parse_argv ~current args speclist anon_fun usage_msg] parses\n  the array [args] as if it were the command line.  It uses and updates\n  the value of [~current] (if given), or {!Arg.current}.  You must set\n  it before calling [parse_argv].  The initial value of [current]\n  is the index of the program name (argument 0) in the array.\n  If an error occurs, [Arg.parse_argv] raises {!Arg.Bad} with\n  the error message as argument.  If option [-help] or [--help] is\n  given, [Arg.parse_argv] raises {!Arg.Help} with the help message\n  as argument."
      ]
    },
    {
      "id": "Arg.parse_argv_dynamic",
      "kind": "value",
      "name": "parse_argv_dynamic",
      "signature": "let parse_argv_dynamic: (\\n  ~current: ref<int>=?,\\n  array<string>,\\n  ref<list<(key, spec, doc)>>,\\n  anon_fun,\\n  string,\\n) => unit",
      "docstrings": [
        "Same as {!Arg.parse_argv}, except that the [speclist] argument is a\n    reference and may be updated during the parsing.\n    See {!Arg.parse_dynamic}.\n    @since 4.01.0"
      ]
    },
    {
      "id": "Arg.parse_and_expand_argv_dynamic",
      "kind": "value",
      "name": "parse_and_expand_argv_dynamic",
      "signature": "let parse_and_expand_argv_dynamic: (\\n  ref<int>,\\n  ref<array<string>>,\\n  ref<list<(key, spec, doc)>>,\\n  anon_fun,\\n  string,\\n) => unit",
      "docstrings": [
        "Same as {!Arg.parse_argv_dynamic}, except that the [argv] argument is a\n    reference and may be updated during the parsing of [Expand] arguments.\n    See {!Arg.parse_argv_dynamic}.\n    @since 4.05.0"
      ]
    },
    {
      "id": "Arg.parse_expand",
      "kind": "value",
      "name": "parse_expand",
      "signature": "let parse_expand: (list<(key, spec, doc)>, anon_fun, usage_msg) => unit",
      "docstrings": [
        "Same as {!Arg.parse}, except that the [Expand] arguments are allowed and\n    the {!current} reference is not updated.\n    @since 4.05.0"
      ]
    },
    {
      "id": "Arg.usage",
      "kind": "value",
      "name": "usage",
      "signature": "let usage: (list<(key, spec, doc)>, usage_msg) => unit",
      "docstrings": [
        "[Arg.usage speclist usage_msg] prints to standard error\n    an error message that includes the list of valid options.  This is\n    the same message that {!Arg.parse} prints in case of error.\n    [speclist] and [usage_msg] are the same as for {!Arg.parse}."
      ]
    },
    {
      "id": "Arg.usage_string",
      "kind": "value",
      "name": "usage_string",
      "signature": "let usage_string: (list<(key, spec, doc)>, usage_msg) => string",
      "docstrings": [
        "Returns the message that would have been printed by {!Arg.usage},\n    if provided with the same parameters."
      ]
    },
    {
      "id": "Arg.align",
      "kind": "value",
      "name": "align",
      "signature": "let align: (~limit: int=?, list<(key, spec, doc)>) => list<(key, spec, doc)>",
      "docstrings": [
        "Align the documentation strings by inserting spaces at the first alignment\n    separator (tab or, if tab is not found, space), according to the length of\n    the keyword.  Use a alignment separator as the first character in a doc\n    string if you want to align the whole string.  The doc strings corresponding\n    to [Symbol] arguments are aligned on the next line.\n    @param limit options with keyword and message longer than [limit] will not\n    be used to compute the alignment."
      ]
    },
    {
      "id": "Arg.current",
      "kind": "value",
      "name": "current",
      "signature": "let current: ref<int>",
      "docstrings": [
        "Position (in {!Sys.argv}) of the argument being processed.  You can\n    change this value, e.g. to force {!Arg.parse} to skip some arguments.\n    {!Arg.parse} uses the initial value of {!Arg.current} as the index of\n    argument 0 (the program name) and starts parsing arguments\n    at the next element."
      ]
    }
  ]
}