{
  "name": "Map",
  "docstrings": [],
  "items": [
    {
      "id": "Make.Map",
      "kind": "module",
      "item": {
        "name": "Make",
        "docstrings": [],
        "items": [
          {
            "id": "Map.Make.key",
            "kind": "type",
            "name": "key",
            "signature": "type key = Ord.t",
            "docstrings": []
          },
          {
            "id": "Map.Make.t",
            "kind": "type",
            "name": "t",
            "signature": "type t<+'a>",
            "docstrings": [
              "The type of maps from type [key] to type ['a]."
            ]
          },
          {
            "id": "Map.Make.empty",
            "kind": "value",
            "name": "empty",
            "signature": "let empty: t<'a>",
            "docstrings": [
              "The empty map."
            ]
          },
          {
            "id": "Map.Make.is_empty",
            "kind": "value",
            "name": "is_empty",
            "signature": "let is_empty: t<'a> => bool",
            "docstrings": [
              "Test whether a map is empty or not."
            ]
          },
          {
            "id": "Map.Make.mem",
            "kind": "value",
            "name": "mem",
            "signature": "let mem: (key, t<'a>) => bool",
            "docstrings": [
              "[mem x m] returns [true] if [m] contains a binding for [x],\n       and [false] otherwise."
            ]
          },
          {
            "id": "Map.Make.add",
            "kind": "value",
            "name": "add",
            "signature": "let add: (key, 'a, t<'a>) => t<'a>",
            "docstrings": [
              "[add x y m] returns a map containing the same bindings as\n       [m], plus a binding of [x] to [y]. If [x] was already bound\n       in [m] to a value that is physically equal to [y],\n       [m] is returned unchanged (the result of the function is\n       then physically equal to [m]). Otherwise, the previous binding\n       of [x] in [m] disappears.\n       @before 4.03 Physical equality was not ensured."
            ]
          },
          {
            "id": "Map.Make.update",
            "kind": "value",
            "name": "update",
            "signature": "let update: (key, option<'a> => option<'a>, t<'a>) => t<'a>",
            "docstrings": [
              "[update x f m] returns a map containing the same bindings as\n        [m], except for the binding of [x]. Depending on the value of\n        [y] where [y] is [f (find_opt x m)], the binding of [x] is\n        added, removed or updated. If [y] is [None], the binding is\n        removed if it exists; otherwise, if [y] is [Some z] then [x]\n        is associated to [z] in the resulting map.  If [x] was already\n        bound in [m] to a value that is physically equal to [z], [m]\n        is returned unchanged (the result of the function is then\n        physically equal to [m]).\n        @since 4.06.0"
            ]
          },
          {
            "id": "Map.Make.singleton",
            "kind": "value",
            "name": "singleton",
            "signature": "let singleton: (key, 'a) => t<'a>",
            "docstrings": [
              "[singleton x y] returns the one-element map that contains a binding [y]\n        for [x].\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.remove",
            "kind": "value",
            "name": "remove",
            "signature": "let remove: (key, t<'a>) => t<'a>",
            "docstrings": [
              "[remove x m] returns a map containing the same bindings as\n       [m], except for [x] which is unbound in the returned map.\n       If [x] was not in [m], [m] is returned unchanged\n       (the result of the function is then physically equal to [m]).\n       @before 4.03 Physical equality was not ensured."
            ]
          },
          {
            "id": "Map.Make.merge",
            "kind": "value",
            "name": "merge",
            "signature": "let merge: ((key, option<'a>, option<'b>) => option<'c>, t<'a>, t<'b>) => t<'c>",
            "docstrings": [
              "[merge f m1 m2] computes a map whose keys is a subset of keys of [m1]\n        and of [m2]. The presence of each such binding, and the corresponding\n        value, is determined with the function [f].\n        In terms of the [find_opt] operation, we have\n        [find_opt x (merge f m1 m2) = f (find_opt x m1) (find_opt x m2)]\n        for any key [x], provided that [f None None = None].\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.union",
            "kind": "value",
            "name": "union",
            "signature": "let union: ((key, 'a, 'a) => option<'a>, t<'a>, t<'a>) => t<'a>",
            "docstrings": [
              "[union f m1 m2] computes a map whose keys is the union of keys\n        of [m1] and of [m2].  When the same binding is defined in both\n        arguments, the function [f] is used to combine them.\n        This is a special case of [merge]: [union f m1 m2] is equivalent\n        to [merge f' m1 m2], where\n        - [f' None None = None]\n        - [f' (Some v) None = Some v]\n        - [f' None (Some v) = Some v]\n        - [f' (Some v1) (Some v2) = f v1 v2]\n\n        @since 4.03.0"
            ]
          },
          {
            "id": "Map.Make.compare",
            "kind": "value",
            "name": "compare",
            "signature": "let compare: (('a, 'a) => int, t<'a>, t<'a>) => int",
            "docstrings": [
              "Total ordering between maps.  The first argument is a total ordering\n        used to compare data associated with equal keys in the two maps."
            ]
          },
          {
            "id": "Map.Make.equal",
            "kind": "value",
            "name": "equal",
            "signature": "let equal: (('a, 'a) => bool, t<'a>, t<'a>) => bool",
            "docstrings": [
              "[equal cmp m1 m2] tests whether the maps [m1] and [m2] are\n       equal, that is, contain equal keys and associate them with\n       equal data.  [cmp] is the equality predicate used to compare\n       the data associated with the keys."
            ]
          },
          {
            "id": "Map.Make.iter",
            "kind": "value",
            "name": "iter",
            "signature": "let iter: ((key, 'a) => unit, t<'a>) => unit",
            "docstrings": [
              "[iter f m] applies [f] to all bindings in map [m].\n       [f] receives the key as first argument, and the associated value\n       as second argument.  The bindings are passed to [f] in increasing\n       order with respect to the ordering over the type of the keys."
            ]
          },
          {
            "id": "Map.Make.fold",
            "kind": "value",
            "name": "fold",
            "signature": "let fold: ((key, 'a, 'b) => 'b, t<'a>, 'b) => 'b",
            "docstrings": [
              "[fold f m a] computes [(f kN dN ... (f k1 d1 a)...)],\n       where [k1 ... kN] are the keys of all bindings in [m]\n       (in increasing order), and [d1 ... dN] are the associated data."
            ]
          },
          {
            "id": "Map.Make.for_all",
            "kind": "value",
            "name": "for_all",
            "signature": "let for_all: ((key, 'a) => bool, t<'a>) => bool",
            "docstrings": [
              "[for_all p m] checks if all the bindings of the map\n        satisfy the predicate [p].\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.exists",
            "kind": "value",
            "name": "exists",
            "signature": "let exists: ((key, 'a) => bool, t<'a>) => bool",
            "docstrings": [
              "[exists p m] checks if at least one binding of the map\n        satisfies the predicate [p].\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.filter",
            "kind": "value",
            "name": "filter",
            "signature": "let filter: ((key, 'a) => bool, t<'a>) => t<'a>",
            "docstrings": [
              "[filter p m] returns the map with all the bindings in [m]\n        that satisfy predicate [p]. If [p] satisfies every binding in [m],\n        [m] is returned unchanged (the result of the function is then\n        physically equal to [m])\n        @since 3.12.0\n       @before 4.03 Physical equality was not ensured."
            ]
          },
          {
            "id": "Map.Make.partition",
            "kind": "value",
            "name": "partition",
            "signature": "let partition: ((key, 'a) => bool, t<'a>) => (t<'a>, t<'a>)",
            "docstrings": [
              "[partition p m] returns a pair of maps [(m1, m2)], where\n        [m1] contains all the bindings of [s] that satisfy the\n        predicate [p], and [m2] is the map with all the bindings of\n        [s] that do not satisfy [p].\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.cardinal",
            "kind": "value",
            "name": "cardinal",
            "signature": "let cardinal: t<'a> => int",
            "docstrings": [
              "Return the number of bindings of a map.\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.bindings",
            "kind": "value",
            "name": "bindings",
            "signature": "let bindings: t<'a> => list<(key, 'a)>",
            "docstrings": [
              "Return the list of all bindings of the given map.\n       The returned list is sorted in increasing order with respect\n       to the ordering [Ord.compare], where [Ord] is the argument\n       given to {!Map.Make}.\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.min_binding",
            "kind": "value",
            "name": "min_binding",
            "signature": "let min_binding: t<'a> => (key, 'a)",
            "docstrings": [
              "Return the smallest binding of the given map\n       (with respect to the [Ord.compare] ordering), or raise\n       [Not_found] if the map is empty.\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.min_binding_opt",
            "kind": "value",
            "name": "min_binding_opt",
            "signature": "let min_binding_opt: t<'a> => option<(key, 'a)>",
            "docstrings": [
              "Return the smallest binding of the given map\n       (with respect to the [Ord.compare] ordering), or [None]\n       if the map is empty.\n        @since 4.05"
            ]
          },
          {
            "id": "Map.Make.max_binding",
            "kind": "value",
            "name": "max_binding",
            "signature": "let max_binding: t<'a> => (key, 'a)",
            "docstrings": [
              "Same as {!Map.S.min_binding}, but returns the largest binding\n        of the given map.\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.max_binding_opt",
            "kind": "value",
            "name": "max_binding_opt",
            "signature": "let max_binding_opt: t<'a> => option<(key, 'a)>",
            "docstrings": [
              "Same as {!Map.S.min_binding_opt}, but returns the largest binding\n        of the given map.\n        @since 4.05"
            ]
          },
          {
            "id": "Map.Make.choose",
            "kind": "value",
            "name": "choose",
            "signature": "let choose: t<'a> => (key, 'a)",
            "docstrings": [
              "Return one binding of the given map, or raise [Not_found] if\n       the map is empty. Which binding is chosen is unspecified,\n       but equal bindings will be chosen for equal maps.\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.choose_opt",
            "kind": "value",
            "name": "choose_opt",
            "signature": "let choose_opt: t<'a> => option<(key, 'a)>",
            "docstrings": [
              "Return one binding of the given map, or [None] if\n       the map is empty. Which binding is chosen is unspecified,\n       but equal bindings will be chosen for equal maps.\n        @since 4.05"
            ]
          },
          {
            "id": "Map.Make.split",
            "kind": "value",
            "name": "split",
            "signature": "let split: (key, t<'a>) => (t<'a>, option<'a>, t<'a>)",
            "docstrings": [
              "[split x m] returns a triple [(l, data, r)], where\n          [l] is the map with all the bindings of [m] whose key\n        is strictly less than [x];\n          [r] is the map with all the bindings of [m] whose key\n        is strictly greater than [x];\n          [data] is [None] if [m] contains no binding for [x],\n          or [Some v] if [m] binds [v] to [x].\n        @since 3.12.0"
            ]
          },
          {
            "id": "Map.Make.find",
            "kind": "value",
            "name": "find",
            "signature": "let find: (key, t<'a>) => 'a",
            "docstrings": [
              "[find x m] returns the current binding of [x] in [m],\n       or raises [Not_found] if no such binding exists."
            ]
          },
          {
            "id": "Map.Make.find_opt",
            "kind": "value",
            "name": "find_opt",
            "signature": "let find_opt: (key, t<'a>) => option<'a>",
            "docstrings": [
              "[find_opt x m] returns [Some v] if the current binding of [x]\n        in [m] is [v], or [None] if no such binding exists.\n        @since 4.05"
            ]
          },
          {
            "id": "Map.Make.find_first",
            "kind": "value",
            "name": "find_first",
            "signature": "let find_first: (key => bool, t<'a>) => (key, 'a)",
            "docstrings": [
              "[find_first f m], where [f] is a monotonically increasing function,\n       returns the binding of [m] with the lowest key [k] such that [f k],\n       or raises [Not_found] if no such key exists.\n\n       For example, [find_first (fun k -> Ord.compare k x >= 0) m] will return\n       the first binding [k, v] of [m] where [Ord.compare k x >= 0]\n       (intuitively: [k >= x]), or raise [Not_found] if [x] is greater than any\n       element of [m].\n\n        @since 4.05"
            ]
          },
          {
            "id": "Map.Make.find_first_opt",
            "kind": "value",
            "name": "find_first_opt",
            "signature": "let find_first_opt: (key => bool, t<'a>) => option<(key, 'a)>",
            "docstrings": [
              "[find_first_opt f m], where [f] is a monotonically increasing function,\n       returns an option containing the binding of [m] with the lowest key [k]\n       such that [f k], or [None] if no such key exists.\n        @since 4.05"
            ]
          },
          {
            "id": "Map.Make.find_last",
            "kind": "value",
            "name": "find_last",
            "signature": "let find_last: (key => bool, t<'a>) => (key, 'a)",
            "docstrings": [
              "[find_last f m], where [f] is a monotonically decreasing function,\n       returns the binding of [m] with the highest key [k] such that [f k],\n       or raises [Not_found] if no such key exists.\n        @since 4.05"
            ]
          },
          {
            "id": "Map.Make.find_last_opt",
            "kind": "value",
            "name": "find_last_opt",
            "signature": "let find_last_opt: (key => bool, t<'a>) => option<(key, 'a)>",
            "docstrings": [
              "[find_last_opt f m], where [f] is a monotonically decreasing function,\n       returns an option containing the binding of [m] with the highest key [k]\n       such that [f k], or [None] if no such key exists.\n        @since 4.05"
            ]
          },
          {
            "id": "Map.Make.map",
            "kind": "value",
            "name": "map",
            "signature": "let map: ('a => 'b, t<'a>) => t<'b>",
            "docstrings": [
              "[map f m] returns a map with same domain as [m], where the\n       associated value [a] of all bindings of [m] has been\n       replaced by the result of the application of [f] to [a].\n       The bindings are passed to [f] in increasing order\n       with respect to the ordering over the type of the keys."
            ]
          },
          {
            "id": "Map.Make.mapi",
            "kind": "value",
            "name": "mapi",
            "signature": "let mapi: ((key, 'a) => 'b, t<'a>) => t<'b>",
            "docstrings": [
              "Same as {!Map.S.map}, but the function receives as arguments both the\n       key and the associated value for each binding of the map."
            ]
          }
        ]
      }
    }
  ]
}