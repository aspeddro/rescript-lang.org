{
  "name": "Hashtbl",
  "docstrings": [],
  "items": [
    {
      "id": "Hashtbl.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a, 'b>",
      "docstrings": [
        "The type of hash tables from type ['a] to type ['b]."
      ]
    },
    {
      "id": "Hashtbl.create",
      "kind": "value",
      "name": "create",
      "signature": "let create: (~random: bool=?, int) => t<'a, 'b>",
      "docstrings": [
        "[Hashtbl.create n] creates a new, empty hash table, with\n   initial size [n].  For best results, [n] should be on the\n   order of the expected number of elements that will be in\n   the table.  The table grows as needed, so [n] is just an\n   initial guess.\n\n   The optional [random] parameter (a boolean) controls whether\n   the internal organization of the hash table is randomized at each\n   execution of [Hashtbl.create] or deterministic over all executions.\n\n   A hash table that is created with [~random:false] uses a\n   fixed hash function ({!Hashtbl.hash}) to distribute keys among\n   buckets.  As a consequence, collisions between keys happen\n   deterministically.  In Web-facing applications or other\n   security-sensitive applications, the deterministic collision\n   patterns can be exploited by a malicious user to create a\n   denial-of-service attack: the attacker sends input crafted to\n   create many collisions in the table, slowing the application down.\n\n   A hash table that is created with [~random:true] uses the seeded\n   hash function {!Hashtbl.seeded_hash} with a seed that is randomly\n   chosen at hash table creation time.  In effect, the hash function\n   used is randomly selected among [2^{30}] different hash functions.\n   All these hash functions have different collision patterns,\n   rendering ineffective the denial-of-service attack described above.\n   However, because of randomization, enumerating all elements of the\n   hash table using {!Hashtbl.fold} or {!Hashtbl.iter} is no longer\n   deterministic: elements are enumerated in different orders at\n   different runs of the program.\n\n   If no [~random] parameter is given, hash tables are created\n   in non-random mode by default.  This default can be changed\n   either programmatically by calling {!Hashtbl.randomize} or by\n   setting the [R] flag in the [OCAMLRUNPARAM] environment variable.\n\n   @before 4.00.0 the [random] parameter was not present and all\n   hash tables were created in non-randomized mode."
      ]
    },
    {
      "id": "Hashtbl.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'a, 'b> => unit",
      "docstrings": [
        "Empty a hash table. Use [reset] instead of [clear] to shrink the\n    size of the bucket table to its initial size."
      ]
    },
    {
      "id": "Hashtbl.reset",
      "kind": "value",
      "name": "reset",
      "signature": "let reset: t<'a, 'b> => unit",
      "docstrings": [
        "Empty a hash table and shrink the size of the bucket table\n    to its initial size.\n    @since 4.00.0"
      ]
    },
    {
      "id": "Hashtbl.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'a, 'b> => t<'a, 'b>",
      "docstrings": [
        "Return a copy of the given hashtable."
      ]
    },
    {
      "id": "Hashtbl.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'a, 'b>, 'a, 'b) => unit",
      "docstrings": [
        "[Hashtbl.add tbl x y] adds a binding of [x] to [y] in table [tbl].\n   Previous bindings for [x] are not removed, but simply\n   hidden. That is, after performing {!Hashtbl.remove}[ tbl x],\n   the previous binding for [x], if any, is restored.\n   (Same behavior as with association lists.)"
      ]
    },
    {
      "id": "Hashtbl.find",
      "kind": "value",
      "name": "find",
      "signature": "let find: (t<'a, 'b>, 'a) => 'b",
      "docstrings": [
        "[Hashtbl.find tbl x] returns the current binding of [x] in [tbl],\n   or raises [Not_found] if no such binding exists."
      ]
    },
    {
      "id": "Hashtbl.find_opt",
      "kind": "value",
      "name": "find_opt",
      "signature": "let find_opt: (t<'a, 'b>, 'a) => option<'b>",
      "docstrings": [
        "[Hashtbl.find_opt tbl x] returns the current binding of [x] in [tbl],\n    or [None] if no such binding exists.\n    @since 4.05"
      ]
    },
    {
      "id": "Hashtbl.find_all",
      "kind": "value",
      "name": "find_all",
      "signature": "let find_all: (t<'a, 'b>, 'a) => list<'b>",
      "docstrings": [
        "[Hashtbl.find_all tbl x] returns the list of all data\n   associated with [x] in [tbl].\n   The current binding is returned first, then the previous\n   bindings, in reverse order of introduction in the table."
      ]
    },
    {
      "id": "Hashtbl.mem",
      "kind": "value",
      "name": "mem",
      "signature": "let mem: (t<'a, 'b>, 'a) => bool",
      "docstrings": [
        "[Hashtbl.mem tbl x] checks if [x] is bound in [tbl]."
      ]
    },
    {
      "id": "Hashtbl.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'a, 'b>, 'a) => unit",
      "docstrings": [
        "[Hashtbl.remove tbl x] removes the current binding of [x] in [tbl],\n   restoring the previous binding if it exists.\n   It does nothing if [x] is not bound in [tbl]."
      ]
    },
    {
      "id": "Hashtbl.replace",
      "kind": "value",
      "name": "replace",
      "signature": "let replace: (t<'a, 'b>, 'a, 'b) => unit",
      "docstrings": [
        "[Hashtbl.replace tbl x y] replaces the current binding of [x]\n   in [tbl] by a binding of [x] to [y].  If [x] is unbound in [tbl],\n   a binding of [x] to [y] is added to [tbl].\n   This is functionally equivalent to {!Hashtbl.remove}[ tbl x]\n   followed by {!Hashtbl.add}[ tbl x y]."
      ]
    },
    {
      "id": "Hashtbl.iter",
      "kind": "value",
      "name": "iter",
      "signature": "let iter: (('a, 'b) => unit, t<'a, 'b>) => unit",
      "docstrings": [
        "[Hashtbl.iter f tbl] applies [f] to all bindings in table [tbl].\n   [f] receives the key as first argument, and the associated value\n   as second argument. Each binding is presented exactly once to [f].\n\n   The order in which the bindings are passed to [f] is unspecified.\n   However, if the table contains several bindings for the same key,\n   they are passed to [f] in reverse order of introduction, that is,\n   the most recent binding is passed first.\n\n   If the hash table was created in non-randomized mode, the order\n   in which the bindings are enumerated is reproducible between\n   successive runs of the program, and even between minor versions\n   of OCaml.  For randomized hash tables, the order of enumeration\n   is entirely random.\n\n   The behavior is not defined if the hash table is modified\n   by [f] during the iteration."
      ]
    },
    {
      "id": "Hashtbl.filter_map_inplace",
      "kind": "value",
      "name": "filter_map_inplace",
      "signature": "let filter_map_inplace: (('a, 'b) => option<'b>, t<'a, 'b>) => unit",
      "docstrings": [
        "[Hashtbl.filter_map_inplace f tbl] applies [f] to all bindings in\n    table [tbl] and update each binding depending on the result of\n    [f].  If [f] returns [None], the binding is discarded.  If it\n    returns [Some new_val], the binding is update to associate the key\n    to [new_val].\n\n    Other comments for {!Hashtbl.iter} apply as well.\n    @since 4.03.0"
      ]
    },
    {
      "id": "Hashtbl.fold",
      "kind": "value",
      "name": "fold",
      "signature": "let fold: (('a, 'b, 'c) => 'c, t<'a, 'b>, 'c) => 'c",
      "docstrings": [
        "[Hashtbl.fold f tbl init] computes\n   [(f kN dN ... (f k1 d1 init)...)],\n   where [k1 ... kN] are the keys of all bindings in [tbl],\n   and [d1 ... dN] are the associated values.\n   Each binding is presented exactly once to [f].\n\n   The order in which the bindings are passed to [f] is unspecified.\n   However, if the table contains several bindings for the same key,\n   they are passed to [f] in reverse order of introduction, that is,\n   the most recent binding is passed first.\n\n   If the hash table was created in non-randomized mode, the order\n   in which the bindings are enumerated is reproducible between\n   successive runs of the program, and even between minor versions\n   of OCaml.  For randomized hash tables, the order of enumeration\n   is entirely random.\n\n   The behavior is not defined if the hash table is modified\n   by [f] during the iteration."
      ]
    },
    {
      "id": "Hashtbl.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: t<'a, 'b> => int",
      "docstrings": [
        "[Hashtbl.length tbl] returns the number of bindings in [tbl].\n   It takes constant time.  Multiple bindings are counted once each, so\n   [Hashtbl.length] gives the number of times [Hashtbl.iter] calls its\n   first argument."
      ]
    },
    {
      "id": "Hashtbl.randomize",
      "kind": "value",
      "name": "randomize",
      "signature": "let randomize: unit => unit",
      "docstrings": [
        "After a call to [Hashtbl.randomize()], hash tables are created in\n    randomized mode by default: {!Hashtbl.create} returns randomized\n    hash tables, unless the [~random:false] optional parameter is given.\n    The same effect can be achieved by setting the [R] parameter in\n    the [OCAMLRUNPARAM] environment variable.\n\n    It is recommended that applications or Web frameworks that need to\n    protect themselves against the denial-of-service attack described\n    in {!Hashtbl.create} call [Hashtbl.randomize()] at initialization\n    time.\n\n    Note that once [Hashtbl.randomize()] was called, there is no way\n    to revert to the non-randomized default behavior of {!Hashtbl.create}.\n    This is intentional.  Non-randomized hash tables can still be\n    created using [Hashtbl.create ~random:false].\n\n    @since 4.00.0"
      ]
    },
    {
      "id": "Hashtbl.is_randomized",
      "kind": "value",
      "name": "is_randomized",
      "signature": "let is_randomized: unit => bool",
      "docstrings": [
        "return if the tables are currently created in randomized mode by default\n\n    @since 4.03.0"
      ]
    },
    {
      "id": "Hashtbl.statistics",
      "kind": "type",
      "name": "statistics",
      "signature": "type statistics = {\\n  num_bindings: int,\\n  num_buckets: int,\\n  max_bucket_length: int,\\n  bucket_histogram: array<int>,\\n}",
      "docstrings": [
        "@since 4.00.0"
      ],
      "detail": {
        "kind": "record",
        "fieldDocs": [
          {
            "fieldName": "num_bindings",
            "docstrings": [
              "Number of bindings present in the table.\n        Same value as returned by {!Hashtbl.length}."
            ],
            "signature": "int"
          },
          {
            "fieldName": "num_buckets",
            "docstrings": [
              "Number of buckets in the table."
            ],
            "signature": "int"
          },
          {
            "fieldName": "max_bucket_length",
            "docstrings": [
              "Maximal number of bindings per bucket."
            ],
            "signature": "int"
          },
          {
            "fieldName": "bucket_histogram",
            "docstrings": [
              "Histogram of bucket sizes.  This array [histo] has\n        length [max_bucket_length + 1].  The value of\n        [histo.(i)] is the number of buckets whose size is [i]."
            ],
            "signature": "array<int>"
          }
        ]
      }
    },
    {
      "id": "Hashtbl.stats",
      "kind": "value",
      "name": "stats",
      "signature": "let stats: t<'a, 'b> => statistics",
      "docstrings": [
        "[Hashtbl.stats tbl] returns statistics about the table [tbl]:\n   number of buckets, size of the biggest bucket, distribution of\n   buckets by size.\n   @since 4.00.0"
      ]
    },
    {
      "id": "Make.Hashtbl",
      "kind": "module",
      "item": {
        "name": "Make",
        "docstrings": [],
        "items": [
          {
            "id": "Hashtbl.Make.key",
            "kind": "type",
            "name": "key",
            "signature": "type key = H.t",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.t",
            "kind": "type",
            "name": "t",
            "signature": "type t<'a>",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.create",
            "kind": "value",
            "name": "create",
            "signature": "let create: int => t<'a>",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.clear",
            "kind": "value",
            "name": "clear",
            "signature": "let clear: t<'a> => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.reset",
            "kind": "value",
            "name": "reset",
            "signature": "let reset: t<'a> => unit",
            "docstrings": [
              "@since 4.00.0"
            ]
          },
          {
            "id": "Hashtbl.Make.copy",
            "kind": "value",
            "name": "copy",
            "signature": "let copy: t<'a> => t<'a>",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.add",
            "kind": "value",
            "name": "add",
            "signature": "let add: (t<'a>, key, 'a) => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.remove",
            "kind": "value",
            "name": "remove",
            "signature": "let remove: (t<'a>, key) => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.find",
            "kind": "value",
            "name": "find",
            "signature": "let find: (t<'a>, key) => 'a",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.find_opt",
            "kind": "value",
            "name": "find_opt",
            "signature": "let find_opt: (t<'a>, key) => option<'a>",
            "docstrings": [
              "@since 4.05.0"
            ]
          },
          {
            "id": "Hashtbl.Make.find_all",
            "kind": "value",
            "name": "find_all",
            "signature": "let find_all: (t<'a>, key) => list<'a>",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.replace",
            "kind": "value",
            "name": "replace",
            "signature": "let replace: (t<'a>, key, 'a) => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.mem",
            "kind": "value",
            "name": "mem",
            "signature": "let mem: (t<'a>, key) => bool",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.iter",
            "kind": "value",
            "name": "iter",
            "signature": "let iter: ((key, 'a) => unit, t<'a>) => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.filter_map_inplace",
            "kind": "value",
            "name": "filter_map_inplace",
            "signature": "let filter_map_inplace: ((key, 'a) => option<'a>, t<'a>) => unit",
            "docstrings": [
              "@since 4.03.0"
            ]
          },
          {
            "id": "Hashtbl.Make.fold",
            "kind": "value",
            "name": "fold",
            "signature": "let fold: ((key, 'a, 'b) => 'b, t<'a>, 'b) => 'b",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.length",
            "kind": "value",
            "name": "length",
            "signature": "let length: t<'a> => int",
            "docstrings": []
          },
          {
            "id": "Hashtbl.Make.stats",
            "kind": "value",
            "name": "stats",
            "signature": "let stats: t<'a> => statistics",
            "docstrings": [
              "@since 4.00.0"
            ]
          }
        ]
      }
    },
    {
      "id": "MakeSeeded.Hashtbl",
      "kind": "module",
      "item": {
        "name": "MakeSeeded",
        "docstrings": [],
        "items": [
          {
            "id": "Hashtbl.MakeSeeded.key",
            "kind": "type",
            "name": "key",
            "signature": "type key = H.t",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.t",
            "kind": "type",
            "name": "t",
            "signature": "type t<'a>",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.create",
            "kind": "value",
            "name": "create",
            "signature": "let create: (~random: bool=?, int) => t<'a>",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.clear",
            "kind": "value",
            "name": "clear",
            "signature": "let clear: t<'a> => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.reset",
            "kind": "value",
            "name": "reset",
            "signature": "let reset: t<'a> => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.copy",
            "kind": "value",
            "name": "copy",
            "signature": "let copy: t<'a> => t<'a>",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.add",
            "kind": "value",
            "name": "add",
            "signature": "let add: (t<'a>, key, 'a) => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.remove",
            "kind": "value",
            "name": "remove",
            "signature": "let remove: (t<'a>, key) => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.find",
            "kind": "value",
            "name": "find",
            "signature": "let find: (t<'a>, key) => 'a",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.find_opt",
            "kind": "value",
            "name": "find_opt",
            "signature": "let find_opt: (t<'a>, key) => option<'a>",
            "docstrings": [
              "@since 4.05.0"
            ]
          },
          {
            "id": "Hashtbl.MakeSeeded.find_all",
            "kind": "value",
            "name": "find_all",
            "signature": "let find_all: (t<'a>, key) => list<'a>",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.replace",
            "kind": "value",
            "name": "replace",
            "signature": "let replace: (t<'a>, key, 'a) => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.mem",
            "kind": "value",
            "name": "mem",
            "signature": "let mem: (t<'a>, key) => bool",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.iter",
            "kind": "value",
            "name": "iter",
            "signature": "let iter: ((key, 'a) => unit, t<'a>) => unit",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.filter_map_inplace",
            "kind": "value",
            "name": "filter_map_inplace",
            "signature": "let filter_map_inplace: ((key, 'a) => option<'a>, t<'a>) => unit",
            "docstrings": [
              "@since 4.03.0"
            ]
          },
          {
            "id": "Hashtbl.MakeSeeded.fold",
            "kind": "value",
            "name": "fold",
            "signature": "let fold: ((key, 'a, 'b) => 'b, t<'a>, 'b) => 'b",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.length",
            "kind": "value",
            "name": "length",
            "signature": "let length: t<'a> => int",
            "docstrings": []
          },
          {
            "id": "Hashtbl.MakeSeeded.stats",
            "kind": "value",
            "name": "stats",
            "signature": "let stats: t<'a> => statistics",
            "docstrings": []
          }
        ]
      }
    },
    {
      "id": "Hashtbl.hash",
      "kind": "value",
      "name": "hash",
      "signature": "let hash: 'a => int",
      "docstrings": [
        "[Hashtbl.hash x] associates a nonnegative integer to any value of\n   any type. It is guaranteed that\n   if [x = y] or [Pervasives.compare x y = 0], then [hash x = hash y].\n   Moreover, [hash] always terminates, even on cyclic structures."
      ]
    },
    {
      "id": "Hashtbl.seeded_hash",
      "kind": "value",
      "name": "seeded_hash",
      "signature": "let seeded_hash: (int, 'a) => int",
      "docstrings": [
        "A variant of {!Hashtbl.hash} that is further parameterized by\n   an integer seed.\n   @since 4.00.0"
      ]
    },
    {
      "id": "Hashtbl.hash_param",
      "kind": "value",
      "name": "hash_param",
      "signature": "let hash_param: (int, int, 'a) => int",
      "docstrings": [
        "[Hashtbl.hash_param meaningful total x] computes a hash value for [x],\n   with the same properties as for [hash]. The two extra integer\n   parameters [meaningful] and [total] give more precise control over\n   hashing. Hashing performs a breadth-first, left-to-right traversal\n   of the structure [x], stopping after [meaningful] meaningful nodes\n   were encountered, or [total] nodes (meaningful or not) were\n   encountered.  If [total] as specified by the user exceeds a certain\n   value, currently 256, then it is capped to that value.\n   Meaningful nodes are: integers; floating-point\n   numbers; strings; characters; booleans; and constant\n   constructors. Larger values of [meaningful] and [total] means that\n   more nodes are taken into account to compute the final hash value,\n   and therefore collisions are less likely to happen.  However,\n   hashing takes longer. The parameters [meaningful] and [total]\n   govern the tradeoff between accuracy and speed.  As default\n   choices, {!Hashtbl.hash} and {!Hashtbl.seeded_hash} take\n   [meaningful = 10] and [total = 100]."
      ]
    },
    {
      "id": "Hashtbl.seeded_hash_param",
      "kind": "value",
      "name": "seeded_hash_param",
      "signature": "let seeded_hash_param: (int, int, int, 'a) => int",
      "docstrings": [
        "A variant of {!Hashtbl.hash_param} that is further parameterized by\n   an integer seed.  Usage:\n   [Hashtbl.seeded_hash_param meaningful total seed x].\n   @since 4.00.0"
      ]
    }
  ]
}