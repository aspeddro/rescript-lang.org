{
  "name": "Belt",
  "docstrings": [
    "The ReScript standard library.\n\nBelt is currently mostly covering collection types. It has no string or date functions yet, although Belt.String is in the works. In the meantime, use [Js.String](js/string) for string functions and [Js.Date](js/date) for date functions.\n\n## Motivation\n\nBelt provides:\n\n- The **highest quality** immutable data structures in JavaScript.\n- Safety by default: A Belt function will never throw exceptions, unless it is\n  indicated explicitly in the function name (suffix \"Exn\").\n- Better performance and smaller code size running on the JS platform.\n- Ready for [Tree Shaking](https://webpack.js.org/guides/tree-shaking/).\n\n## Usage\n\nTo use modules from Belt, either refer to them by their fully qualified name (`Belt.List`, `Belt.Array` etc.) or open the `Belt` module by putting\n\n```\nopen Belt\n```\n\nat the top of your source files. After opening Belt this way, `Array` will refer to `Belt.Array`, `List` will refer to `Belt.List` etc. in the subsequent code.\n\nIf you want to open Belt globally for all files in your project instead, you can put\n\n```json\n  \"bsc-flags\": [\"-open Belt\"],\n```\n\ninto your `bsconfig.json`.\n\n**Note**: this is the **only** `open` we encourage.\n\nExample usage:\n\n```\nlet someNumbers = [1, 1, 4, 2, 3, 6, 3, 4, 2]\n\nlet greaterThan2UniqueAndSorted =\n  someNumbers\n  ->Belt.Array.keep(x => x > 2)\n  // convert to and from set to make values unique\n  ->Belt.Set.Int.fromArray\n  ->Belt.Set.Int.toArray // output is already sorted\n\nJs.log2(\"result\", greaterThan2UniqueAndSorted)\n```\n\n## Curried vs. Uncurried Callbacks\n\nFor functions taking a callback parameter, there are usually two versions\navailable:\n\n- curried (no suffix)\n- uncurried (suffixed with `U`)\n\nE.g.:\n\n```\nlet forEach: (t<'a>, 'a => unit) => unit\n\nlet forEachU: (t<'a>, (. 'a) => unit) => unit\n```\n\nThe uncurried version will be faster in some cases, but for simplicity we recommend to stick with the curried version unless you need the extra performance.\n\nThe two versions can be invoked as follows:\n\n```\n[\"a\", \"b\", \"c\"]->Belt.Array.forEach(x => Js.log(x))\n\n[\"a\", \"b\", \"c\"]->Belt.Array.forEachU((. x) => Js.log(x))\n```\n\n## Specialized Collections\n\nFor collections types like set or map, Belt provides both a generic module as well as specialized, more efficient implementations for string and int keys.\n\nFor example, Belt has the following set modules:\n\n- [Belt.Set](belt/set)\n- [Belt.Set.Int](belt/set-int)\n- [Belt.Set.String](belt/set-string)\n\n## Implementation Details\n\n### Array access runtime safety\n\nOne common confusion comes from the way Belt handles array access. It differs from than the default standard library's.\n\n```\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0] // a == \"a\"\nlet capitalA = Js.String.toUpperCase(a)\nlet k = letters[10] // Raises an exception! The 10th index doesn't exist.\n```\n\nBecause Belt avoids exceptions and returns `options` instead, this code behaves differently:\n\n```\nopen Belt\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0] // a == Some(\"a\")\nlet captialA = Js.String.toUpperCase(a) // Type error! This code will not compile.\nlet k = letters[10] // k == None\n```\n\nAlthough we've fixed the problem where `k` raises an exception, we now have a type error when trying to capitalize `a`. There are a few things going on here:\n\n- Reason transforms array index access to the function `Array.get`. So `letters[0]` is the same as `Array.get(letters, 0)`.\n- The compiler uses whichever `Array` module is in scope. If you `open Belt`, then it uses `Belt.Array`.\n- `Belt.Array.get` returns values wrapped in options, so `letters[0] == Some(\"a\")`.\n\nFortunately, this is easy to fix:\n\n```res example\nopen Belt\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0]\n\n// Use a switch statement:\nlet capitalA =\n  switch a {\n  | Some(a) => Some(Js.String.toUpperCase(a))\n  | None => None\n  }\n\nlet k = letters[10] // k == None\n```\n\nWith that little bit of tweaking, our code now compiles successfully and is 100% free of runtime errors!\n\n### A Special Encoding for Collection Safety\n\nWhen we create a collection library for a custom data type we need a way to provide a comparator function. Take Set for example, suppose its element type is a pair of ints, it needs a custom compare function that takes two tuples and returns their order. The Set could not just be typed as Set.t (int \\* int) , its customized compare function needs to manifest itself in the signature, otherwise, if the user creates another customized compare function, the two collection could mix which would result in runtime error.\n\nWe use a phantom type to solve the problem:\n\n```\nmodule Comparable1 =\n  Belt.Id.MakeComparable(\n    {\n      type t = (int, int)\n      let cmp = ((a0, a1), (b0, b1)) =>\n        switch Pervasives.compare(a0, b0) {\n        | 0 => Pervasives.compare(a1, b1)\n        | c => c\n        }\n    }\n  )\n\nlet mySet1 = Belt.Set.make(~id=module(Comparable1))\n\nmodule Comparable2 =\n  Belt.Id.MakeComparable(\n    {\n      type t = (int, int)\n      let cmp = ((a0, a1), (b0, b1)) =>\n        switch Pervasives.compare(a0, b0) {\n        | 0 => Pervasives.compare(a1, b1)\n        | c => c\n        }\n    }\n  )\n\nlet mySet2 = Belt.Set.make(~id=module(Comparable2))\n```\n\nHere, the compiler would infer `mySet1` and `mySet2` having different type, so e.g. a `merge` operation that tries to merge these two sets will correctly fail.\n\n```\nlet mySet1: t<(int, int), Comparable1.identity>\nlet mySet2: t<(int, int), Comparable2.identity>\n```\n\n`Comparable1.identity` and `Comparable2.identity` are not the same using our encoding scheme."
  ],
  "items": [
    {
      "id": "Belt.Belt_Id",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Id`]()\n\n  Provide utilities to create identified comparators or hashes for\n  data structures used below.\n\n  It create a unique identifier per module of\n  functions so that different data structures with slightly different\n  comparison functions won't mix"
      ],
      "signature": "module Id = Belt_Id"
    },
    {
      "id": "Belt.Belt_Array",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Array`]()\n\n  **mutable array**: Utilities functions"
      ],
      "signature": "module Array = Belt_Array"
    },
    {
      "id": "Belt.Belt_SortArray",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.SortArray`]()\n\n  The top level provides some generic sort related utilities.\n\n  It also has two specialized inner modules\n  [`Belt.SortArray.Int`]() and [`Belt.SortArray.String`]()"
      ],
      "signature": "module SortArray = Belt_SortArray"
    },
    {
      "id": "Belt.Belt_MutableQueue",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.MutableQueue`]()\n\n  An FIFO(first in first out) queue data structure"
      ],
      "signature": "module MutableQueue = Belt_MutableQueue"
    },
    {
      "id": "Belt.Belt_MutableStack",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.MutableStack`]()\n\n  An FILO(first in last out) stack data structure"
      ],
      "signature": "module MutableStack = Belt_MutableStack"
    },
    {
      "id": "Belt.Belt_List",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.List`]()\n\n  Utilities for List data type"
      ],
      "signature": "module List = Belt_List"
    },
    {
      "id": "Belt.Belt_Range",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Range`]()\n\n  Utilities for a closed range `(from, start)`"
      ],
      "signature": "module Range = Belt_Range"
    },
    {
      "id": "Belt.Belt_Set",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Set`]()\n\n  The top level provides generic **immutable** set operations.\n\n  It also has three specialized inner modules\n  [`Belt.Set.Int`](), [`Belt.Set.String`]() and\n\n  [`Belt.Set.Dict`](): This module separates data from function\n  which is more verbose but slightly more efficient"
      ],
      "signature": "module Set = Belt_Set"
    },
    {
      "id": "Belt.Belt_Map",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Map`](),\n\n  The top level provides generic **immutable** map operations.\n\n  It also has three specialized inner modules\n  [`Belt.Map.Int`](), [`Belt.Map.String`]() and\n\n  [`Belt.Map.Dict`](): This module separates data from function\n  which  is more verbose but slightly more efficient"
      ],
      "signature": "module Map = Belt_Map"
    },
    {
      "id": "Belt.Belt_MutableSet",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.MutableSet`]()\n\n  The top level provides generic **mutable** set operations.\n\n  It also has two specialized inner modules\n  [`Belt.MutableSet.Int`]() and [`Belt.MutableSet.String`]()"
      ],
      "signature": "module MutableSet = Belt_MutableSet"
    },
    {
      "id": "Belt.Belt_MutableMap",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.MutableMap`]()\n\n  The top level provides generic **mutable** map operations.\n\n  It also has two specialized inner modules\n  [`Belt.MutableMap.Int`]() and [`Belt.MutableMap.String`]()"
      ],
      "signature": "module MutableMap = Belt_MutableMap"
    },
    {
      "id": "Belt.Belt_HashSet",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.HashSet`]()\n\n  The top level provides generic **mutable** hash set operations.\n\n  It also has two specialized inner modules\n  [`Belt.HashSet.Int`]() and [`Belt.HashSet.String`]()"
      ],
      "signature": "module HashSet = Belt_HashSet"
    },
    {
      "id": "Belt.Belt_HashMap",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.HashMap`]()\n\n  The top level provides generic **mutable** hash map operations.\n\n  It also has two specialized inner modules\n  [`Belt.HashMap.Int`]() and [`Belt.HashMap.String`]()"
      ],
      "signature": "module HashMap = Belt_HashMap"
    },
    {
      "id": "Belt.Belt_Option",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Option`]()\n\n  Utilities for option data type."
      ],
      "signature": "module Option = Belt_Option"
    },
    {
      "id": "Belt.Belt_Result",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Result`]()\n\n  Utilities for result data type."
      ],
      "signature": "module Result = Belt_Result"
    },
    {
      "id": "Belt.Belt_Int",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Int`]()\n\n  Utilities for Int."
      ],
      "signature": "module Int = Belt_Int"
    },
    {
      "id": "Belt.Belt_Float",
      "kind": "moduleAlias",
      "docstrings": [
        "[`Belt.Float`]()\n\n  Utilities for Float."
      ],
      "signature": "module Float = Belt_Float"
    }
  ]
}