{
  "name": "Stream",
  "docstrings": [],
  "items": [
    {
      "id": "Stream.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a>",
      "docstrings": [
        "The type of streams holding values of type ['a]."
      ]
    },
    {
      "id": "Stream.from",
      "kind": "value",
      "name": "from",
      "signature": "let from: (int => option<'a>) => t<'a>",
      "docstrings": [
        "[Stream.from f] returns a stream built from the function [f].\n   To create a new stream element, the function [f] is called with\n   the current stream count. The user function [f] must return either\n   [Some <value>] for a value or [None] to specify the end of the\n   stream.\n\n   Do note that the indices passed to [f] may not start at [0] in the\n   general case. For example, [[< '0; '1; Stream.from f >]] would call\n   [f] the first time with count [2]."
      ]
    },
    {
      "id": "Stream.of_list",
      "kind": "value",
      "name": "of_list",
      "signature": "let of_list: list<'a> => t<'a>",
      "docstrings": [
        "Return the stream holding the elements of the list in the same\n   order."
      ]
    },
    {
      "id": "Stream.of_string",
      "kind": "value",
      "name": "of_string",
      "signature": "let of_string: string => t<char>",
      "docstrings": [
        "Return the stream of the characters of the string parameter."
      ]
    },
    {
      "id": "Stream.of_bytes",
      "kind": "value",
      "name": "of_bytes",
      "signature": "let of_bytes: bytes => t<char>",
      "docstrings": [
        "Return the stream of the characters of the bytes parameter.\n    @since 4.02.0"
      ]
    },
    {
      "id": "Stream.iter",
      "kind": "value",
      "name": "iter",
      "signature": "let iter: ('a => unit, t<'a>) => unit",
      "docstrings": [
        "[Stream.iter f s] scans the whole stream s, applying function [f]\n   in turn to each stream element encountered."
      ]
    },
    {
      "id": "Stream.next",
      "kind": "value",
      "name": "next",
      "signature": "let next: t<'a> => 'a",
      "docstrings": [
        "Return the first element of the stream and remove it from the\n   stream. Raise {!Stream.Failure} if the stream is empty."
      ]
    },
    {
      "id": "Stream.empty",
      "kind": "value",
      "name": "empty",
      "signature": "let empty: t<'a> => unit",
      "docstrings": [
        "Return [()] if the stream is empty, else raise {!Stream.Failure}."
      ]
    },
    {
      "id": "Stream.peek",
      "kind": "value",
      "name": "peek",
      "signature": "let peek: t<'a> => option<'a>",
      "docstrings": [
        "Return [Some] of \"the first element\" of the stream, or [None] if\n   the stream is empty."
      ]
    },
    {
      "id": "Stream.junk",
      "kind": "value",
      "name": "junk",
      "signature": "let junk: t<'a> => unit",
      "docstrings": [
        "Remove the first element of the stream, possibly unfreezing\n   it before."
      ]
    },
    {
      "id": "Stream.count",
      "kind": "value",
      "name": "count",
      "signature": "let count: t<'a> => int",
      "docstrings": [
        "Return the current count of the stream elements, i.e. the number\n   of the stream elements discarded."
      ]
    },
    {
      "id": "Stream.npeek",
      "kind": "value",
      "name": "npeek",
      "signature": "let npeek: (int, t<'a>) => list<'a>",
      "docstrings": [
        "[npeek n] returns the list of the [n] first elements of\n   the stream, or all its remaining elements if less than [n]\n   elements are available."
      ]
    },
    {
      "id": "Stream.iapp",
      "kind": "value",
      "name": "iapp",
      "signature": "let iapp: (t<'a>, t<'a>) => t<'a>",
      "docstrings": []
    },
    {
      "id": "Stream.icons",
      "kind": "value",
      "name": "icons",
      "signature": "let icons: ('a, t<'a>) => t<'a>",
      "docstrings": []
    },
    {
      "id": "Stream.ising",
      "kind": "value",
      "name": "ising",
      "signature": "let ising: 'a => t<'a>",
      "docstrings": []
    },
    {
      "id": "Stream.lapp",
      "kind": "value",
      "name": "lapp",
      "signature": "let lapp: (unit => t<'a>, t<'a>) => t<'a>",
      "docstrings": []
    },
    {
      "id": "Stream.lcons",
      "kind": "value",
      "name": "lcons",
      "signature": "let lcons: (unit => 'a, t<'a>) => t<'a>",
      "docstrings": []
    },
    {
      "id": "Stream.lsing",
      "kind": "value",
      "name": "lsing",
      "signature": "let lsing: (unit => 'a) => t<'a>",
      "docstrings": []
    },
    {
      "id": "Stream.sempty",
      "kind": "value",
      "name": "sempty",
      "signature": "let sempty: t<'a>",
      "docstrings": []
    },
    {
      "id": "Stream.slazy",
      "kind": "value",
      "name": "slazy",
      "signature": "let slazy: (unit => t<'a>) => t<'a>",
      "docstrings": []
    },
    {
      "id": "Stream.dump",
      "kind": "value",
      "name": "dump",
      "signature": "let dump: ('a => unit, t<'a>) => unit",
      "docstrings": []
    }
  ]
}