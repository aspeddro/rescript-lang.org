{
  "name": "Belt_MapString",
  "docstrings": [],
  "items": [
    {
      "id": "Belt_MapString.key",
      "kind": "type",
      "name": "key",
      "signature": "type key = string",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'value>",
      "docstrings": [
        "The type of maps from type `key` to type `'value`."
      ]
    },
    {
      "id": "Belt_MapString.empty",
      "kind": "value",
      "name": "empty",
      "signature": "let empty: t<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'v> => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'v>, key) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.cmpU",
      "kind": "value",
      "name": "cmpU",
      "signature": "let cmpU: (t<'v>, t<'v>, (. 'v, 'v) => int) => int",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'v>, t<'v>, ('v, 'v) => int) => int",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.eqU",
      "kind": "value",
      "name": "eqU",
      "signature": "let eqU: (t<'v>, t<'v>, (. 'v, 'v) => bool) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'v>, t<'v>, ('v, 'v) => bool) => bool",
      "docstrings": [
        "`eq m1 m2` tests whether the maps `m1` and `m2` are\n  equal, that is, contain equal keys and associate them with\n  equal data."
      ]
    },
    {
      "id": "Belt_MapString.findFirstByU",
      "kind": "value",
      "name": "findFirstByU",
      "signature": "let findFirstByU: (t<'v>, (. key, 'v) => bool) => option<(key, 'v)>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.findFirstBy",
      "kind": "value",
      "name": "findFirstBy",
      "signature": "let findFirstBy: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>",
      "docstrings": [
        "`findFirstBy m p` uses funcion `f` to find the first key value pair\n  to match predicate `p`.\n\n  ```\n  let s0 = fromArray ~id:(module IntCmp) [|4,\"4\";1,\"1\";2,\"2,\"3\"\"|];;\n  findFirstBy s0 (fun k v -> k = 4 ) = option (4, \"4\");;\n  ```"
      ]
    },
    {
      "id": "Belt_MapString.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'v>, (. key, 'v) => unit) => unit",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'v>, (key, 'v) => unit) => unit",
      "docstrings": [
        "`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument. The bindings are passed to `f` in increasing\n  order with respect to the ordering over the type of the keys."
      ]
    },
    {
      "id": "Belt_MapString.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'v>, 'v2, (. 'v2, key, 'v) => 'v2) => 'v2",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2",
      "docstrings": [
        "`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."
      ]
    },
    {
      "id": "Belt_MapString.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t<'v>, (. key, 'v) => bool) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'v>, (key, 'v) => bool) => bool",
      "docstrings": [
        "`every m p` checks if all the bindings of the map\n    satisfy the predicate `p`. Order unspecified"
      ]
    },
    {
      "id": "Belt_MapString.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t<'v>, (. key, 'v) => bool) => bool",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'v>, (key, 'v) => bool) => bool",
      "docstrings": [
        "`some m p` checks if at least one binding of the map\n    satisfy the predicate `p`. Order unspecified"
      ]
    },
    {
      "id": "Belt_MapString.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'v> => int",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.toList",
      "kind": "value",
      "name": "toList",
      "signature": "let toList: t<'v> => list<(key, 'v)>",
      "docstrings": [
        "In increasing order."
      ]
    },
    {
      "id": "Belt_MapString.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'v> => array<(key, 'v)>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<(key, 'v)> => t<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.keysToArray",
      "kind": "value",
      "name": "keysToArray",
      "signature": "let keysToArray: t<'v> => array<key>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.valuesToArray",
      "kind": "value",
      "name": "valuesToArray",
      "signature": "let valuesToArray: t<'v> => array<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.minKey",
      "kind": "value",
      "name": "minKey",
      "signature": "let minKey: t<'a> => option<key>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.minKeyUndefined",
      "kind": "value",
      "name": "minKeyUndefined",
      "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.maxKey",
      "kind": "value",
      "name": "maxKey",
      "signature": "let maxKey: t<'a> => option<key>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.maxKeyUndefined",
      "kind": "value",
      "name": "maxKeyUndefined",
      "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.minimum",
      "kind": "value",
      "name": "minimum",
      "signature": "let minimum: t<'v> => option<(key, 'v)>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.minUndefined",
      "kind": "value",
      "name": "minUndefined",
      "signature": "let minUndefined: t<'v> => Js.undefined<(key, 'v)>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.maximum",
      "kind": "value",
      "name": "maximum",
      "signature": "let maximum: t<'v> => option<(key, 'v)>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.maxUndefined",
      "kind": "value",
      "name": "maxUndefined",
      "signature": "let maxUndefined: t<'v> => Js.undefined<(key, 'v)>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'v>, key) => option<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.getUndefined",
      "kind": "value",
      "name": "getUndefined",
      "signature": "let getUndefined: (t<'v>, key) => Js.undefined<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "signature": "let getWithDefault: (t<'v>, key, 'v) => 'v",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'v>, key) => 'v",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.checkInvariantInternal",
      "kind": "value",
      "name": "checkInvariantInternal",
      "signature": "let checkInvariantInternal: t<'a> => unit",
      "docstrings": [
        "**raise** when invariant is not held"
      ]
    },
    {
      "id": "Belt_MapString.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'v>, key) => t<'v>",
      "docstrings": [
        "`remove m x` returns a map containing the same bindings as\n    `m`, except for `x` which is unbound in the returned map."
      ]
    },
    {
      "id": "Belt_MapString.removeMany",
      "kind": "value",
      "name": "removeMany",
      "signature": "let removeMany: (t<'v>, array<key>) => t<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'v>, key, 'v) => t<'v>",
      "docstrings": [
        "`set m x y` returns a map containing the same bindings as\n  `m`, plus a binding of `x` to `y`. If `x` was already bound\n  in `m`, its previous binding disappears."
      ]
    },
    {
      "id": "Belt_MapString.updateU",
      "kind": "value",
      "name": "updateU",
      "signature": "let updateU: (t<'v>, key, (. option<'v>) => option<'v>) => t<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.update",
      "kind": "value",
      "name": "update",
      "signature": "let update: (t<'v>, key, option<'v> => option<'v>) => t<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.mergeU",
      "kind": "value",
      "name": "mergeU",
      "signature": "let mergeU: (t<'v>, t<'v2>, (. key, option<'v>, option<'v2>) => option<'c>) => t<'c>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.merge",
      "kind": "value",
      "name": "merge",
      "signature": "let merge: (t<'v>, t<'v2>, (key, option<'v>, option<'v2>) => option<'c>) => t<'c>",
      "docstrings": [
        "`merge m1 m2 f` computes a map whose keys is a subset of keys of `m1`\n  and of `m2`. The presence of each such binding, and the corresponding\n  value, is determined with the function `f`."
      ]
    },
    {
      "id": "Belt_MapString.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t<'v>, array<(key, 'v)>) => t<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (t<'v>, (. key, 'v) => bool) => t<'v>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (t<'v>, (key, 'v) => bool) => t<'v>",
      "docstrings": [
        "`keep m p` returns the map with all the bindings in `m`\n    that satisfy predicate `p`."
      ]
    },
    {
      "id": "Belt_MapString.partitionU",
      "kind": "value",
      "name": "partitionU",
      "signature": "let partitionU: (t<'v>, (. key, 'v) => bool) => (t<'v>, t<'v>)",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)",
      "docstrings": [
        "`partition m p` returns a pair of maps `(m1, m2)`, where\n  `m1` contains all the bindings of `s` that satisfy the\n  predicate `p`, and `m2` is the map with all the bindings of\n  `s` that do not satisfy `p`."
      ]
    },
    {
      "id": "Belt_MapString.split",
      "kind": "value",
      "name": "split",
      "signature": "let split: (key, t<'v>) => (t<'v>, option<'v>, t<'v>)",
      "docstrings": [
        "`split x m` returns a triple `(l, data, r)`, where\n  `l` is the map with all the bindings of `m` whose key\n  is strictly less than `x`;\n  `r` is the map with all the bindings of `m` whose key\n  is strictly greater than `x`;\n  `data` is `None` if `m` contains no binding for `x`,\n  or `Some v` if `m` binds `v` to `x`."
      ]
    },
    {
      "id": "Belt_MapString.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (t<'v>, (. 'v) => 'v2) => t<'v2>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'v>, 'v => 'v2) => t<'v2>",
      "docstrings": [
        "`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."
      ]
    },
    {
      "id": "Belt_MapString.mapWithKeyU",
      "kind": "value",
      "name": "mapWithKeyU",
      "signature": "let mapWithKeyU: (t<'v>, (. key, 'v) => 'v2) => t<'v2>",
      "docstrings": []
    },
    {
      "id": "Belt_MapString.mapWithKey",
      "kind": "value",
      "name": "mapWithKey",
      "signature": "let mapWithKey: (t<'v>, (key, 'v) => 'v2) => t<'v2>",
      "docstrings": []
    }
  ]
}