{
  "name": "BytesLabels",
  "docstrings": [],
  "items": [
    {
      "id": "BytesLabels.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: bytes => int",
      "docstrings": [
        "Return the length (number of bytes) of the argument."
      ]
    },
    {
      "id": "BytesLabels.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (bytes, int) => char",
      "docstrings": [
        "[get s n] returns the byte at index [n] in argument [s].\n\n    Raise [Invalid_argument] if [n] is not a valid index in [s]."
      ]
    },
    {
      "id": "BytesLabels.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (bytes, int, char) => unit",
      "docstrings": [
        "[set s n c] modifies [s] in place, replacing the byte at index [n]\n    with [c].\n\n    Raise [Invalid_argument] if [n] is not a valid index in [s]."
      ]
    },
    {
      "id": "BytesLabels.create",
      "kind": "value",
      "name": "create",
      "signature": "let create: int => bytes",
      "docstrings": [
        "[create n] returns a new byte sequence of length [n]. The\n    sequence is uninitialized and contains arbitrary bytes.\n\n    Raise [Invalid_argument] if [n < 0] or [n > ]{!Sys.max_string_length}."
      ]
    },
    {
      "id": "BytesLabels.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (int, char) => bytes",
      "docstrings": [
        "[make n c] returns a new byte sequence of length [n], filled with\n    the byte [c].\n\n    Raise [Invalid_argument] if [n < 0] or [n > ]{!Sys.max_string_length}."
      ]
    },
    {
      "id": "BytesLabels.init",
      "kind": "value",
      "name": "init",
      "signature": "let init: (int, ~f: int => char) => bytes",
      "docstrings": [
        "[init n f] returns a fresh byte sequence of length [n],\n    with character [i] initialized to the result of [f i].\n\n    Raise [Invalid_argument] if [n < 0] or [n > ]{!Sys.max_string_length}."
      ]
    },
    {
      "id": "BytesLabels.empty",
      "kind": "value",
      "name": "empty",
      "signature": "let empty: bytes",
      "docstrings": [
        "A byte sequence of size 0."
      ]
    },
    {
      "id": "BytesLabels.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: bytes => bytes",
      "docstrings": [
        "Return a new byte sequence that contains the same bytes as the\n    argument."
      ]
    },
    {
      "id": "BytesLabels.of_string",
      "kind": "value",
      "name": "of_string",
      "signature": "let of_string: string => bytes",
      "docstrings": [
        "Return a new byte sequence that contains the same bytes as the\n    given string."
      ]
    },
    {
      "id": "BytesLabels.to_string",
      "kind": "value",
      "name": "to_string",
      "signature": "let to_string: bytes => string",
      "docstrings": [
        "Return a new string that contains the same bytes as the given byte\n    sequence."
      ]
    },
    {
      "id": "BytesLabels.sub",
      "kind": "value",
      "name": "sub",
      "signature": "let sub: (bytes, ~pos: int, ~len: int) => bytes",
      "docstrings": [
        "[sub s start len] returns a new byte sequence of length [len],\n    containing the subsequence of [s] that starts at position [start]\n    and has length [len].\n\n    Raise [Invalid_argument] if [start] and [len] do not designate a\n    valid range of [s]."
      ]
    },
    {
      "id": "BytesLabels.sub_string",
      "kind": "value",
      "name": "sub_string",
      "signature": "let sub_string: (bytes, ~pos: int, ~len: int) => string",
      "docstrings": [
        "Same as [sub] but return a string instead of a byte sequence."
      ]
    },
    {
      "id": "BytesLabels.extend",
      "kind": "value",
      "name": "extend",
      "signature": "let extend: (bytes, ~left: int, ~right: int) => bytes",
      "docstrings": [
        "[extend s left right] returns a new byte sequence that contains\n    the bytes of [s], with [left] uninitialized bytes prepended and\n    [right] uninitialized bytes appended to it. If [left] or [right]\n    is negative, then bytes are removed (instead of appended) from\n    the corresponding side of [s].\n\n    Raise [Invalid_argument] if the result length is negative or\n    longer than {!Sys.max_string_length} bytes.\n    @since 4.05.0"
      ]
    },
    {
      "id": "BytesLabels.fill",
      "kind": "value",
      "name": "fill",
      "signature": "let fill: (bytes, ~pos: int, ~len: int, char) => unit",
      "docstrings": [
        "[fill s start len c] modifies [s] in place, replacing [len]\n    characters with [c], starting at [start].\n\n    Raise [Invalid_argument] if [start] and [len] do not designate a\n    valid range of [s]."
      ]
    },
    {
      "id": "BytesLabels.blit",
      "kind": "value",
      "name": "blit",
      "signature": "let blit: (~src: bytes, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit",
      "docstrings": [
        "[blit src srcoff dst dstoff len] copies [len] bytes from sequence\n    [src], starting at index [srcoff], to sequence [dst], starting at\n    index [dstoff]. It works correctly even if [src] and [dst] are the\n    same byte sequence, and the source and destination intervals\n    overlap.\n\n    Raise [Invalid_argument] if [srcoff] and [len] do not\n    designate a valid range of [src], or if [dstoff] and [len]\n    do not designate a valid range of [dst]."
      ]
    },
    {
      "id": "BytesLabels.blit_string",
      "kind": "value",
      "name": "blit_string",
      "signature": "let blit_string: (~src: string, ~src_pos: int, ~dst: bytes, ~dst_pos: int, ~len: int) => unit",
      "docstrings": [
        "[blit src srcoff dst dstoff len] copies [len] bytes from string\n    [src], starting at index [srcoff], to byte sequence [dst],\n    starting at index [dstoff].\n\n    Raise [Invalid_argument] if [srcoff] and [len] do not\n    designate a valid range of [src], or if [dstoff] and [len]\n    do not designate a valid range of [dst].\n    @since 4.05.0"
      ]
    },
    {
      "id": "BytesLabels.concat",
      "kind": "value",
      "name": "concat",
      "signature": "let concat: (~sep: bytes, list<bytes>) => bytes",
      "docstrings": [
        "[concat sep sl] concatenates the list of byte sequences [sl],\n    inserting the separator byte sequence [sep] between each, and\n    returns the result as a new byte sequence."
      ]
    },
    {
      "id": "BytesLabels.cat",
      "kind": "value",
      "name": "cat",
      "signature": "let cat: (bytes, bytes) => bytes",
      "docstrings": [
        "[cat s1 s2] concatenates [s1] and [s2] and returns the result\n     as new byte sequence.\n\n    Raise [Invalid_argument] if the result is longer than\n    {!Sys.max_string_length} bytes.\n    @since 4.05.0"
      ]
    },
    {
      "id": "BytesLabels.iter",
      "kind": "value",
      "name": "iter",
      "signature": "let iter: (~f: char => unit, bytes) => unit",
      "docstrings": [
        "[iter f s] applies function [f] in turn to all the bytes of [s].\n    It is equivalent to [f (get s 0); f (get s 1); ...; f (get s\n    (length s - 1)); ()]."
      ]
    },
    {
      "id": "BytesLabels.iteri",
      "kind": "value",
      "name": "iteri",
      "signature": "let iteri: (~f: (int, char) => unit, bytes) => unit",
      "docstrings": [
        "Same as {!Bytes.iter}, but the function is applied to the index of\n    the byte as first argument and the byte itself as second\n    argument."
      ]
    },
    {
      "id": "BytesLabels.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (~f: char => char, bytes) => bytes",
      "docstrings": [
        "[map f s] applies function [f] in turn to all the bytes of [s] and\n    stores the resulting bytes in a new sequence that is returned as\n    the result."
      ]
    },
    {
      "id": "BytesLabels.mapi",
      "kind": "value",
      "name": "mapi",
      "signature": "let mapi: (~f: (int, char) => char, bytes) => bytes",
      "docstrings": [
        "[mapi f s] calls [f] with each character of [s] and its\n    index (in increasing index order) and stores the resulting bytes\n    in a new sequence that is returned as the result."
      ]
    },
    {
      "id": "BytesLabels.trim",
      "kind": "value",
      "name": "trim",
      "signature": "let trim: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, without leading and trailing\n    whitespace. The bytes regarded as whitespace are the ASCII\n    characters [' '], ['\\012'], ['\\n'], ['\\r'], and ['\\t']."
      ]
    },
    {
      "id": "BytesLabels.escaped",
      "kind": "value",
      "name": "escaped",
      "signature": "let escaped: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with special characters represented\n    by escape sequences, following the lexical conventions of OCaml."
      ]
    },
    {
      "id": "BytesLabels.index",
      "kind": "value",
      "name": "index",
      "signature": "let index: (bytes, char) => int",
      "docstrings": [
        "[index s c] returns the index of the first occurrence of byte [c]\n    in [s].\n\n    Raise [Not_found] if [c] does not occur in [s]."
      ]
    },
    {
      "id": "BytesLabels.index_opt",
      "kind": "value",
      "name": "index_opt",
      "signature": "let index_opt: (bytes, char) => option<int>",
      "docstrings": [
        "[index_opt s c] returns the index of the first occurrence of byte [c]\n    in [s] or [None] if [c] does not occur in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "BytesLabels.rindex",
      "kind": "value",
      "name": "rindex",
      "signature": "let rindex: (bytes, char) => int",
      "docstrings": [
        "[rindex s c] returns the index of the last occurrence of byte [c]\n    in [s].\n\n    Raise [Not_found] if [c] does not occur in [s]."
      ]
    },
    {
      "id": "BytesLabels.rindex_opt",
      "kind": "value",
      "name": "rindex_opt",
      "signature": "let rindex_opt: (bytes, char) => option<int>",
      "docstrings": [
        "[rindex_opt s c] returns the index of the last occurrence of byte [c]\n    in [s] or [None] if [c] does not occur in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "BytesLabels.index_from",
      "kind": "value",
      "name": "index_from",
      "signature": "let index_from: (bytes, int, char) => int",
      "docstrings": [
        "[index_from s i c] returns the index of the first occurrence of\n    byte [c] in [s] after position [i].  [Bytes.index s c] is\n    equivalent to [Bytes.index_from s 0 c].\n\n    Raise [Invalid_argument] if [i] is not a valid position in [s].\n    Raise [Not_found] if [c] does not occur in [s] after position [i]."
      ]
    },
    {
      "id": "BytesLabels.index_from_opt",
      "kind": "value",
      "name": "index_from_opt",
      "signature": "let index_from_opt: (bytes, int, char) => option<int>",
      "docstrings": [
        "[index_from _opts i c] returns the index of the first occurrence of\n    byte [c] in [s] after position [i] or [None] if [c] does not occur in [s] after position [i].\n    [Bytes.index_opt s c] is equivalent to [Bytes.index_from_opt s 0 c].\n\n    Raise [Invalid_argument] if [i] is not a valid position in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "BytesLabels.rindex_from",
      "kind": "value",
      "name": "rindex_from",
      "signature": "let rindex_from: (bytes, int, char) => int",
      "docstrings": [
        "[rindex_from s i c] returns the index of the last occurrence of\n    byte [c] in [s] before position [i+1].  [rindex s c] is equivalent\n    to [rindex_from s (Bytes.length s - 1) c].\n\n    Raise [Invalid_argument] if [i+1] is not a valid position in [s].\n    Raise [Not_found] if [c] does not occur in [s] before position [i+1]."
      ]
    },
    {
      "id": "BytesLabels.rindex_from_opt",
      "kind": "value",
      "name": "rindex_from_opt",
      "signature": "let rindex_from_opt: (bytes, int, char) => option<int>",
      "docstrings": [
        "[rindex_from_opt s i c] returns the index of the last occurrence\n    of byte [c] in [s] before position [i+1] or [None] if [c] does not\n    occur in [s] before position [i+1].  [rindex_opt s c] is equivalent to\n    [rindex_from s (Bytes.length s - 1) c].\n\n    Raise [Invalid_argument] if [i+1] is not a valid position in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "BytesLabels.contains",
      "kind": "value",
      "name": "contains",
      "signature": "let contains: (bytes, char) => bool",
      "docstrings": [
        "[contains s c] tests if byte [c] appears in [s]."
      ]
    },
    {
      "id": "BytesLabels.contains_from",
      "kind": "value",
      "name": "contains_from",
      "signature": "let contains_from: (bytes, int, char) => bool",
      "docstrings": [
        "[contains_from s start c] tests if byte [c] appears in [s] after\n    position [start].  [contains s c] is equivalent to [contains_from\n    s 0 c].\n\n    Raise [Invalid_argument] if [start] is not a valid position in [s]."
      ]
    },
    {
      "id": "BytesLabels.rcontains_from",
      "kind": "value",
      "name": "rcontains_from",
      "signature": "let rcontains_from: (bytes, int, char) => bool",
      "docstrings": [
        "[rcontains_from s stop c] tests if byte [c] appears in [s] before\n    position [stop+1].\n\n    Raise [Invalid_argument] if [stop < 0] or [stop+1] is not a valid\n    position in [s]."
      ]
    },
    {
      "id": "BytesLabels.uppercase_ascii",
      "kind": "value",
      "name": "uppercase_ascii",
      "signature": "let uppercase_ascii: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with all lowercase letters\n   translated to uppercase, using the US-ASCII character set.\n   @since 4.05.0"
      ]
    },
    {
      "id": "BytesLabels.lowercase_ascii",
      "kind": "value",
      "name": "lowercase_ascii",
      "signature": "let lowercase_ascii: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with all uppercase letters\n   translated to lowercase, using the US-ASCII character set.\n   @since 4.05.0"
      ]
    },
    {
      "id": "BytesLabels.capitalize_ascii",
      "kind": "value",
      "name": "capitalize_ascii",
      "signature": "let capitalize_ascii: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with the first character set to uppercase,\n   using the US-ASCII character set.\n   @since 4.05.0"
      ]
    },
    {
      "id": "BytesLabels.uncapitalize_ascii",
      "kind": "value",
      "name": "uncapitalize_ascii",
      "signature": "let uncapitalize_ascii: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with the first character set to lowercase,\n   using the US-ASCII character set.\n   @since 4.05.0"
      ]
    },
    {
      "id": "BytesLabels.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = bytes",
      "docstrings": [
        "An alias for the type of byte sequences."
      ]
    },
    {
      "id": "BytesLabels.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (t, t) => int",
      "docstrings": [
        "The comparison function for byte sequences, with the same\n    specification as {!Pervasives.compare}.  Along with the type [t],\n    this function [compare] allows the module [Bytes] to be passed as\n    argument to the functors {!Set.Make} and {!Map.Make}."
      ]
    },
    {
      "id": "BytesLabels.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (t, t) => bool",
      "docstrings": [
        "The equality function for byte sequences.\n    @since 4.05.0"
      ]
    },
    {
      "id": "BytesLabels.unsafe_get",
      "kind": "value",
      "name": "unsafe_get",
      "signature": "let unsafe_get: (bytes, int) => char",
      "docstrings": []
    },
    {
      "id": "BytesLabels.unsafe_set",
      "kind": "value",
      "name": "unsafe_set",
      "signature": "let unsafe_set: (bytes, int, char) => unit",
      "docstrings": []
    },
    {
      "id": "BytesLabels.unsafe_to_string",
      "kind": "value",
      "name": "unsafe_to_string",
      "signature": "let unsafe_to_string: bytes => string",
      "docstrings": []
    },
    {
      "id": "BytesLabels.unsafe_of_string",
      "kind": "value",
      "name": "unsafe_of_string",
      "signature": "let unsafe_of_string: string => bytes",
      "docstrings": []
    }
  ]
}