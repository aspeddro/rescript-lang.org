{
  "name": "String",
  "docstrings": [],
  "items": [
    {
      "id": "String.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: string => int",
      "docstrings": [
        "Return the length (number of characters) of the given string."
      ]
    },
    {
      "id": "String.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (string, int) => char",
      "docstrings": [
        "[String.get s n] returns the character at index [n] in string [s].\n   You can also write [s.[n]] instead of [String.get s n].\n\n   Raise [Invalid_argument] if [n] not a valid index in [s]."
      ]
    },
    {
      "id": "String.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (int, char) => string",
      "docstrings": [
        "[String.make n c] returns a fresh string of length [n],\n   filled with the character [c].\n\n   Raise [Invalid_argument] if [n < 0] or [n > ]{!Sys.max_string_length}."
      ]
    },
    {
      "id": "String.init",
      "kind": "value",
      "name": "init",
      "signature": "let init: (int, int => char) => string",
      "docstrings": [
        "[String.init n f] returns a string of length [n], with character\n    [i] initialized to the result of [f i] (called in increasing\n    index order).\n\n    Raise [Invalid_argument] if [n < 0] or [n > ]{!Sys.max_string_length}.\n\n    @since 4.02.0"
      ]
    },
    {
      "id": "String.sub",
      "kind": "value",
      "name": "sub",
      "signature": "let sub: (string, int, int) => string",
      "docstrings": [
        "[String.sub s start len] returns a fresh string of length [len],\n   containing the substring of [s] that starts at position [start] and\n   has length [len].\n\n   Raise [Invalid_argument] if [start] and [len] do not\n   designate a valid substring of [s]."
      ]
    },
    {
      "id": "String.blit",
      "kind": "value",
      "name": "blit",
      "signature": "let blit: (string, int, bytes, int, int) => unit",
      "docstrings": [
        "Same as {!Bytes.blit_string}."
      ]
    },
    {
      "id": "String.concat",
      "kind": "value",
      "name": "concat",
      "signature": "let concat: (string, list<string>) => string",
      "docstrings": [
        "[String.concat sep sl] concatenates the list of strings [sl],\n    inserting the separator string [sep] between each.\n\n    Raise [Invalid_argument] if the result is longer than\n    {!Sys.max_string_length} bytes."
      ]
    },
    {
      "id": "String.iter",
      "kind": "value",
      "name": "iter",
      "signature": "let iter: (char => unit, string) => unit",
      "docstrings": [
        "[String.iter f s] applies function [f] in turn to all\n   the characters of [s].  It is equivalent to\n   [f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ()]."
      ]
    },
    {
      "id": "String.iteri",
      "kind": "value",
      "name": "iteri",
      "signature": "let iteri: ((int, char) => unit, string) => unit",
      "docstrings": [
        "Same as {!String.iter}, but the\n   function is applied to the index of the element as first argument\n   (counting from 0), and the character itself as second argument.\n   @since 4.00.0"
      ]
    },
    {
      "id": "String.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (char => char, string) => string",
      "docstrings": [
        "[String.map f s] applies function [f] in turn to all the\n    characters of [s] (in increasing index order) and stores the\n    results in a new string that is returned.\n    @since 4.00.0"
      ]
    },
    {
      "id": "String.mapi",
      "kind": "value",
      "name": "mapi",
      "signature": "let mapi: ((int, char) => char, string) => string",
      "docstrings": [
        "[String.mapi f s] calls [f] with each character of [s] and its\n    index (in increasing index order) and stores the results in a new\n    string that is returned.\n    @since 4.02.0"
      ]
    },
    {
      "id": "String.trim",
      "kind": "value",
      "name": "trim",
      "signature": "let trim: string => string",
      "docstrings": [
        "Return a copy of the argument, without leading and trailing\n   whitespace.  The characters regarded as whitespace are: [' '],\n   ['\\012'], ['\\n'], ['\\r'], and ['\\t'].  If there is neither leading nor\n   trailing whitespace character in the argument, return the original\n   string itself, not a copy.\n   @since 4.00.0"
      ]
    },
    {
      "id": "String.escaped",
      "kind": "value",
      "name": "escaped",
      "signature": "let escaped: string => string",
      "docstrings": [
        "Return a copy of the argument, with special characters\n    represented by escape sequences, following the lexical\n    conventions of OCaml.\n    All characters outside the ASCII printable range (32..126) are\n    escaped, as well as backslash and double-quote.\n\n    If there is no special character in the argument that needs\n    escaping, return the original string itself, not a copy.\n\n    Raise [Invalid_argument] if the result is longer than\n    {!Sys.max_string_length} bytes.\n\n    The function {!Scanf.unescaped} is a left inverse of [escaped],\n    i.e. [Scanf.unescaped (escaped s) = s] for any string [s] (unless\n    [escape s] fails)."
      ]
    },
    {
      "id": "String.index",
      "kind": "value",
      "name": "index",
      "signature": "let index: (string, char) => int",
      "docstrings": [
        "[String.index s c] returns the index of the first\n   occurrence of character [c] in string [s].\n\n   Raise [Not_found] if [c] does not occur in [s]."
      ]
    },
    {
      "id": "String.index_opt",
      "kind": "value",
      "name": "index_opt",
      "signature": "let index_opt: (string, char) => option<int>",
      "docstrings": [
        "[String.index_opt s c] returns the index of the first\n    occurrence of character [c] in string [s], or\n    [None] if [c] does not occur in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "String.rindex",
      "kind": "value",
      "name": "rindex",
      "signature": "let rindex: (string, char) => int",
      "docstrings": [
        "[String.rindex s c] returns the index of the last\n   occurrence of character [c] in string [s].\n\n   Raise [Not_found] if [c] does not occur in [s]."
      ]
    },
    {
      "id": "String.rindex_opt",
      "kind": "value",
      "name": "rindex_opt",
      "signature": "let rindex_opt: (string, char) => option<int>",
      "docstrings": [
        "[String.rindex_opt s c] returns the index of the last occurrence\n    of character [c] in string [s], or [None] if [c] does not occur in\n    [s].\n    @since 4.05"
      ]
    },
    {
      "id": "String.index_from",
      "kind": "value",
      "name": "index_from",
      "signature": "let index_from: (string, int, char) => int",
      "docstrings": [
        "[String.index_from s i c] returns the index of the\n   first occurrence of character [c] in string [s] after position [i].\n   [String.index s c] is equivalent to [String.index_from s 0 c].\n\n   Raise [Invalid_argument] if [i] is not a valid position in [s].\n   Raise [Not_found] if [c] does not occur in [s] after position [i]."
      ]
    },
    {
      "id": "String.index_from_opt",
      "kind": "value",
      "name": "index_from_opt",
      "signature": "let index_from_opt: (string, int, char) => option<int>",
      "docstrings": [
        "[String.index_from_opt s i c] returns the index of the\n    first occurrence of character [c] in string [s] after position [i]\n    or [None] if [c] does not occur in [s] after position [i].\n\n    [String.index_opt s c] is equivalent to [String.index_from_opt s 0 c].\n    Raise [Invalid_argument] if [i] is not a valid position in [s].\n\n    @since 4.05"
      ]
    },
    {
      "id": "String.rindex_from",
      "kind": "value",
      "name": "rindex_from",
      "signature": "let rindex_from: (string, int, char) => int",
      "docstrings": [
        "[String.rindex_from s i c] returns the index of the\n   last occurrence of character [c] in string [s] before position [i+1].\n   [String.rindex s c] is equivalent to\n   [String.rindex_from s (String.length s - 1) c].\n\n   Raise [Invalid_argument] if [i+1] is not a valid position in [s].\n   Raise [Not_found] if [c] does not occur in [s] before position [i+1]."
      ]
    },
    {
      "id": "String.rindex_from_opt",
      "kind": "value",
      "name": "rindex_from_opt",
      "signature": "let rindex_from_opt: (string, int, char) => option<int>",
      "docstrings": [
        "[String.rindex_from_opt s i c] returns the index of the\n   last occurrence of character [c] in string [s] before position [i+1]\n   or [None] if [c] does not occur in [s] before position [i+1].\n\n   [String.rindex_opt s c] is equivalent to\n   [String.rindex_from_opt s (String.length s - 1) c].\n\n   Raise [Invalid_argument] if [i+1] is not a valid position in [s].\n\n    @since 4.05"
      ]
    },
    {
      "id": "String.contains",
      "kind": "value",
      "name": "contains",
      "signature": "let contains: (string, char) => bool",
      "docstrings": [
        "[String.contains s c] tests if character [c]\n   appears in the string [s]."
      ]
    },
    {
      "id": "String.contains_from",
      "kind": "value",
      "name": "contains_from",
      "signature": "let contains_from: (string, int, char) => bool",
      "docstrings": [
        "[String.contains_from s start c] tests if character [c]\n   appears in [s] after position [start].\n   [String.contains s c] is equivalent to\n   [String.contains_from s 0 c].\n\n   Raise [Invalid_argument] if [start] is not a valid position in [s]."
      ]
    },
    {
      "id": "String.rcontains_from",
      "kind": "value",
      "name": "rcontains_from",
      "signature": "let rcontains_from: (string, int, char) => bool",
      "docstrings": [
        "[String.rcontains_from s stop c] tests if character [c]\n   appears in [s] before position [stop+1].\n\n   Raise [Invalid_argument] if [stop < 0] or [stop+1] is not a valid\n   position in [s]."
      ]
    },
    {
      "id": "String.uppercase_ascii",
      "kind": "value",
      "name": "uppercase_ascii",
      "signature": "let uppercase_ascii: string => string",
      "docstrings": [
        "Return a copy of the argument, with all lowercase letters\n   translated to uppercase, using the US-ASCII character set.\n   @since 4.03.0"
      ]
    },
    {
      "id": "String.lowercase_ascii",
      "kind": "value",
      "name": "lowercase_ascii",
      "signature": "let lowercase_ascii: string => string",
      "docstrings": [
        "Return a copy of the argument, with all uppercase letters\n   translated to lowercase, using the US-ASCII character set.\n   @since 4.03.0"
      ]
    },
    {
      "id": "String.capitalize_ascii",
      "kind": "value",
      "name": "capitalize_ascii",
      "signature": "let capitalize_ascii: string => string",
      "docstrings": [
        "Return a copy of the argument, with the first character set to uppercase,\n   using the US-ASCII character set.\n   @since 4.03.0"
      ]
    },
    {
      "id": "String.uncapitalize_ascii",
      "kind": "value",
      "name": "uncapitalize_ascii",
      "signature": "let uncapitalize_ascii: string => string",
      "docstrings": [
        "Return a copy of the argument, with the first character set to lowercase,\n   using the US-ASCII character set.\n   @since 4.03.0"
      ]
    },
    {
      "id": "String.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = string",
      "docstrings": [
        "An alias for the type of strings."
      ]
    },
    {
      "id": "String.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (t, t) => int",
      "docstrings": [
        "The comparison function for strings, with the same specification as\n    {!Pervasives.compare}.  Along with the type [t], this function [compare]\n    allows the module [String] to be passed as argument to the functors\n    {!Set.Make} and {!Map.Make}."
      ]
    },
    {
      "id": "String.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (t, t) => bool",
      "docstrings": [
        "The equal function for strings.\n    @since 4.03.0"
      ]
    },
    {
      "id": "String.split_on_char",
      "kind": "value",
      "name": "split_on_char",
      "signature": "let split_on_char: (char, string) => list<string>",
      "docstrings": [
        "[String.split_on_char sep s] returns the list of all (possibly empty)\n    substrings of [s] that are delimited by the [sep] character.\n\n    The function's output is specified by the following invariants:\n\n    - The list is not empty.\n    - Concatenating its elements using [sep] as a separator returns a\n      string equal to the input ([String.concat (String.make 1 sep)\n      (String.split_on_char sep s) = s]).\n    - No string in the result contains the [sep] character.\n\n    @since 4.04.0"
      ]
    },
    {
      "id": "String.unsafe_get",
      "kind": "value",
      "name": "unsafe_get",
      "signature": "let unsafe_get: (string, int) => char",
      "docstrings": []
    }
  ]
}