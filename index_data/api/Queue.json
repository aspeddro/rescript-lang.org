{
  "name": "Queue",
  "docstrings": [],
  "items": [
    {
      "id": "Queue.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a>",
      "docstrings": [
        "The type of queues containing elements of type ['a]."
      ]
    },
    {
      "id": "Queue.create",
      "kind": "value",
      "name": "create",
      "signature": "let create: unit => t<'a>",
      "docstrings": [
        "Return a new queue, initially empty."
      ]
    },
    {
      "id": "Queue.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: ('a, t<'a>) => unit",
      "docstrings": [
        "[add x q] adds the element [x] at the end of the queue [q]."
      ]
    },
    {
      "id": "Queue.push",
      "kind": "value",
      "name": "push",
      "signature": "let push: ('a, t<'a>) => unit",
      "docstrings": [
        "[push] is a synonym for [add]."
      ]
    },
    {
      "id": "Queue.take",
      "kind": "value",
      "name": "take",
      "signature": "let take: t<'a> => 'a",
      "docstrings": [
        "[take q] removes and returns the first element in queue [q],\n   or raises {!Empty} if the queue is empty."
      ]
    },
    {
      "id": "Queue.pop",
      "kind": "value",
      "name": "pop",
      "signature": "let pop: t<'a> => 'a",
      "docstrings": [
        "[pop] is a synonym for [take]."
      ]
    },
    {
      "id": "Queue.peek",
      "kind": "value",
      "name": "peek",
      "signature": "let peek: t<'a> => 'a",
      "docstrings": [
        "[peek q] returns the first element in queue [q], without removing\n   it from the queue, or raises {!Empty} if the queue is empty."
      ]
    },
    {
      "id": "Queue.top",
      "kind": "value",
      "name": "top",
      "signature": "let top: t<'a> => 'a",
      "docstrings": [
        "[top] is a synonym for [peek]."
      ]
    },
    {
      "id": "Queue.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'a> => unit",
      "docstrings": [
        "Discard all elements from a queue."
      ]
    },
    {
      "id": "Queue.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'a> => t<'a>",
      "docstrings": [
        "Return a copy of the given queue."
      ]
    },
    {
      "id": "Queue.is_empty",
      "kind": "value",
      "name": "is_empty",
      "signature": "let is_empty: t<'a> => bool",
      "docstrings": [
        "Return [true] if the given queue is empty, [false] otherwise."
      ]
    },
    {
      "id": "Queue.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: t<'a> => int",
      "docstrings": [
        "Return the number of elements in a queue."
      ]
    },
    {
      "id": "Queue.iter",
      "kind": "value",
      "name": "iter",
      "signature": "let iter: ('a => unit, t<'a>) => unit",
      "docstrings": [
        "[iter f q] applies [f] in turn to all elements of [q],\n   from the least recently entered to the most recently entered.\n   The queue itself is unchanged."
      ]
    },
    {
      "id": "Queue.fold",
      "kind": "value",
      "name": "fold",
      "signature": "let fold: (('b, 'a) => 'b, 'b, t<'a>) => 'b",
      "docstrings": [
        "[fold f accu q] is equivalent to [List.fold_left f accu l],\n   where [l] is the list of [q]'s elements. The queue remains\n   unchanged."
      ]
    },
    {
      "id": "Queue.transfer",
      "kind": "value",
      "name": "transfer",
      "signature": "let transfer: (t<'a>, t<'a>) => unit",
      "docstrings": [
        "[transfer q1 q2] adds all of [q1]'s elements at the end of\n   the queue [q2], then clears [q1]. It is equivalent to the\n   sequence [iter (fun x -> add x q2) q1; clear q1], but runs\n   in constant time."
      ]
    }
  ]
}