{
  "name": "Bytes",
  "docstrings": [],
  "items": [
    {
      "id": "Bytes.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: bytes => int",
      "docstrings": [
        "Return the length (number of bytes) of the argument."
      ]
    },
    {
      "id": "Bytes.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (bytes, int) => char",
      "docstrings": [
        "[get s n] returns the byte at index [n] in argument [s].\n\n    Raise [Invalid_argument] if [n] is not a valid index in [s]."
      ]
    },
    {
      "id": "Bytes.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (bytes, int, char) => unit",
      "docstrings": [
        "[set s n c] modifies [s] in place, replacing the byte at index [n]\n    with [c].\n\n    Raise [Invalid_argument] if [n] is not a valid index in [s]."
      ]
    },
    {
      "id": "Bytes.create",
      "kind": "value",
      "name": "create",
      "signature": "let create: int => bytes",
      "docstrings": [
        "[create n] returns a new byte sequence of length [n]. The\n    sequence is uninitialized and contains arbitrary bytes.\n\n    Raise [Invalid_argument] if [n < 0] or [n > ]{!Sys.max_string_length}."
      ]
    },
    {
      "id": "Bytes.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (int, char) => bytes",
      "docstrings": [
        "[make n c] returns a new byte sequence of length [n], filled with\n    the byte [c].\n\n    Raise [Invalid_argument] if [n < 0] or [n > ]{!Sys.max_string_length}."
      ]
    },
    {
      "id": "Bytes.init",
      "kind": "value",
      "name": "init",
      "signature": "let init: (int, int => char) => bytes",
      "docstrings": [
        "[Bytes.init n f] returns a fresh byte sequence of length [n], with\n    character [i] initialized to the result of [f i] (in increasing\n    index order).\n\n    Raise [Invalid_argument] if [n < 0] or [n > ]{!Sys.max_string_length}."
      ]
    },
    {
      "id": "Bytes.empty",
      "kind": "value",
      "name": "empty",
      "signature": "let empty: bytes",
      "docstrings": [
        "A byte sequence of size 0."
      ]
    },
    {
      "id": "Bytes.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: bytes => bytes",
      "docstrings": [
        "Return a new byte sequence that contains the same bytes as the\n    argument."
      ]
    },
    {
      "id": "Bytes.of_string",
      "kind": "value",
      "name": "of_string",
      "signature": "let of_string: string => bytes",
      "docstrings": [
        "Return a new byte sequence that contains the same bytes as the\n    given string."
      ]
    },
    {
      "id": "Bytes.to_string",
      "kind": "value",
      "name": "to_string",
      "signature": "let to_string: bytes => string",
      "docstrings": [
        "Return a new string that contains the same bytes as the given byte\n    sequence."
      ]
    },
    {
      "id": "Bytes.sub",
      "kind": "value",
      "name": "sub",
      "signature": "let sub: (bytes, int, int) => bytes",
      "docstrings": [
        "[sub s start len] returns a new byte sequence of length [len],\n    containing the subsequence of [s] that starts at position [start]\n    and has length [len].\n\n    Raise [Invalid_argument] if [start] and [len] do not designate a\n    valid range of [s]."
      ]
    },
    {
      "id": "Bytes.sub_string",
      "kind": "value",
      "name": "sub_string",
      "signature": "let sub_string: (bytes, int, int) => string",
      "docstrings": [
        "Same as [sub] but return a string instead of a byte sequence."
      ]
    },
    {
      "id": "Bytes.extend",
      "kind": "value",
      "name": "extend",
      "signature": "let extend: (bytes, int, int) => bytes",
      "docstrings": [
        "[extend s left right] returns a new byte sequence that contains\n    the bytes of [s], with [left] uninitialized bytes prepended and\n    [right] uninitialized bytes appended to it. If [left] or [right]\n    is negative, then bytes are removed (instead of appended) from\n    the corresponding side of [s].\n\n    Raise [Invalid_argument] if the result length is negative or\n    longer than {!Sys.max_string_length} bytes."
      ]
    },
    {
      "id": "Bytes.fill",
      "kind": "value",
      "name": "fill",
      "signature": "let fill: (bytes, int, int, char) => unit",
      "docstrings": [
        "[fill s start len c] modifies [s] in place, replacing [len]\n    characters with [c], starting at [start].\n\n    Raise [Invalid_argument] if [start] and [len] do not designate a\n    valid range of [s]."
      ]
    },
    {
      "id": "Bytes.blit",
      "kind": "value",
      "name": "blit",
      "signature": "let blit: (bytes, int, bytes, int, int) => unit",
      "docstrings": [
        "[blit src srcoff dst dstoff len] copies [len] bytes from sequence\n    [src], starting at index [srcoff], to sequence [dst], starting at\n    index [dstoff]. It works correctly even if [src] and [dst] are the\n    same byte sequence, and the source and destination intervals\n    overlap.\n\n    Raise [Invalid_argument] if [srcoff] and [len] do not\n    designate a valid range of [src], or if [dstoff] and [len]\n    do not designate a valid range of [dst]."
      ]
    },
    {
      "id": "Bytes.blit_string",
      "kind": "value",
      "name": "blit_string",
      "signature": "let blit_string: (string, int, bytes, int, int) => unit",
      "docstrings": [
        "[blit src srcoff dst dstoff len] copies [len] bytes from string\n    [src], starting at index [srcoff], to byte sequence [dst],\n    starting at index [dstoff].\n\n    Raise [Invalid_argument] if [srcoff] and [len] do not\n    designate a valid range of [src], or if [dstoff] and [len]\n    do not designate a valid range of [dst]."
      ]
    },
    {
      "id": "Bytes.concat",
      "kind": "value",
      "name": "concat",
      "signature": "let concat: (bytes, list<bytes>) => bytes",
      "docstrings": [
        "[concat sep sl] concatenates the list of byte sequences [sl],\n    inserting the separator byte sequence [sep] between each, and\n    returns the result as a new byte sequence.\n\n    Raise [Invalid_argument] if the result is longer than\n    {!Sys.max_string_length} bytes."
      ]
    },
    {
      "id": "Bytes.cat",
      "kind": "value",
      "name": "cat",
      "signature": "let cat: (bytes, bytes) => bytes",
      "docstrings": [
        "[cat s1 s2] concatenates [s1] and [s2] and returns the result\n     as new byte sequence.\n\n    Raise [Invalid_argument] if the result is longer than\n    {!Sys.max_string_length} bytes."
      ]
    },
    {
      "id": "Bytes.iter",
      "kind": "value",
      "name": "iter",
      "signature": "let iter: (char => unit, bytes) => unit",
      "docstrings": [
        "[iter f s] applies function [f] in turn to all the bytes of [s].\n    It is equivalent to [f (get s 0); f (get s 1); ...; f (get s\n    (length s - 1)); ()]."
      ]
    },
    {
      "id": "Bytes.iteri",
      "kind": "value",
      "name": "iteri",
      "signature": "let iteri: ((int, char) => unit, bytes) => unit",
      "docstrings": [
        "Same as {!Bytes.iter}, but the function is applied to the index of\n    the byte as first argument and the byte itself as second\n    argument."
      ]
    },
    {
      "id": "Bytes.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (char => char, bytes) => bytes",
      "docstrings": [
        "[map f s] applies function [f] in turn to all the bytes of [s]\n    (in increasing index order) and stores the resulting bytes in\n    a new sequence that is returned as the result."
      ]
    },
    {
      "id": "Bytes.mapi",
      "kind": "value",
      "name": "mapi",
      "signature": "let mapi: ((int, char) => char, bytes) => bytes",
      "docstrings": [
        "[mapi f s] calls [f] with each character of [s] and its\n    index (in increasing index order) and stores the resulting bytes\n    in a new sequence that is returned as the result."
      ]
    },
    {
      "id": "Bytes.trim",
      "kind": "value",
      "name": "trim",
      "signature": "let trim: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, without leading and trailing\n    whitespace. The bytes regarded as whitespace are the ASCII\n    characters [' '], ['\\012'], ['\\n'], ['\\r'], and ['\\t']."
      ]
    },
    {
      "id": "Bytes.escaped",
      "kind": "value",
      "name": "escaped",
      "signature": "let escaped: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with special characters represented\n    by escape sequences, following the lexical conventions of OCaml.\n    All characters outside the ASCII printable range (32..126) are\n    escaped, as well as backslash and double-quote.\n\n    Raise [Invalid_argument] if the result is longer than\n    {!Sys.max_string_length} bytes."
      ]
    },
    {
      "id": "Bytes.index",
      "kind": "value",
      "name": "index",
      "signature": "let index: (bytes, char) => int",
      "docstrings": [
        "[index s c] returns the index of the first occurrence of byte [c]\n    in [s].\n\n    Raise [Not_found] if [c] does not occur in [s]."
      ]
    },
    {
      "id": "Bytes.index_opt",
      "kind": "value",
      "name": "index_opt",
      "signature": "let index_opt: (bytes, char) => option<int>",
      "docstrings": [
        "[index_opt s c] returns the index of the first occurrence of byte [c]\n    in [s] or [None] if [c] does not occur in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "Bytes.rindex",
      "kind": "value",
      "name": "rindex",
      "signature": "let rindex: (bytes, char) => int",
      "docstrings": [
        "[rindex s c] returns the index of the last occurrence of byte [c]\n    in [s].\n\n    Raise [Not_found] if [c] does not occur in [s]."
      ]
    },
    {
      "id": "Bytes.rindex_opt",
      "kind": "value",
      "name": "rindex_opt",
      "signature": "let rindex_opt: (bytes, char) => option<int>",
      "docstrings": [
        "[rindex_opt s c] returns the index of the last occurrence of byte [c]\n    in [s] or [None] if [c] does not occur in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "Bytes.index_from",
      "kind": "value",
      "name": "index_from",
      "signature": "let index_from: (bytes, int, char) => int",
      "docstrings": [
        "[index_from s i c] returns the index of the first occurrence of\n    byte [c] in [s] after position [i].  [Bytes.index s c] is\n    equivalent to [Bytes.index_from s 0 c].\n\n    Raise [Invalid_argument] if [i] is not a valid position in [s].\n    Raise [Not_found] if [c] does not occur in [s] after position [i]."
      ]
    },
    {
      "id": "Bytes.index_from_opt",
      "kind": "value",
      "name": "index_from_opt",
      "signature": "let index_from_opt: (bytes, int, char) => option<int>",
      "docstrings": [
        "[index_from _opts i c] returns the index of the first occurrence of\n    byte [c] in [s] after position [i] or [None] if [c] does not occur in [s] after position [i].\n    [Bytes.index_opt s c] is equivalent to [Bytes.index_from_opt s 0 c].\n\n    Raise [Invalid_argument] if [i] is not a valid position in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "Bytes.rindex_from",
      "kind": "value",
      "name": "rindex_from",
      "signature": "let rindex_from: (bytes, int, char) => int",
      "docstrings": [
        "[rindex_from s i c] returns the index of the last occurrence of\n    byte [c] in [s] before position [i+1].  [rindex s c] is equivalent\n    to [rindex_from s (Bytes.length s - 1) c].\n\n    Raise [Invalid_argument] if [i+1] is not a valid position in [s].\n    Raise [Not_found] if [c] does not occur in [s] before position [i+1]."
      ]
    },
    {
      "id": "Bytes.rindex_from_opt",
      "kind": "value",
      "name": "rindex_from_opt",
      "signature": "let rindex_from_opt: (bytes, int, char) => option<int>",
      "docstrings": [
        "[rindex_from_opt s i c] returns the index of the last occurrence\n    of byte [c] in [s] before position [i+1] or [None] if [c] does not\n    occur in [s] before position [i+1].  [rindex_opt s c] is equivalent to\n    [rindex_from s (Bytes.length s - 1) c].\n\n    Raise [Invalid_argument] if [i+1] is not a valid position in [s].\n    @since 4.05"
      ]
    },
    {
      "id": "Bytes.contains",
      "kind": "value",
      "name": "contains",
      "signature": "let contains: (bytes, char) => bool",
      "docstrings": [
        "[contains s c] tests if byte [c] appears in [s]."
      ]
    },
    {
      "id": "Bytes.contains_from",
      "kind": "value",
      "name": "contains_from",
      "signature": "let contains_from: (bytes, int, char) => bool",
      "docstrings": [
        "[contains_from s start c] tests if byte [c] appears in [s] after\n    position [start].  [contains s c] is equivalent to [contains_from\n    s 0 c].\n\n    Raise [Invalid_argument] if [start] is not a valid position in [s]."
      ]
    },
    {
      "id": "Bytes.rcontains_from",
      "kind": "value",
      "name": "rcontains_from",
      "signature": "let rcontains_from: (bytes, int, char) => bool",
      "docstrings": [
        "[rcontains_from s stop c] tests if byte [c] appears in [s] before\n    position [stop+1].\n\n    Raise [Invalid_argument] if [stop < 0] or [stop+1] is not a valid\n    position in [s]."
      ]
    },
    {
      "id": "Bytes.uppercase_ascii",
      "kind": "value",
      "name": "uppercase_ascii",
      "signature": "let uppercase_ascii: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with all lowercase letters\n   translated to uppercase, using the US-ASCII character set.\n   @since 4.03.0"
      ]
    },
    {
      "id": "Bytes.lowercase_ascii",
      "kind": "value",
      "name": "lowercase_ascii",
      "signature": "let lowercase_ascii: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with all uppercase letters\n   translated to lowercase, using the US-ASCII character set.\n   @since 4.03.0"
      ]
    },
    {
      "id": "Bytes.capitalize_ascii",
      "kind": "value",
      "name": "capitalize_ascii",
      "signature": "let capitalize_ascii: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with the first character set to uppercase,\n   using the US-ASCII character set.\n   @since 4.03.0"
      ]
    },
    {
      "id": "Bytes.uncapitalize_ascii",
      "kind": "value",
      "name": "uncapitalize_ascii",
      "signature": "let uncapitalize_ascii: bytes => bytes",
      "docstrings": [
        "Return a copy of the argument, with the first character set to lowercase,\n   using the US-ASCII character set.\n   @since 4.03.0"
      ]
    },
    {
      "id": "Bytes.t",
      "kind": "type",
      "name": "t",
      "signature": "type t = bytes",
      "docstrings": [
        "An alias for the type of byte sequences."
      ]
    },
    {
      "id": "Bytes.compare",
      "kind": "value",
      "name": "compare",
      "signature": "let compare: (t, t) => int",
      "docstrings": [
        "The comparison function for byte sequences, with the same\n    specification as {!Pervasives.compare}.  Along with the type [t],\n    this function [compare] allows the module [Bytes] to be passed as\n    argument to the functors {!Set.Make} and {!Map.Make}."
      ]
    },
    {
      "id": "Bytes.equal",
      "kind": "value",
      "name": "equal",
      "signature": "let equal: (t, t) => bool",
      "docstrings": [
        "The equality function for byte sequences.\n    @since 4.03.0"
      ]
    },
    {
      "id": "Bytes.unsafe_to_string",
      "kind": "value",
      "name": "unsafe_to_string",
      "signature": "let unsafe_to_string: bytes => string",
      "docstrings": [
        "Unsafely convert a byte sequence into a string.\n\n    To reason about the use of [unsafe_to_string], it is convenient to\n    consider an \"ownership\" discipline. A piece of code that\n    manipulates some data \"owns\" it; there are several disjoint ownership\n    modes, including:\n    - Unique ownership: the data may be accessed and mutated\n    - Shared ownership: the data has several owners, that may only\n      access it, not mutate it.\n\n    Unique ownership is linear: passing the data to another piece of\n    code means giving up ownership (we cannot write the\n    data again). A unique owner may decide to make the data shared\n    (giving up mutation rights on it), but shared data may not become\n    uniquely-owned again.\n\n   [unsafe_to_string s] can only be used when the caller owns the byte\n   sequence [s] -- either uniquely or as shared immutable data. The\n   caller gives up ownership of [s], and gains ownership of the\n   returned string.\n\n   There are two valid use-cases that respect this ownership\n   discipline:\n\n   1. Creating a string by initializing and mutating a byte sequence\n   that is never changed after initialization is performed.\n\n   {[\nlet string_init len f : string =\n  let s = Bytes.create len in\n  for i = 0 to len - 1 do Bytes.set s i (f i) done;\n  Bytes.unsafe_to_string s\n   ]}\n\n   This function is safe because the byte sequence [s] will never be\n   accessed or mutated after [unsafe_to_string] is called. The\n   [string_init] code gives up ownership of [s], and returns the\n   ownership of the resulting string to its caller.\n\n   Note that it would be unsafe if [s] was passed as an additional\n   parameter to the function [f] as it could escape this way and be\n   mutated in the future -- [string_init] would give up ownership of\n   [s] to pass it to [f], and could not call [unsafe_to_string]\n   safely.\n\n   We have provided the {!String.init}, {!String.map} and\n   {!String.mapi} functions to cover most cases of building\n   new strings. You should prefer those over [to_string] or\n   [unsafe_to_string] whenever applicable.\n\n   2. Temporarily giving ownership of a byte sequence to a function\n   that expects a uniquely owned string and returns ownership back, so\n   that we can mutate the sequence again after the call ended.\n\n   {[\nlet bytes_length (s : bytes) =\n  String.length (Bytes.unsafe_to_string s)\n   ]}\n\n   In this use-case, we do not promise that [s] will never be mutated\n   after the call to [bytes_length s]. The {!String.length} function\n   temporarily borrows unique ownership of the byte sequence\n   (and sees it as a [string]), but returns this ownership back to\n   the caller, which may assume that [s] is still a valid byte\n   sequence after the call. Note that this is only correct because we\n   know that {!String.length} does not capture its argument -- it could\n   escape by a side-channel such as a memoization combinator.\n\n   The caller may not mutate [s] while the string is borrowed (it has\n   temporarily given up ownership). This affects concurrent programs,\n   but also higher-order functions: if {!String.length} returned\n   a closure to be called later, [s] should not be mutated until this\n   closure is fully applied and returns ownership."
      ]
    },
    {
      "id": "Bytes.unsafe_of_string",
      "kind": "value",
      "name": "unsafe_of_string",
      "signature": "let unsafe_of_string: string => bytes",
      "docstrings": [
        "Unsafely convert a shared string to a byte sequence that should\n    not be mutated.\n\n    The same ownership discipline that makes [unsafe_to_string]\n    correct applies to [unsafe_of_string]: you may use it if you were\n    the owner of the [string] value, and you will own the return\n    [bytes] in the same mode.\n\n    In practice, unique ownership of string values is extremely\n    difficult to reason about correctly. You should always assume\n    strings are shared, never uniquely owned.\n\n    For example, string literals are implicitly shared by the\n    compiler, so you never uniquely own them.\n\n    {[\nlet incorrect = Bytes.unsafe_of_string \"hello\"\nlet s = Bytes.of_string \"hello\"\n    ]}\n\n    The first declaration is incorrect, because the string literal\n    [\"hello\"] could be shared by the compiler with other parts of the\n    program, and mutating [incorrect] is a bug. You must always use\n    the second version, which performs a copy and is thus correct.\n\n    Assuming unique ownership of strings that are not string\n    literals, but are (partly) built from string literals, is also\n    incorrect. For example, mutating [unsafe_of_string (\"foo\" ^ s)]\n    could mutate the shared string [\"foo\"] -- assuming a rope-like\n    representation of strings. More generally, functions operating on\n    strings will assume shared ownership, they do not preserve unique\n    ownership. It is thus incorrect to assume unique ownership of the\n    result of [unsafe_of_string].\n\n    The only case we have reasonable confidence is safe is if the\n    produced [bytes] is shared -- used as an immutable byte\n    sequence. This is possibly useful for incremental migration of\n    low-level programs that manipulate immutable sequences of bytes\n    (for example {!Marshal.from_bytes}) and previously used the\n    [string] type for this purpose."
      ]
    },
    {
      "id": "Bytes.unsafe_get",
      "kind": "value",
      "name": "unsafe_get",
      "signature": "let unsafe_get: (bytes, int) => char",
      "docstrings": []
    },
    {
      "id": "Bytes.unsafe_set",
      "kind": "value",
      "name": "unsafe_set",
      "signature": "let unsafe_set: (bytes, int, char) => unit",
      "docstrings": []
    }
  ]
}