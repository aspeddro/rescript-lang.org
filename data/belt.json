{
  "belt": {
    "id": "Belt",
    "name": "Belt",
    "docstrings": [
      "The ReScript standard library.\n\nBelt is currently mostly covering collection types. It has no string or date functions yet, although Belt.String is in the works. In the meantime, use [Js.String](js/string) for string functions and [Js.Date](js/date) for date functions.\n\n## Motivation\n\nBelt provides:\n\n- The **highest quality** immutable data structures in JavaScript.\n- Safety by default: A Belt function will never throw exceptions, unless it is\n  indicated explicitly in the function name (suffix \"Exn\").\n- Better performance and smaller code size running on the JS platform.\n- Ready for [Tree Shaking](https://webpack.js.org/guides/tree-shaking/).\n\n## Usage\n\nTo use modules from Belt, either refer to them by their fully qualified name (`Belt.List`, `Belt.Array` etc.) or open the `Belt` module by putting\n\n```rescript\nopen Belt\n```\n\nat the top of your source files. After opening Belt this way, `Array` will refer to `Belt.Array`, `List` will refer to `Belt.List` etc. in the subsequent code.\n\nIf you want to open Belt globally for all files in your project instead, you can put\n\n```json\n\"bsc-flags\": [\"-open Belt\"]\n```\n\ninto your `bsconfig.json`.\n\n**Note**: this is the **only** `open` we encourage.\n\nExample usage:\n\n```rescript\nlet someNumbers = [1, 1, 4, 2, 3, 6, 3, 4, 2]\n\nlet greaterThan2UniqueAndSorted =\n  someNumbers\n  ->Belt.Array.keep(x => x > 2)\n  // convert to and from set to make values unique\n  ->Belt.Set.Int.fromArray\n  ->Belt.Set.Int.toArray // output is already sorted\n\nJs.log2(\"result\", greaterThan2UniqueAndSorted)\n```\n\n## Curried vs. Uncurried Callbacks\n\nFor functions taking a callback parameter, there are usually two versions\navailable:\n\n- curried (no suffix)\n- uncurried (suffixed with `U`)\n\nE.g.:\n\n```rescript\nlet forEach: (t<'a>, 'a => unit) => unit\n\nlet forEachU: (t<'a>, (. 'a) => unit) => unit\n```\n\nThe uncurried version will be faster in some cases, but for simplicity we recommend to stick with the curried version unless you need the extra performance.\n\nThe two versions can be invoked as follows:\n\n```rescript\n[\"a\", \"b\", \"c\"]->Belt.Array.forEach(x => Js.log(x))\n\n[\"a\", \"b\", \"c\"]->Belt.Array.forEachU((. x) => Js.log(x))\n```\n\n## Specialized Collections\n\nFor collections types like set or map, Belt provides both a generic module as well as specialized, more efficient implementations for string and int keys.\n\nFor example, Belt has the following set modules:\n\n- [Belt.Set](belt/set)\n- [Belt.Set.Int](belt/set-int)\n- [Belt.Set.String](belt/set-string)\n\n## Implementation Details\n\n### Array access runtime safety\n\nOne common confusion comes from the way Belt handles array access. It differs from than the default standard library's.\n\n```rescript\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0] // a == \"a\"\nlet capitalA = Js.String.toUpperCase(a)\nlet k = letters[10] // Raises an exception! The 10th index doesn't exist.\n```\n\nBecause Belt avoids exceptions and returns `options` instead, this code behaves differently:\n\n```rescript\nopen Belt\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0] // a == Some(\"a\")\nlet captialA = Js.String.toUpperCase(a) // Type error! This code will not compile.\nlet k = letters[10] // k == None\n```\n\nAlthough we've fixed the problem where `k` raises an exception, we now have a type error when trying to capitalize `a`. There are a few things going on here:\n\n- Reason transforms array index access to the function `Array.get`. So `letters[0]` is the same as `Array.get(letters, 0)`.\n- The compiler uses whichever `Array` module is in scope. If you `open Belt`, then it uses `Belt.Array`.\n- `Belt.Array.get` returns values wrapped in options, so `letters[0] == Some(\"a\")`.\n\nFortunately, this is easy to fix:\n\n```rescript\nopen Belt\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0]\n\n// Use a switch statement:\nlet capitalA =\n  switch a {\n  | Some(a) => Some(Js.String.toUpperCase(a))\n  | None => None\n  }\n\nlet k = letters[10] // k == None\n```\n\nWith that little bit of tweaking, our code now compiles successfully and is 100% free of runtime errors!\n\n### A Special Encoding for Collection Safety\n\nWhen we create a collection library for a custom data type we need a way to provide a comparator function. Take Set for example, suppose its element type is a pair of ints, it needs a custom compare function that takes two tuples and returns their order. The Set could not just be typed as Set.t (int \\* int) , its customized compare function needs to manifest itself in the signature, otherwise, if the user creates another customized compare function, the two collection could mix which would result in runtime error.\n\nWe use a phantom type to solve the problem:\n\n```rescript\nmodule Comparable1 =\n  Belt.Id.MakeComparable(\n    {\n      type t = (int, int)\n      let cmp = ((a0, a1), (b0, b1)) =>\n        switch Pervasives.compare(a0, b0) {\n        | 0 => Pervasives.compare(a1, b1)\n        | c => c\n        }\n    }\n  )\n\nlet mySet1 = Belt.Set.make(~id=module(Comparable1))\n\nmodule Comparable2 =\n  Belt.Id.MakeComparable(\n    {\n      type t = (int, int)\n      let cmp = ((a0, a1), (b0, b1)) =>\n        switch Pervasives.compare(a0, b0) {\n        | 0 => Pervasives.compare(a1, b1)\n        | c => c\n        }\n    }\n  )\n\nlet mySet2 = Belt.Set.make(~id=module(Comparable2))\n```\n\nHere, the compiler would infer `mySet1` and `mySet2` having different type, so e.g. a `merge` operation that tries to merge these two sets will correctly fail.\n\n```rescript\nlet mySet1: t<(int, int), Comparable1.identity>\nlet mySet2: t<(int, int), Comparable2.identity>\n```\n\n`Comparable1.identity` and `Comparable2.identity` are not the same using our encoding scheme."
    ],
    "items": []
  },
  "belt/hashmap/string": {
    "id": "Belt.HashMap.String",
    "name": "String",
    "docstrings": [
      "Specalized when key type is `string`, more efficient\n    than the generic type"
    ],
    "items": [
      {
        "id": "Belt.HashMap.String.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = string"
      },
      {
        "id": "Belt.HashMap.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'b>"
      },
      {
        "id": "Belt.HashMap.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int) => t<'b>"
      },
      {
        "id": "Belt.HashMap.String.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'b> => unit"
      },
      {
        "id": "Belt.HashMap.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.HashMap.String.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`setDone tbl k v` if `k` does not exist,\n  add the binding `k,v`, otherwise, update the old value with the new\n  `v`"
        ],
        "signature": "let set: (t<'a>, key, 'a) => unit"
      },
      {
        "id": "Belt.HashMap.String.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.HashMap.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, key) => option<'a>"
      },
      {
        "id": "Belt.HashMap.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'b>, key) => bool"
      },
      {
        "id": "Belt.HashMap.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t<'a>, key) => unit"
      },
      {
        "id": "Belt.HashMap.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'b>, (. key, 'b) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t<'b>, (key, 'b) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'b>, 'c, (. 'c, key, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t<'b>, 'c, ('c, key, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.String.keepMapInPlaceU",
        "kind": "value",
        "name": "keepMapInPlaceU",
        "docstrings": [],
        "signature": "let keepMapInPlaceU: (t<'a>, (. key, 'a) => option<'a>) => unit"
      },
      {
        "id": "Belt.HashMap.String.keepMapInPlace",
        "kind": "value",
        "name": "keepMapInPlace",
        "docstrings": [],
        "signature": "let keepMapInPlace: (t<'a>, (key, 'a) => option<'a>) => unit"
      },
      {
        "id": "Belt.HashMap.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.HashMap.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'a> => array<(key, 'a)>"
      },
      {
        "id": "Belt.HashMap.String.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'a> => array<key>"
      },
      {
        "id": "Belt.HashMap.String.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.HashMap.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'a)> => t<'a>"
      },
      {
        "id": "Belt.HashMap.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'a>, array<(key, 'a)>) => unit"
      },
      {
        "id": "Belt.HashMap.String.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t<'a> => array<int>"
      },
      {
        "id": "Belt.HashMap.String.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t<'a> => unit"
      }
    ]
  },
  "belt/hashmap/int": {
    "id": "Belt.HashMap.Int",
    "name": "Int",
    "docstrings": [
      "Specalized when key type is `int`, more efficient\n    than the generic type"
    ],
    "items": [
      {
        "id": "Belt.HashMap.Int.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = int"
      },
      {
        "id": "Belt.HashMap.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'b>"
      },
      {
        "id": "Belt.HashMap.Int.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int) => t<'b>"
      },
      {
        "id": "Belt.HashMap.Int.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'b> => unit"
      },
      {
        "id": "Belt.HashMap.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.HashMap.Int.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`setDone tbl k v` if `k` does not exist,\n  add the binding `k,v`, otherwise, update the old value with the new\n  `v`"
        ],
        "signature": "let set: (t<'a>, key, 'a) => unit"
      },
      {
        "id": "Belt.HashMap.Int.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.HashMap.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, key) => option<'a>"
      },
      {
        "id": "Belt.HashMap.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'b>, key) => bool"
      },
      {
        "id": "Belt.HashMap.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t<'a>, key) => unit"
      },
      {
        "id": "Belt.HashMap.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'b>, (. key, 'b) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t<'b>, (key, 'b) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'b>, 'c, (. 'c, key, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t<'b>, 'c, ('c, key, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.Int.keepMapInPlaceU",
        "kind": "value",
        "name": "keepMapInPlaceU",
        "docstrings": [],
        "signature": "let keepMapInPlaceU: (t<'a>, (. key, 'a) => option<'a>) => unit"
      },
      {
        "id": "Belt.HashMap.Int.keepMapInPlace",
        "kind": "value",
        "name": "keepMapInPlace",
        "docstrings": [],
        "signature": "let keepMapInPlace: (t<'a>, (key, 'a) => option<'a>) => unit"
      },
      {
        "id": "Belt.HashMap.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.HashMap.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'a> => array<(key, 'a)>"
      },
      {
        "id": "Belt.HashMap.Int.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'a> => array<key>"
      },
      {
        "id": "Belt.HashMap.Int.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.HashMap.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'a)> => t<'a>"
      },
      {
        "id": "Belt.HashMap.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'a>, array<(key, 'a)>) => unit"
      },
      {
        "id": "Belt.HashMap.Int.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t<'a> => array<int>"
      },
      {
        "id": "Belt.HashMap.Int.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t<'a> => unit"
      }
    ]
  },
  "belt/hashset/string": {
    "id": "Belt.HashSet.String",
    "name": "String",
    "docstrings": [
      "Specalized when key type is `string`, more efficient\n    than the generic type"
    ],
    "items": [
      {
        "id": "Belt.HashSet.String.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = string"
      },
      {
        "id": "Belt.HashSet.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Belt.HashSet.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int) => t"
      },
      {
        "id": "Belt.HashSet.String.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t => unit"
      },
      {
        "id": "Belt.HashSet.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.HashSet.String.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t, key) => unit"
      },
      {
        "id": "Belt.HashSet.String.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t => t"
      },
      {
        "id": "Belt.HashSet.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, key) => bool"
      },
      {
        "id": "Belt.HashSet.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t, key) => unit"
      },
      {
        "id": "Belt.HashSet.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, (. key) => unit) => unit"
      },
      {
        "id": "Belt.HashSet.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t, key => unit) => unit"
      },
      {
        "id": "Belt.HashSet.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'c, (. 'c, key) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t, 'c, ('c, key) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.HashSet.String.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t => unit"
      },
      {
        "id": "Belt.HashSet.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t => array<key>"
      },
      {
        "id": "Belt.HashSet.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<key> => t"
      },
      {
        "id": "Belt.HashSet.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<key>) => unit"
      },
      {
        "id": "Belt.HashSet.String.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t => array<int>"
      }
    ]
  },
  "belt/hashset/int": {
    "id": "Belt.HashSet.Int",
    "name": "Int",
    "docstrings": [
      "Specalized when key type is `int`, more efficient\n    than the generic type"
    ],
    "items": [
      {
        "id": "Belt.HashSet.Int.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = int"
      },
      {
        "id": "Belt.HashSet.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t"
      },
      {
        "id": "Belt.HashSet.Int.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int) => t"
      },
      {
        "id": "Belt.HashSet.Int.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t => unit"
      },
      {
        "id": "Belt.HashSet.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.HashSet.Int.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t, key) => unit"
      },
      {
        "id": "Belt.HashSet.Int.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t => t"
      },
      {
        "id": "Belt.HashSet.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, key) => bool"
      },
      {
        "id": "Belt.HashSet.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t, key) => unit"
      },
      {
        "id": "Belt.HashSet.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, (. key) => unit) => unit"
      },
      {
        "id": "Belt.HashSet.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t, key => unit) => unit"
      },
      {
        "id": "Belt.HashSet.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'c, (. 'c, key) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [],
        "signature": "let reduce: (t, 'c, ('c, key) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.HashSet.Int.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t => unit"
      },
      {
        "id": "Belt.HashSet.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t => array<key>"
      },
      {
        "id": "Belt.HashSet.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<key> => t"
      },
      {
        "id": "Belt.HashSet.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<key>) => unit"
      },
      {
        "id": "Belt.HashSet.Int.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t => array<int>"
      }
    ]
  },
  "belt/mutablemap/string": {
    "id": "Belt.MutableMap.String",
    "name": "String",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.MutableMap.String.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = string"
      },
      {
        "id": "Belt.MutableMap.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a>"
      },
      {
        "id": "Belt.MutableMap.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Belt.MutableMap.String.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Belt.MutableMap.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.MutableMap.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'a>, key) => bool"
      },
      {
        "id": "Belt.MutableMap.String.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.String.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp m1 m2 cmp`\n  First compare by size, if size is the same,\n  compare by key, value pair"
        ],
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.String.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq m1 m2 cmp`"
        ],
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, (. key, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument.\n  The application order of `f`  is in increasing order."
        ],
        "signature": "let forEach: (t<'a>, (key, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'a>, 'b, (. 'b, key, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.String.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'a>, (. key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every m p` checks if all the bindings of the map\n  satisfy the predicate `p`.\n  The application order of `p` is unspecified."
        ],
        "signature": "let every: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'a>, (. key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some m p` checks if at least one binding of the map\n  satisfy the predicate `p`.\n  The application order of `p` is unspecified."
        ],
        "signature": "let some: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.MutableMap.String.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toList: t<'a> => list<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toArray: t<'a> => array<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'a)> => t<'a>"
      },
      {
        "id": "Belt.MutableMap.String.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'a> => array<key>"
      },
      {
        "id": "Belt.MutableMap.String.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.MutableMap.String.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.MutableMap.String.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.MutableMap.String.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.MutableMap.String.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.MutableMap.String.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'a> => option<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'a> => Js.undefined<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'a> => option<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'a> => Js.undefined<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, key) => option<'a>"
      },
      {
        "id": "Belt.MutableMap.String.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'a>, key) => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableMap.String.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'a>, key, 'a) => 'a"
      },
      {
        "id": "Belt.MutableMap.String.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'a>, key) => 'a"
      },
      {
        "id": "Belt.MutableMap.String.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a> => unit"
      },
      {
        "id": "Belt.MutableMap.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove m x` do the in-place modification"
        ],
        "signature": "let remove: (t<'a>, key) => unit"
      },
      {
        "id": "Belt.MutableMap.String.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'a>, array<key>) => unit"
      },
      {
        "id": "Belt.MutableMap.String.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set m x y` do the in-place modification, return\n  `m` for chaining. If `x` was already bound\n  in `m`, its previous binding disappears."
        ],
        "signature": "let set: (t<'a>, key, 'a) => unit"
      },
      {
        "id": "Belt.MutableMap.String.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'a>, key, (. option<'a>) => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.String.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'a>, key, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.String.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a>, (. 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.String.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.String.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'a>, (. key, 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.String.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'a>, (key, 'a) => 'b) => t<'b>"
      }
    ]
  },
  "belt/mutablemap/int": {
    "id": "Belt.MutableMap.Int",
    "name": "Int",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.MutableMap.Int.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = int"
      },
      {
        "id": "Belt.MutableMap.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Belt.MutableMap.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.MutableMap.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'a>, key) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.Int.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp m1 m2 cmp`\n  First compare by size, if size is the same,\n  compare by key, value pair"
        ],
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.Int.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq m1 m2 cmp`"
        ],
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, (. key, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument.\n  The application order of `f`  is in increasing order."
        ],
        "signature": "let forEach: (t<'a>, (key, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'a>, 'b, (. 'b, key, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.Int.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'a>, (. key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every m p` checks if all the bindings of the map\n  satisfy the predicate `p`.\n  The application order of `p` is unspecified."
        ],
        "signature": "let every: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'a>, (. key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some m p` checks if at least one binding of the map\n  satisfy the predicate `p`.\n  The application order of `p` is unspecified."
        ],
        "signature": "let some: (t<'a>, (key, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.MutableMap.Int.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toList: t<'a> => list<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toArray: t<'a> => array<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'a)> => t<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'a> => array<key>"
      },
      {
        "id": "Belt.MutableMap.Int.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.MutableMap.Int.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.MutableMap.Int.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.MutableMap.Int.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.MutableMap.Int.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'a> => option<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'a> => Js.undefined<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'a> => option<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'a> => Js.undefined<(key, 'a)>"
      },
      {
        "id": "Belt.MutableMap.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'a>, key) => option<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'a>, key) => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableMap.Int.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'a>, key, 'a) => 'a"
      },
      {
        "id": "Belt.MutableMap.Int.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'a>, key) => 'a"
      },
      {
        "id": "Belt.MutableMap.Int.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a> => unit"
      },
      {
        "id": "Belt.MutableMap.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove m x` do the in-place modification"
        ],
        "signature": "let remove: (t<'a>, key) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'a>, array<key>) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set m x y` do the in-place modification, return\n  `m` for chaining. If `x` was already bound\n  in `m`, its previous binding disappears."
        ],
        "signature": "let set: (t<'a>, key, 'a) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'a>, key, (. option<'a>) => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'a>, key, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.Int.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a>, (. 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.Int.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.Int.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'a>, (. key, 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableMap.Int.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'a>, (key, 'a) => 'b) => t<'b>"
      }
    ]
  },
  "belt/mutableset/string": {
    "id": "Belt.MutableSet.String",
    "name": "String",
    "docstrings": [
      "Specialized when key type is `string`, more efficient\n    than the generic type"
    ],
    "items": [
      {
        "id": "Belt.MutableSet.String.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The type of the set elements."
        ],
        "signature": "type value = string"
      },
      {
        "id": "Belt.MutableSet.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of sets."
        ],
        "signature": "type t"
      },
      {
        "id": "Belt.MutableSet.String.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t"
      },
      {
        "id": "Belt.MutableSet.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<value> => t"
      },
      {
        "id": "Belt.MutableSet.String.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [],
        "signature": "let fromSortedArrayUnsafe: array<value> => t"
      },
      {
        "id": "Belt.MutableSet.String.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t => t"
      },
      {
        "id": "Belt.MutableSet.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.MutableSet.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.String.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t, value) => unit"
      },
      {
        "id": "Belt.MutableSet.String.addCheck",
        "kind": "value",
        "name": "addCheck",
        "docstrings": [],
        "signature": "let addCheck: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<value>) => unit"
      },
      {
        "id": "Belt.MutableSet.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t, value) => unit"
      },
      {
        "id": "Belt.MutableSet.String.removeCheck",
        "kind": "value",
        "name": "removeCheck",
        "docstrings": [],
        "signature": "let removeCheck: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.String.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t, array<value>) => unit"
      },
      {
        "id": "Belt.MutableSet.String.union",
        "kind": "value",
        "name": "union",
        "docstrings": [],
        "signature": "let union: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.String.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.String.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.String.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [],
        "signature": "let subset: (t, t) => bool"
      },
      {
        "id": "Belt.MutableSet.String.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t, t) => int"
      },
      {
        "id": "Belt.MutableSet.String.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [],
        "signature": "let eq: (t, t) => bool"
      },
      {
        "id": "Belt.MutableSet.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, (. value) => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let forEach: (t, value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Iterate in increasing order."
        ],
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.String.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t, (. value) => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.String.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every p s` checks if all elements of the set\n  satisfy the predicate `p`. Order unspecified."
        ],
        "signature": "let every: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.String.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t, (. value) => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.String.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some p s` checks if at least one element of\n  the set satisfies the predicate `p`. Oder unspecified."
        ],
        "signature": "let some: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.String.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t, (. value) => bool) => t"
      },
      {
        "id": "Belt.MutableSet.String.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep s p` returns a fresh copy of the set of all elements in `s`\n  that satisfy predicate `p`."
        ],
        "signature": "let keep: (t, value => bool) => t"
      },
      {
        "id": "Belt.MutableSet.String.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t, (. value) => bool) => (t, t)"
      },
      {
        "id": "Belt.MutableSet.String.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition s p` returns a fresh copy pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.MutableSet.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.MutableSet.String.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order with respect"
        ],
        "signature": "let toList: t => list<value>"
      },
      {
        "id": "Belt.MutableSet.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "In increasing order with respect"
        ],
        "signature": "let toArray: t => array<value>"
      },
      {
        "id": "Belt.MutableSet.String.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t => option<value>"
      },
      {
        "id": "Belt.MutableSet.String.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.String.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t => option<value>"
      },
      {
        "id": "Belt.MutableSet.String.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t, value) => option<value>"
      },
      {
        "id": "Belt.MutableSet.String.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t, value) => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.String.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t, value) => value"
      },
      {
        "id": "Belt.MutableSet.String.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split s key` return a fresh copy of each"
        ],
        "signature": "let split: (t, value) => ((t, t), bool)"
      },
      {
        "id": "Belt.MutableSet.String.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t => unit"
      }
    ]
  },
  "belt/mutableset/int": {
    "id": "Belt.MutableSet.Int",
    "name": "Int",
    "docstrings": [
      "Specialized when key type is `int`, more efficient\n    than the generic type"
    ],
    "items": [
      {
        "id": "Belt.MutableSet.Int.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The type of the set elements."
        ],
        "signature": "type value = int"
      },
      {
        "id": "Belt.MutableSet.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of sets."
        ],
        "signature": "type t"
      },
      {
        "id": "Belt.MutableSet.Int.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: unit => t"
      },
      {
        "id": "Belt.MutableSet.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<value> => t"
      },
      {
        "id": "Belt.MutableSet.Int.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [],
        "signature": "let fromSortedArrayUnsafe: array<value> => t"
      },
      {
        "id": "Belt.MutableSet.Int.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t => t"
      },
      {
        "id": "Belt.MutableSet.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.MutableSet.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t, value) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.addCheck",
        "kind": "value",
        "name": "addCheck",
        "docstrings": [],
        "signature": "let addCheck: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<value>) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t, value) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.removeCheck",
        "kind": "value",
        "name": "removeCheck",
        "docstrings": [],
        "signature": "let removeCheck: (t, value) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t, array<value>) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.union",
        "kind": "value",
        "name": "union",
        "docstrings": [],
        "signature": "let union: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.Int.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.Int.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (t, t) => t"
      },
      {
        "id": "Belt.MutableSet.Int.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [],
        "signature": "let subset: (t, t) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t, t) => int"
      },
      {
        "id": "Belt.MutableSet.Int.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [],
        "signature": "let eq: (t, t) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, (. value) => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let forEach: (t, value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Iterate in increasing order."
        ],
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.Int.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t, (. value) => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every p s` checks if all elements of the set\n  satisfy the predicate `p`. Order unspecified."
        ],
        "signature": "let every: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t, (. value) => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some p s` checks if at least one element of\n  the set satisfies the predicate `p`. Oder unspecified."
        ],
        "signature": "let some: (t, value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.Int.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t, (. value) => bool) => t"
      },
      {
        "id": "Belt.MutableSet.Int.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep s p` returns a fresh copy of the set of all elements in `s`\n  that satisfy predicate `p`."
        ],
        "signature": "let keep: (t, value => bool) => t"
      },
      {
        "id": "Belt.MutableSet.Int.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t, (. value) => bool) => (t, t)"
      },
      {
        "id": "Belt.MutableSet.Int.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition s p` returns a fresh copy pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.MutableSet.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.MutableSet.Int.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order with respect"
        ],
        "signature": "let toList: t => list<value>"
      },
      {
        "id": "Belt.MutableSet.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "In increasing order with respect"
        ],
        "signature": "let toArray: t => array<value>"
      },
      {
        "id": "Belt.MutableSet.Int.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t => option<value>"
      },
      {
        "id": "Belt.MutableSet.Int.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.Int.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t => option<value>"
      },
      {
        "id": "Belt.MutableSet.Int.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t, value) => option<value>"
      },
      {
        "id": "Belt.MutableSet.Int.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t, value) => Js.undefined<value>"
      },
      {
        "id": "Belt.MutableSet.Int.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t, value) => value"
      },
      {
        "id": "Belt.MutableSet.Int.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split s key` return a fresh copy of each"
        ],
        "signature": "let split: (t, value) => ((t, t), bool)"
      },
      {
        "id": "Belt.MutableSet.Int.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t => unit"
      }
    ]
  },
  "belt/map/dict": {
    "id": "Belt.Map.Dict",
    "name": "Dict",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Map.Dict.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.Map.Dict.cmp",
        "kind": "type",
        "name": "cmp",
        "docstrings": [],
        "signature": "type cmp<'key, 'id> = Belt_Id.cmp<'key, 'id>"
      },
      {
        "id": "Belt.Map.Dict.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.Dict.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'k, 'v, 'id> => bool"
      },
      {
        "id": "Belt.Map.Dict.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => bool"
      },
      {
        "id": "Belt.Map.Dict.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ~kcmp: cmp<'k, 'id>, ~vcmp: (. 'v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.Dict.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ~kcmp: cmp<'k, 'id>, ~vcmp: ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.Dict.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ~kcmp: cmp<'k, 'id>, ~veq: (. 'a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2, cmp)` tests whether the maps `m1` and `m2` are equal, that is,\n    contain equal keys and associate them with equal data. `cmp` is the\n    equality predicate used to compare the data associated with the keys."
        ],
        "signature": "let eq: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ~kcmp: cmp<'k, 'id>, ~veq: ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "docstrings": [],
        "signature": "let findFirstByU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.Dict.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "docstrings": [
          "`findFirstBy(m, p)` uses function `f` to find the first key value pair to\n    match predicate `p`.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = Pervasives.compare\n    })\n\n    let s0 = Belt.Map.Dict.fromArray([(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"3\")], ~cmp=IntCmp.cmp)\n\n    Belt.Map.Dict.findFirstBy(s0, (k, _) => k == 4) == Some((4, \"4\"))\n    ```"
        ],
        "signature": "let findFirstBy: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.Dict.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'k, 'a, 'id>, (. 'k, 'a) => unit) => unit"
      },
      {
        "id": "Belt.Map.Dict.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the\n    key as first argument, and the associated value as second argument. The\n    bindings are passed to `f` in increasing order with respect to the ordering\n    over the type of the keys."
        ],
        "signature": "let forEach: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit"
      },
      {
        "id": "Belt.Map.Dict.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'k, 'a, 'id>, 'b, (. 'b, 'k, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.Map.Dict.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f)` computes `f(kN, dN ... f(k1, d1, a)...)`, where `k1 ...\n    kN` are the keys of all bindings in `m` (in increasing order), and `d1 ...\n    dN` are the associated data."
        ],
        "signature": "let reduce: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.Map.Dict.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate\n    `p`. Order unspecified"
        ],
        "signature": "let every: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the\n    predicate `p`. Order unspecified"
        ],
        "signature": "let some: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Map.Dict.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'k, 'a, 'id> => int"
      },
      {
        "id": "Belt.Map.Dict.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order."
        ],
        "signature": "let toList: t<'k, 'a, 'id> => list<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'k, 'a, 'id> => array<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: (array<('k, 'a)>, ~cmp: cmp<'k, 'id>) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.Map.Dict.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'k, 'a, 'id> => array<'k>"
      },
      {
        "id": "Belt.Map.Dict.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'k, 'a, 'id> => array<'a>"
      },
      {
        "id": "Belt.Map.Dict.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.Map.Dict.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.Map.Dict.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.Map.Dict.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.Map.Dict.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'k, 'a, 'b> => option<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'k, 'a, 'b> => option<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>"
      },
      {
        "id": "Belt.Map.Dict.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => option<'a>"
      },
      {
        "id": "Belt.Map.Dict.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => Js.undefined<'a>"
      },
      {
        "id": "Belt.Map.Dict.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'k, 'a, 'id>, 'k, 'a, ~cmp: cmp<'k, 'id>) => 'a"
      },
      {
        "id": "Belt.Map.Dict.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => 'a"
      },
      {
        "id": "Belt.Map.Dict.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [],
        "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit"
      },
      {
        "id": "Belt.Map.Dict.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` returns a map containing the same bindings as `m`, except\n    for `x` which is unbound in the returned map."
        ],
        "signature": "let remove: (t<'a, 'b, 'id>, 'a, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'a, 'b, 'id>, array<'a>, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` returns a map containing the same bindings as `m`, plus a\n    binding of `x` to `y`. If `x` was already bound in `m`, its previous\n    binding disappears."
        ],
        "signature": "let set: (t<'a, 'b, 'id>, 'a, 'b, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (\\n  t<'a, 'b, 'id>,\\n  'a,\\n  (. option<'b>) => option<'b>,\\n  ~cmp: cmp<'a, 'id>,\\n) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'a, 'b, 'id>, 'a, option<'b> => option<'b>, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.mergeU",
        "kind": "value",
        "name": "mergeU",
        "docstrings": [],
        "signature": "let mergeU: (\\n  t<'a, 'b, 'id>,\\n  t<'a, 'c, 'id>,\\n  (. 'a, option<'b>, option<'c>) => option<'d>,\\n  ~cmp: cmp<'a, 'id>,\\n) => t<'a, 'd, 'id>"
      },
      {
        "id": "Belt.Map.Dict.merge",
        "kind": "value",
        "name": "merge",
        "docstrings": [
          "`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\n    and of `m2`. The presence of each such binding, and the corresponding\n    value, is determined with the function `f`."
        ],
        "signature": "let merge: (\\n  t<'a, 'b, 'id>,\\n  t<'a, 'c, 'id>,\\n  ('a, option<'b>, option<'c>) => option<'d>,\\n  ~cmp: cmp<'a, 'id>,\\n) => t<'a, 'd, 'id>"
      },
      {
        "id": "Belt.Map.Dict.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'a, 'b, 'id>, array<('a, 'b)>, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.Map.Dict.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(m, p)` returns the map with all the bindings in `m` that satisfy\n    predicate `p`."
        ],
        "signature": "let keep: (t<'k, 'a, 'id>, ('k, 'a) => bool) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.Map.Dict.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => (t<'k, 'a, 'id>, t<'k, 'a, 'id>)"
      },
      {
        "id": "Belt.Map.Dict.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains\n    all the bindings of `s` that satisfy the predicate `p`, and `m2` is the map\n    with all the bindings of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t<'k, 'a, 'id>, ('k, 'a) => bool) => (t<'k, 'a, 'id>, t<'k, 'a, 'id>)"
      },
      {
        "id": "Belt.Map.Dict.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(x, m)` returns a triple `(l, data, r)`, where `l` is the map with\n    all the bindings of `m` whose key is strictly less than `x`; `r` is the map\n    with all the bindings of `m` whose key is strictly greater than `x`; `data`\n    is `None` if `m` contains no binding for `x`, or `Some(v)` if `m` binds `v`\n    to `x`."
        ],
        "signature": "let split: (\\n  t<'a, 'b, 'id>,\\n  'a,\\n  ~cmp: cmp<'a, 'id>,\\n) => ((t<'a, 'b, 'id>, t<'a, 'b, 'id>), option<'b>)"
      },
      {
        "id": "Belt.Map.Dict.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'k, 'a, 'id>, (. 'a) => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f)` returns a map with same domain as `m`, where the associated\n    value `a` of all bindings of `m` has been replaced by the result of the\n    application of `f` to `a`. The bindings are passed to `f` in increasing\n    order with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'k, 'a, 'id>, (. 'k, 'a) => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.Map.Dict.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>"
      }
    ]
  },
  "belt/map/string": {
    "id": "Belt.Map.String",
    "name": "String",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Map.String.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = string"
      },
      {
        "id": "Belt.Map.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of maps from type `key` to type `'value`."
        ],
        "signature": "type t<'value>"
      },
      {
        "id": "Belt.Map.String.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t<'v>"
      },
      {
        "id": "Belt.Map.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'v> => bool"
      },
      {
        "id": "Belt.Map.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'v>, key) => bool"
      },
      {
        "id": "Belt.Map.String.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'v>, t<'v>, (. 'v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.String.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t<'v>, t<'v>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.String.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'v>, t<'v>, (. 'v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq m1 m2` tests whether the maps `m1` and `m2` are\n  equal, that is, contain equal keys and associate them with\n  equal data."
        ],
        "signature": "let eq: (t<'v>, t<'v>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "docstrings": [],
        "signature": "let findFirstByU: (t<'v>, (. key, 'v) => bool) => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "docstrings": [
          "`findFirstBy m p` uses funcion `f` to find the first key value pair\n  to match predicate `p`.\n\n  ```\n  let s0 = fromArray ~id:(module IntCmp) [|4,\"4\";1,\"1\";2,\"2,\"3\"\"|];;\n  findFirstBy s0 (fun k v -> k = 4 ) = option (4, \"4\");;\n  ```"
        ],
        "signature": "let findFirstBy: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'v>, (. key, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument. The bindings are passed to `f` in increasing\n  order with respect to the ordering over the type of the keys."
        ],
        "signature": "let forEach: (t<'v>, (key, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'v>, 'v2, (. 'v2, key, 'v) => 'v2) => 'v2"
      },
      {
        "id": "Belt.Map.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."
        ],
        "signature": "let reduce: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2"
      },
      {
        "id": "Belt.Map.String.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'v>, (. key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every m p` checks if all the bindings of the map\n    satisfy the predicate `p`. Order unspecified"
        ],
        "signature": "let every: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'v>, (. key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some m p` checks if at least one binding of the map\n    satisfy the predicate `p`. Order unspecified"
        ],
        "signature": "let some: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'v> => int"
      },
      {
        "id": "Belt.Map.String.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order."
        ],
        "signature": "let toList: t<'v> => list<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'v> => array<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'v)> => t<'v>"
      },
      {
        "id": "Belt.Map.String.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'v> => array<key>"
      },
      {
        "id": "Belt.Map.String.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'v> => array<'v>"
      },
      {
        "id": "Belt.Map.String.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.Map.String.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.Map.String.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.Map.String.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.Map.String.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'v> => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'v> => Js.undefined<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'v> => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'v> => Js.undefined<(key, 'v)>"
      },
      {
        "id": "Belt.Map.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'v>, key) => option<'v>"
      },
      {
        "id": "Belt.Map.String.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'v>, key) => Js.undefined<'v>"
      },
      {
        "id": "Belt.Map.String.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'v>, key, 'v) => 'v"
      },
      {
        "id": "Belt.Map.String.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'v>, key) => 'v"
      },
      {
        "id": "Belt.Map.String.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a> => unit"
      },
      {
        "id": "Belt.Map.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove m x` returns a map containing the same bindings as\n    `m`, except for `x` which is unbound in the returned map."
        ],
        "signature": "let remove: (t<'v>, key) => t<'v>"
      },
      {
        "id": "Belt.Map.String.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'v>, array<key>) => t<'v>"
      },
      {
        "id": "Belt.Map.String.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set m x y` returns a map containing the same bindings as\n  `m`, plus a binding of `x` to `y`. If `x` was already bound\n  in `m`, its previous binding disappears."
        ],
        "signature": "let set: (t<'v>, key, 'v) => t<'v>"
      },
      {
        "id": "Belt.Map.String.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'v>, key, (. option<'v>) => option<'v>) => t<'v>"
      },
      {
        "id": "Belt.Map.String.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'v>, key, option<'v> => option<'v>) => t<'v>"
      },
      {
        "id": "Belt.Map.String.mergeU",
        "kind": "value",
        "name": "mergeU",
        "docstrings": [],
        "signature": "let mergeU: (t<'v>, t<'v2>, (. key, option<'v>, option<'v2>) => option<'c>) => t<'c>"
      },
      {
        "id": "Belt.Map.String.merge",
        "kind": "value",
        "name": "merge",
        "docstrings": [
          "`merge m1 m2 f` computes a map whose keys is a subset of keys of `m1`\n  and of `m2`. The presence of each such binding, and the corresponding\n  value, is determined with the function `f`."
        ],
        "signature": "let merge: (t<'v>, t<'v2>, (key, option<'v>, option<'v2>) => option<'c>) => t<'c>"
      },
      {
        "id": "Belt.Map.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'v>, array<(key, 'v)>) => t<'v>"
      },
      {
        "id": "Belt.Map.String.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'v>, (. key, 'v) => bool) => t<'v>"
      },
      {
        "id": "Belt.Map.String.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep m p` returns the map with all the bindings in `m`\n    that satisfy predicate `p`."
        ],
        "signature": "let keep: (t<'v>, (key, 'v) => bool) => t<'v>"
      },
      {
        "id": "Belt.Map.String.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'v>, (. key, 'v) => bool) => (t<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.String.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition m p` returns a pair of maps `(m1, m2)`, where\n  `m1` contains all the bindings of `s` that satisfy the\n  predicate `p`, and `m2` is the map with all the bindings of\n  `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.String.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split x m` returns a triple `(l, data, r)`, where\n  `l` is the map with all the bindings of `m` whose key\n  is strictly less than `x`;\n  `r` is the map with all the bindings of `m` whose key\n  is strictly greater than `x`;\n  `data` is `None` if `m` contains no binding for `x`,\n  or `Some v` if `m` binds `v` to `x`."
        ],
        "signature": "let split: (key, t<'v>) => (t<'v>, option<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.String.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'v>, (. 'v) => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.String.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'v>, 'v => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.String.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'v>, (. key, 'v) => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.String.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'v>, (key, 'v) => 'v2) => t<'v2>"
      }
    ]
  },
  "belt/map/int": {
    "id": "Belt.Map.Int",
    "name": "Int",
    "docstrings": [
      "```rescript\ntype t<'key, 'value, 'identity>\ntype id<'key, 'id> = Belt_Id.comparable<'key, 'id>\n```"
    ],
    "items": [
      {
        "id": "Belt.Map.Int.key",
        "kind": "type",
        "name": "key",
        "docstrings": [],
        "signature": "type key = int"
      },
      {
        "id": "Belt.Map.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of maps from type `key` to type `'value`."
        ],
        "signature": "type t<'value>"
      },
      {
        "id": "Belt.Map.Int.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t<'v>"
      },
      {
        "id": "Belt.Map.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'v> => bool"
      },
      {
        "id": "Belt.Map.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'v>, key) => bool"
      },
      {
        "id": "Belt.Map.Int.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'v>, t<'v>, (. 'v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.Int.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: (t<'v>, t<'v>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.Int.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'v>, t<'v>, (. 'v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq m1 m2` tests whether the maps `m1` and `m2` are\n  equal, that is, contain equal keys and associate them with\n  equal data."
        ],
        "signature": "let eq: (t<'v>, t<'v>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "docstrings": [],
        "signature": "let findFirstByU: (t<'v>, (. key, 'v) => bool) => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "docstrings": [
          "`findFirstBy m p` uses funcion `f` to find the first key value pair\n  to match predicate `p`.\n\n  ```\n  let s0 = fromArray ~id:(module IntCmp) [|4,\"4\";1,\"1\";2,\"2,\"3\"\"|];;\n  findFirstBy s0 (fun k v -> k = 4 ) = option (4, \"4\");;\n  ```"
        ],
        "signature": "let findFirstBy: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'v>, (. key, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument. The bindings are passed to `f` in increasing\n  order with respect to the ordering over the type of the keys."
        ],
        "signature": "let forEach: (t<'v>, (key, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'v>, 'v2, (. 'v2, key, 'v) => 'v2) => 'v2"
      },
      {
        "id": "Belt.Map.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."
        ],
        "signature": "let reduce: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2"
      },
      {
        "id": "Belt.Map.Int.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'v>, (. key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every m p` checks if all the bindings of the map\n    satisfy the predicate `p`. Order unspecified"
        ],
        "signature": "let every: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'v>, (. key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some m p` checks if at least one binding of the map\n    satisfy the predicate `p`. Order unspecified"
        ],
        "signature": "let some: (t<'v>, (key, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'v> => int"
      },
      {
        "id": "Belt.Map.Int.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order."
        ],
        "signature": "let toList: t<'v> => list<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'v> => array<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<(key, 'v)> => t<'v>"
      },
      {
        "id": "Belt.Map.Int.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'v> => array<key>"
      },
      {
        "id": "Belt.Map.Int.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'v> => array<'v>"
      },
      {
        "id": "Belt.Map.Int.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.Map.Int.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.Map.Int.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'a> => option<key>"
      },
      {
        "id": "Belt.Map.Int.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>"
      },
      {
        "id": "Belt.Map.Int.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'v> => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'v> => Js.undefined<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'v> => option<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'v> => Js.undefined<(key, 'v)>"
      },
      {
        "id": "Belt.Map.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'v>, key) => option<'v>"
      },
      {
        "id": "Belt.Map.Int.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'v>, key) => Js.undefined<'v>"
      },
      {
        "id": "Belt.Map.Int.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'v>, key, 'v) => 'v"
      },
      {
        "id": "Belt.Map.Int.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'v>, key) => 'v"
      },
      {
        "id": "Belt.Map.Int.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a> => unit"
      },
      {
        "id": "Belt.Map.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove m x` returns a map containing the same bindings as\n    `m`, except for `x` which is unbound in the returned map."
        ],
        "signature": "let remove: (t<'v>, key) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'v>, array<key>) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set m x y` returns a map containing the same bindings as\n  `m`, plus a binding of `x` to `y`. If `x` was already bound\n  in `m`, its previous binding disappears."
        ],
        "signature": "let set: (t<'v>, key, 'v) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'v>, key, (. option<'v>) => option<'v>) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'v>, key, option<'v> => option<'v>) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.mergeU",
        "kind": "value",
        "name": "mergeU",
        "docstrings": [],
        "signature": "let mergeU: (t<'v>, t<'v2>, (. key, option<'v>, option<'v2>) => option<'c>) => t<'c>"
      },
      {
        "id": "Belt.Map.Int.merge",
        "kind": "value",
        "name": "merge",
        "docstrings": [
          "`merge m1 m2 f` computes a map whose keys is a subset of keys of `m1`\n  and of `m2`. The presence of each such binding, and the corresponding\n  value, is determined with the function `f`."
        ],
        "signature": "let merge: (t<'v>, t<'v2>, (key, option<'v>, option<'v2>) => option<'c>) => t<'c>"
      },
      {
        "id": "Belt.Map.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'v>, array<(key, 'v)>) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'v>, (. key, 'v) => bool) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep m p` returns the map with all the bindings in `m`\n    that satisfy predicate `p`."
        ],
        "signature": "let keep: (t<'v>, (key, 'v) => bool) => t<'v>"
      },
      {
        "id": "Belt.Map.Int.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'v>, (. key, 'v) => bool) => (t<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.Int.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition m p` returns a pair of maps `(m1, m2)`, where\n  `m1` contains all the bindings of `s` that satisfy the\n  predicate `p`, and `m2` is the map with all the bindings of\n  `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.Int.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split x m` returns a triple `(l, data, r)`, where\n  `l` is the map with all the bindings of `m` whose key\n  is strictly less than `x`;\n  `r` is the map with all the bindings of `m` whose key\n  is strictly greater than `x`;\n  `data` is `None` if `m` contains no binding for `x`,\n  or `Some v` if `m` binds `v` to `x`."
        ],
        "signature": "let split: (key, t<'v>) => (t<'v>, option<'v>, t<'v>)"
      },
      {
        "id": "Belt.Map.Int.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'v>, (. 'v) => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.Int.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'v>, 'v => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.Int.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'v>, (. key, 'v) => 'v2) => t<'v2>"
      },
      {
        "id": "Belt.Map.Int.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'v>, (key, 'v) => 'v2) => t<'v2>"
      }
    ]
  },
  "belt/set/dict": {
    "id": "Belt.Set.Dict",
    "name": "Dict",
    "docstrings": [
      "This module separates identity from data, it is a bit more verbose but slightly\n  more efficient due to the fact that there is no need to pack identity and data back\n  after each operation"
    ],
    "items": [
      {
        "id": "Belt.Set.Dict.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'value` is the element type\n\n  `'identity` the identity of the collection"
        ],
        "signature": "type t<'value, 'identity>"
      },
      {
        "id": "Belt.Set.Dict.cmp",
        "kind": "type",
        "name": "cmp",
        "docstrings": [
          "Type of compare function."
        ],
        "signature": "type cmp<'value, 'id> = Belt_Id.cmp<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [
          "```rescript\n  let s0 = Belt.Set.Dict.empty\n  ```"
        ],
        "signature": "let empty: t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Creates new set from array of elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([1, 3, 2, 4], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.toArray /* [1, 2, 3, 4] */\n  ```"
        ],
        "signature": "let fromArray: (array<'value>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [
          "The same as [fromArray][#fromarray] except it is after assuming the input array is already sorted."
        ],
        "signature": "let fromSortedArrayUnsafe: array<'value> => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "Checks if set is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let empty = Belt.Set.Dict.fromArray([], ~cmp=IntCmp.cmp)\n  let notEmpty = Belt.Set.Dict.fromArray([1], ~cmp=IntCmp.cmp)\n\n  Belt.Set.Dict.isEmpty(empty) /* true */\n  Belt.Set.Dict.isEmpty(notEmpty) /* false */\n  ```"
        ],
        "signature": "let isEmpty: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.Set.Dict.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks if an element exists in the set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.Set.Dict.fromArray([1, 4, 2, 5], ~cmp=IntCmp.cmp)\n\n  set->Belt.Set.Dict.has(3, ~cmp=IntCmp.cmp) /* false */\n  set->Belt.Set.Dict.has(1, ~cmp=IntCmp.cmp) /* true */\n  ```"
        ],
        "signature": "let has: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => bool"
      },
      {
        "id": "Belt.Set.Dict.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds element to set. If element existed in set, value is unchanged.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = s0->Belt.Set.Dict.add(1, ~cmp=IntCmp.cmp)\n  let s2 = s1->Belt.Set.Dict.add(2, ~cmp=IntCmp.cmp)\n  let s3 = s2->Belt.Set.Dict.add(2, ~cmp=IntCmp.cmp)\n  s0->Belt.Set.Dict.toArray /* [] */\n  s1->Belt.Set.Dict.toArray /* [1] */\n  s2->Belt.Set.Dict.toArray /* [1, 2] */\n  s3->Belt.Set.Dict.toArray /* [1,2 ] */\n  s2 == s3 /* true */\n  ```"
        ],
        "signature": "let add: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "Adds each element of array to set. Unlike [add](#add), the reference of return value might be changed even if all values in array already exist in set\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.Set.Dict.empty\n\n  let newSet = set->Belt.Set.Dict.mergeMany([5, 4, 3, 2, 1], ~cmp=IntCmp.cmp)\n  newSet->Belt.Set.Dict.toArray /* [1, 2, 3, 4, 5] */\n  ```"
        ],
        "signature": "let mergeMany: (t<'value, 'id>, array<'value>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "Removes element from set. If element did not exist in set, value is unchanged.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([2, 3, 1, 4, 5], ~cmp=IntCmp.cmp)\n  let s1 = s0->Belt.Set.Dict.remove(1, ~cmp=IntCmp.cmp)\n  let s2 = s1->Belt.Set.Dict.remove(3, ~cmp=IntCmp.cmp)\n  let s3 = s2->Belt.Set.Dict.remove(3, ~cmp=IntCmp.cmp)\n\n  s1->Belt.Set.Dict.toArray /* [2,3,4,5] */\n  s2->Belt.Set.Dict.toArray /* [2,4,5] */\n  s2 == s3 /* true */\n  ```"
        ],
        "signature": "let remove: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [
          "Removes each element of array from set. Unlike [remove](#remove), the reference of return value might be changed even if any values in array not existed in set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.Set.Dict.fromArray([1, 2, 3, 4], ~cmp=IntCmp.cmp)\n\n  let newSet = set->Belt.Set.Dict.removeMany([5, 4, 3, 2, 1], ~cmp=IntCmp.cmp)\n  newSet->Belt.Set.Dict.toArray /* [] */\n  ```"
        ],
        "signature": "let removeMany: (t<'value, 'id>, array<'value>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "Returns union of two sets.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n  let union = Belt.Set.Dict.union(s0, s1, ~cmp=IntCmp.cmp)\n  union->Belt.Set.Dict.toArray /* [1,2,3,4,5,6] */\n  ```"
        ],
        "signature": "let union: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [
          "Returns intersection of two sets.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n  let intersect = Belt.Set.Dict.intersect(s0, s1, ~cmp=IntCmp.cmp)\n  intersect->Belt.Set.Dict.toArray /* [2,3,5] */\n  ```"
        ],
        "signature": "let intersect: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [
          "Returns elements from first set, not existing in second set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n\n  let diff1 = Belt.Set.Dict.diff(s0, s1, ~cmp=IntCmp.cmp)\n  let diff2 = Belt.Set.Dict.diff(s1, s0, ~cmp=IntCmp.cmp)\n\n  diff1->Belt.Set.Dict.toArray /* [6] */\n  diff2->Belt.Set.Dict.toArray /* [1,4] */\n  ```"
        ],
        "signature": "let diff: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "Checks if second set is subset of first set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n  let s2 = Belt.Set.Dict.intersect(s0, s1, ~cmp=IntCmp.cmp)\n  Belt.Set.Dict.subset(s2, s0, ~cmp=IntCmp.cmp) /* true */\n  Belt.Set.Dict.subset(s2, s1, ~cmp=IntCmp.cmp) /* true */\n  Belt.Set.Dict.subset(s1, s0, ~cmp=IntCmp.cmp) /* false */\n  ```"
        ],
        "signature": "let subset: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => bool"
      },
      {
        "id": "Belt.Set.Dict.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compares size first and then iterates over each element following the order of elements."
        ],
        "signature": "let cmp: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => int"
      },
      {
        "id": "Belt.Set.Dict.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Checks if two sets are equal.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 5], ~cmp=IntCmp.cmp)\n\n  Belt.Set.Dict.eq(s0, s1, ~cmp=IntCmp.cmp) /* true */\n  ```"
        ],
        "signature": "let eq: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => bool"
      },
      {
        "id": "Belt.Set.Dict.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Same as [forEach](##forEach) but takes uncurried functon."
        ],
        "signature": "let forEachU: (t<'value, 'id>, (. 'value) => unit) => unit"
      },
      {
        "id": "Belt.Set.Dict.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Applies function `f` in turn to all elements of set in increasing order.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let acc = ref(list{})\n  s0->Belt.Set.Dict.forEach(x => acc := Belt.List.add(acc.contents, x))\n  acc /* [6,5,3,2] */\n  ```"
        ],
        "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.Set.Dict.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'value, 'id>, 'a, (. 'a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.Dict.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an “accumulator”, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  s0->Belt.Set.Dict.reduce(list{}, (acc, element) => acc->Belt.List.add(element)) /* [6,5,3,2] */\n  ```"
        ],
        "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.Dict.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'value, 'id>, (. 'value) => bool) => bool"
      },
      {
        "id": "Belt.Set.Dict.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.Set.Dict.fromArray([2, 4, 6, 8], ~cmp=IntCmp.cmp)\n  s0->Belt.Set.Dict.every(isEven) /* true */\n  ```"
        ],
        "signature": "let every: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.Dict.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'value, 'id>, (. 'value) => bool) => bool"
      },
      {
        "id": "Belt.Set.Dict.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "Checks if at least one element of the set satisfies the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 4, 6, 8], ~cmp=IntCmp.cmp)\n  s0->Belt.Set.Dict.some(isOdd) /* true */\n  ```"
        ],
        "signature": "let some: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.Dict.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'value, 'id>, (. 'value) => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "Returns the set of all elements that satisfy the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n  let s1 = s0->Belt.Set.Dict.keep(isEven)\n\n  s1->Belt.Set.Dict.toArray /* [2,4] */\n  ```"
        ],
        "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.Dict.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'value, 'id>, (. 'value) => bool) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.Set.Dict.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "Returns a pair of sets, where first is the set of all the elements of set that satisfy the predicate, and second is the set of all the elements of set that do not satisfy the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n  let (s1, s2) = s0->Belt.Set.Dict.partition(isOdd)\n\n  s1->Belt.Set.Dict.toArray /* [1,3,5] */\n  s2->Belt.Set.Dict.toArray /* [2,4] */\n  ```"
        ],
        "signature": "let partition: (t<'value, 'id>, 'value => bool) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.Set.Dict.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns size of the set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.size /* 4 */\n  ```"
        ],
        "signature": "let size: t<'value, 'id> => int"
      },
      {
        "id": "Belt.Set.Dict.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "Returns list of ordered set elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.toList /* [1,2,3,5] */\n  ```"
        ],
        "signature": "let toList: t<'value, 'id> => list<'value>"
      },
      {
        "id": "Belt.Set.Dict.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Returns array of ordered set elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.toArray /* [1,2,3,5] */\n  ```"
        ],
        "signature": "let toArray: t<'value, 'id> => array<'value>"
      },
      {
        "id": "Belt.Set.Dict.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [
          "Returns minimum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.minimum /* None */\n  s1->Belt.Set.Dict.minimum /* Some(1) */\n  ```"
        ],
        "signature": "let minimum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.Set.Dict.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [
          "Returns minimum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.minUndefined /* undefined */\n  s1->Belt.Set.Dict.minUndefined /* 1 */\n  ```"
        ],
        "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.Dict.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [
          "Returns maximum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.maximum /* None */\n  s1->Belt.Set.Dict.maximum /* Some(5) */\n  ```"
        ],
        "signature": "let maximum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.Set.Dict.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [
          "Returns maximum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.maxUndefined /* undefined */\n  s1->Belt.Set.Dict.maxUndefined /* 5 */\n  ```"
        ],
        "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.Dict.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.get(3, ~cmp=IntCmp.cmp) /* Some(3) */\n  s0->Belt.Set.Dict.get(20, ~cmp=IntCmp.cmp) /* None */\n  ```"
        ],
        "signature": "let get: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => option<'value>"
      },
      {
        "id": "Belt.Set.Dict.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "Same as [get](#get) but returns `undefined` when element does not exist."
        ],
        "signature": "let getUndefined: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.Dict.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Same as [get](#get) but raise when element does not exist."
        ],
        "signature": "let getExn: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => 'value"
      },
      {
        "id": "Belt.Set.Dict.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n\n  let ((smaller, larger), present) = s0->Belt.Set.Dict.split(3, ~cmp=IntCmp.cmp)\n\n  present /* true */\n  smaller->Belt.Set.Dict.toArray /* [1,2] */\n  larger->Belt.Set.Dict.toArray /* [4,5] */\n  ```"
        ],
        "signature": "let split: (\\n  t<'value, 'id>,\\n  'value,\\n  ~cmp: cmp<'value, 'id>,\\n) => ((t<'value, 'id>, t<'value, 'id>), bool)"
      },
      {
        "id": "Belt.Set.Dict.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b> => unit"
      }
    ]
  },
  "belt/set/string": {
    "id": "Belt.Set.String",
    "name": "String",
    "docstrings": [
      "Specialized when value type is `string`, more efficient\n  than the generic type, its compare behavior is fixed using the built-in comparison"
    ],
    "items": [
      {
        "id": "Belt.Set.String.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The type of the set elements."
        ],
        "signature": "type value = string"
      },
      {
        "id": "Belt.Set.String.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of sets."
        ],
        "signature": "type t"
      },
      {
        "id": "Belt.Set.String.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t"
      },
      {
        "id": "Belt.Set.String.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<value> => t"
      },
      {
        "id": "Belt.Set.String.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [],
        "signature": "let fromSortedArrayUnsafe: array<value> => t"
      },
      {
        "id": "Belt.Set.String.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.Set.String.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, value) => bool"
      },
      {
        "id": "Belt.Set.String.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "`add s x` If `x` was already in `s`, `s` is returned unchanged."
        ],
        "signature": "let add: (t, value) => t"
      },
      {
        "id": "Belt.Set.String.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<value>) => t"
      },
      {
        "id": "Belt.Set.String.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove m x` If `x` was not in `m`, `m` is returned reference unchanged."
        ],
        "signature": "let remove: (t, value) => t"
      },
      {
        "id": "Belt.Set.String.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t, array<value>) => t"
      },
      {
        "id": "Belt.Set.String.union",
        "kind": "value",
        "name": "union",
        "docstrings": [],
        "signature": "let union: (t, t) => t"
      },
      {
        "id": "Belt.Set.String.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (t, t) => t"
      },
      {
        "id": "Belt.Set.String.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (t, t) => t"
      },
      {
        "id": "Belt.Set.String.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "`subset s1 s2` tests whether the set `s1` is a subset of\n    the set `s2`."
        ],
        "signature": "let subset: (t, t) => bool"
      },
      {
        "id": "Belt.Set.String.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function\n    for doing sets of sets."
        ],
        "signature": "let cmp: (t, t) => int"
      },
      {
        "id": "Belt.Set.String.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq s1 s2` tests whether the sets `s1` and `s2` are\n    equal, that is, contain equal elements."
        ],
        "signature": "let eq: (t, t) => bool"
      },
      {
        "id": "Belt.Set.String.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, (. value) => unit) => unit"
      },
      {
        "id": "Belt.Set.String.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach s f` applies `f` in turn to all elements of `s`.\n    In increasing order"
        ],
        "signature": "let forEach: (t, value => unit) => unit"
      },
      {
        "id": "Belt.Set.String.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.String.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Iterate in increasing order."
        ],
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.String.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t, (. value) => bool) => bool"
      },
      {
        "id": "Belt.Set.String.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every p s` checks if all elements of the set\n    satisfy the predicate `p`. Order unspecified."
        ],
        "signature": "let every: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.String.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t, (. value) => bool) => bool"
      },
      {
        "id": "Belt.Set.String.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some p s` checks if at least one element of\n    the set satisfies the predicate `p`. Oder unspecified."
        ],
        "signature": "let some: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.String.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t, (. value) => bool) => t"
      },
      {
        "id": "Belt.Set.String.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep p s` returns the set of all elements in `s`\n    that satisfy predicate `p`."
        ],
        "signature": "let keep: (t, value => bool) => t"
      },
      {
        "id": "Belt.Set.String.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t, (. value) => bool) => (t, t)"
      },
      {
        "id": "Belt.Set.String.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition p s` returns a pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.Set.String.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.Set.String.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toList: t => list<value>"
      },
      {
        "id": "Belt.Set.String.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t => array<value>"
      },
      {
        "id": "Belt.Set.String.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t => option<value>"
      },
      {
        "id": "Belt.Set.String.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.String.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t => option<value>"
      },
      {
        "id": "Belt.Set.String.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.String.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t, value) => option<value>"
      },
      {
        "id": "Belt.Set.String.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t, value) => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.String.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t, value) => value"
      },
      {
        "id": "Belt.Set.String.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split x s` returns a triple `(l, present, r)`, where\n  `l` is the set of elements of `s` that are\n  strictly less than `x`;\n  `r` is the set of elements of `s` that are\n  strictly greater than `x`;\n  `present` is `false` if `s` contains no element equal to `x`,\n  or `true` if `s` contains an element equal to `x`."
        ],
        "signature": "let split: (t, value) => ((t, t), bool)"
      },
      {
        "id": "Belt.Set.String.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t => unit"
      }
    ]
  },
  "belt/set/int": {
    "id": "Belt.Set.Int",
    "name": "Int",
    "docstrings": [
      "Specialized when value type is `int`, more efficient\n  than the generic type, its compare behavior is fixed using the built-in comparison"
    ],
    "items": [
      {
        "id": "Belt.Set.Int.value",
        "kind": "type",
        "name": "value",
        "docstrings": [
          "The type of the set elements."
        ],
        "signature": "type value = int"
      },
      {
        "id": "Belt.Set.Int.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of sets."
        ],
        "signature": "type t"
      },
      {
        "id": "Belt.Set.Int.empty",
        "kind": "value",
        "name": "empty",
        "docstrings": [],
        "signature": "let empty: t"
      },
      {
        "id": "Belt.Set.Int.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: array<value> => t"
      },
      {
        "id": "Belt.Set.Int.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [],
        "signature": "let fromSortedArrayUnsafe: array<value> => t"
      },
      {
        "id": "Belt.Set.Int.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t => bool"
      },
      {
        "id": "Belt.Set.Int.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t, value) => bool"
      },
      {
        "id": "Belt.Set.Int.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "`add s x` If `x` was already in `s`, `s` is returned unchanged."
        ],
        "signature": "let add: (t, value) => t"
      },
      {
        "id": "Belt.Set.Int.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t, array<value>) => t"
      },
      {
        "id": "Belt.Set.Int.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove m x` If `x` was not in `m`, `m` is returned reference unchanged."
        ],
        "signature": "let remove: (t, value) => t"
      },
      {
        "id": "Belt.Set.Int.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t, array<value>) => t"
      },
      {
        "id": "Belt.Set.Int.union",
        "kind": "value",
        "name": "union",
        "docstrings": [],
        "signature": "let union: (t, t) => t"
      },
      {
        "id": "Belt.Set.Int.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (t, t) => t"
      },
      {
        "id": "Belt.Set.Int.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (t, t) => t"
      },
      {
        "id": "Belt.Set.Int.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "`subset s1 s2` tests whether the set `s1` is a subset of\n    the set `s2`."
        ],
        "signature": "let subset: (t, t) => bool"
      },
      {
        "id": "Belt.Set.Int.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function\n    for doing sets of sets."
        ],
        "signature": "let cmp: (t, t) => int"
      },
      {
        "id": "Belt.Set.Int.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq s1 s2` tests whether the sets `s1` and `s2` are\n    equal, that is, contain equal elements."
        ],
        "signature": "let eq: (t, t) => bool"
      },
      {
        "id": "Belt.Set.Int.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t, (. value) => unit) => unit"
      },
      {
        "id": "Belt.Set.Int.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach s f` applies `f` in turn to all elements of `s`.\n    In increasing order"
        ],
        "signature": "let forEach: (t, value => unit) => unit"
      },
      {
        "id": "Belt.Set.Int.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.Int.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Iterate in increasing order."
        ],
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.Int.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t, (. value) => bool) => bool"
      },
      {
        "id": "Belt.Set.Int.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every p s` checks if all elements of the set\n    satisfy the predicate `p`. Order unspecified."
        ],
        "signature": "let every: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.Int.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t, (. value) => bool) => bool"
      },
      {
        "id": "Belt.Set.Int.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some p s` checks if at least one element of\n    the set satisfies the predicate `p`. Oder unspecified."
        ],
        "signature": "let some: (t, value => bool) => bool"
      },
      {
        "id": "Belt.Set.Int.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t, (. value) => bool) => t"
      },
      {
        "id": "Belt.Set.Int.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep p s` returns the set of all elements in `s`\n    that satisfy predicate `p`."
        ],
        "signature": "let keep: (t, value => bool) => t"
      },
      {
        "id": "Belt.Set.Int.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t, (. value) => bool) => (t, t)"
      },
      {
        "id": "Belt.Set.Int.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition p s` returns a pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t, value => bool) => (t, t)"
      },
      {
        "id": "Belt.Set.Int.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t => int"
      },
      {
        "id": "Belt.Set.Int.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order"
        ],
        "signature": "let toList: t => list<value>"
      },
      {
        "id": "Belt.Set.Int.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t => array<value>"
      },
      {
        "id": "Belt.Set.Int.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t => option<value>"
      },
      {
        "id": "Belt.Set.Int.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.Int.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t => option<value>"
      },
      {
        "id": "Belt.Set.Int.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.Int.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t, value) => option<value>"
      },
      {
        "id": "Belt.Set.Int.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t, value) => Js.undefined<value>"
      },
      {
        "id": "Belt.Set.Int.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t, value) => value"
      },
      {
        "id": "Belt.Set.Int.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split x s` returns a triple `(l, present, r)`, where\n  `l` is the set of elements of `s` that are\n  strictly less than `x`;\n  `r` is the set of elements of `s` that are\n  strictly greater than `x`;\n  `present` is `false` if `s` contains no element equal to `x`,\n  or `true` if `s` contains an element equal to `x`."
        ],
        "signature": "let split: (t, value) => ((t, t), bool)"
      },
      {
        "id": "Belt.Set.Int.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t => unit"
      }
    ]
  },
  "belt/sortarray/string": {
    "id": "Belt.SortArray.String",
    "name": "String",
    "docstrings": [
      "Specalized when key type is `string`, more efficient\n    than the generic type"
    ],
    "items": [
      {
        "id": "Belt.SortArray.String.element",
        "kind": "type",
        "name": "element",
        "docstrings": [],
        "signature": "type element = string"
      },
      {
        "id": "Belt.SortArray.String.strictlySortedLength",
        "kind": "value",
        "name": "strictlySortedLength",
        "docstrings": [
          "The same as [`Belt_SortArray.strictlySortedLength`]() except the comparator is fixed\n\n  **return** `+n` means increasing order  `-n` means negative order"
        ],
        "signature": "let strictlySortedLength: array<element> => int"
      },
      {
        "id": "Belt.SortArray.String.isSorted",
        "kind": "value",
        "name": "isSorted",
        "docstrings": [
          "`sorted xs` return true if `xs` is in non strict increasing order"
        ],
        "signature": "let isSorted: array<element> => bool"
      },
      {
        "id": "Belt.SortArray.String.stableSortInPlace",
        "kind": "value",
        "name": "stableSortInPlace",
        "docstrings": [
          "The same as [`Belt_SortArray.stableSortInPlaceBy`]() except the comparator is fixed"
        ],
        "signature": "let stableSortInPlace: array<element> => unit"
      },
      {
        "id": "Belt.SortArray.String.stableSort",
        "kind": "value",
        "name": "stableSort",
        "docstrings": [
          "The same as [`Belt_SortArray.stableSortBy`]() except the comparator is fixed"
        ],
        "signature": "let stableSort: array<element> => array<element>"
      },
      {
        "id": "Belt.SortArray.String.binarySearch",
        "kind": "value",
        "name": "binarySearch",
        "docstrings": [
          "If value is not found and value is less than one or more elements in array,\n  the negative number returned is the bitwise complement of the index of the first element\n  that is larger than value.\n\n  If value is not found and value is greater than all elements in array,\n  the negative number returned is the bitwise complement of\n  (the index of the last element plus 1)\n\n  for example, if `key` is smaller than all elements return `-1` since `lnot (-1) = 0`\n  if `key` is larger than all elements return `- (len + 1)` since `lnot (-(len+1)) = len`"
        ],
        "signature": "let binarySearch: (array<element>, element) => int"
      },
      {
        "id": "Belt.SortArray.String.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n  assume `src` and `src2` is strictly sorted.\n  for equivalent elements, it is picked from `src`\n  also assume that `dst` is large enough to store all elements"
        ],
        "signature": "let union: (array<element>, int, int, array<element>, int, int, array<element>, int) => int"
      },
      {
        "id": "Belt.SortArray.String.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (array<element>, int, int, array<element>, int, int, array<element>, int) => int"
      },
      {
        "id": "Belt.SortArray.String.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (array<element>, int, int, array<element>, int, int, array<element>, int) => int"
      }
    ]
  },
  "belt/sortarray/int": {
    "id": "Belt.SortArray.Int",
    "name": "Int",
    "docstrings": [
      "Specalized when key type is `int`, more efficient\n    than the generic type"
    ],
    "items": [
      {
        "id": "Belt.SortArray.Int.element",
        "kind": "type",
        "name": "element",
        "docstrings": [],
        "signature": "type element = int"
      },
      {
        "id": "Belt.SortArray.Int.strictlySortedLength",
        "kind": "value",
        "name": "strictlySortedLength",
        "docstrings": [
          "The same as [`Belt_SortArray.strictlySortedLength`]() except the comparator is fixed\n\n  **return** `+n` means increasing order  `-n` means negative order"
        ],
        "signature": "let strictlySortedLength: array<element> => int"
      },
      {
        "id": "Belt.SortArray.Int.isSorted",
        "kind": "value",
        "name": "isSorted",
        "docstrings": [
          "`sorted xs` return true if `xs` is in non strict increasing order"
        ],
        "signature": "let isSorted: array<element> => bool"
      },
      {
        "id": "Belt.SortArray.Int.stableSortInPlace",
        "kind": "value",
        "name": "stableSortInPlace",
        "docstrings": [
          "The same as [`Belt_SortArray.stableSortInPlaceBy`]() except the comparator is fixed"
        ],
        "signature": "let stableSortInPlace: array<element> => unit"
      },
      {
        "id": "Belt.SortArray.Int.stableSort",
        "kind": "value",
        "name": "stableSort",
        "docstrings": [
          "The same as [`Belt_SortArray.stableSortBy`]() except the comparator is fixed"
        ],
        "signature": "let stableSort: array<element> => array<element>"
      },
      {
        "id": "Belt.SortArray.Int.binarySearch",
        "kind": "value",
        "name": "binarySearch",
        "docstrings": [
          "If value is not found and value is less than one or more elements in array,\n  the negative number returned is the bitwise complement of the index of the first element\n  that is larger than value.\n\n  If value is not found and value is greater than all elements in array,\n  the negative number returned is the bitwise complement of\n  (the index of the last element plus 1)\n\n  for example, if `key` is smaller than all elements return `-1` since `lnot (-1) = 0`\n  if `key` is larger than all elements return `- (len + 1)` since `lnot (-(len+1)) = len`"
        ],
        "signature": "let binarySearch: (array<element>, element) => int"
      },
      {
        "id": "Belt.SortArray.Int.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n  assume `src` and `src2` is strictly sorted.\n  for equivalent elements, it is picked from `src`\n  also assume that `dst` is large enough to store all elements"
        ],
        "signature": "let union: (array<element>, int, int, array<element>, int, int, array<element>, int) => int"
      },
      {
        "id": "Belt.SortArray.Int.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [],
        "signature": "let intersect: (array<element>, int, int, array<element>, int, int, array<element>, int) => int"
      },
      {
        "id": "Belt.SortArray.Int.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (array<element>, int, int, array<element>, int, int, array<element>, int) => int"
      }
    ]
  },
  "belt/id/makehashable": {
    "id": "Belt.Id.MakeHashable",
    "name": "MakeHashable",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Id.MakeHashable.identity",
        "kind": "type",
        "name": "identity",
        "docstrings": [],
        "signature": "type identity"
      },
      {
        "id": "Belt.Id.MakeHashable.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = M.t"
      },
      {
        "id": "Belt.Id.MakeHashable.hash",
        "kind": "value",
        "name": "hash",
        "docstrings": [],
        "signature": "let hash: hash<t, identity>"
      },
      {
        "id": "Belt.Id.MakeHashable.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [],
        "signature": "let eq: eq<t, identity>"
      }
    ]
  },
  "belt/id/makehashableu": {
    "id": "Belt.Id.MakeHashableU",
    "name": "MakeHashableU",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Id.MakeHashableU.identity",
        "kind": "type",
        "name": "identity",
        "docstrings": [],
        "signature": "type identity"
      },
      {
        "id": "Belt.Id.MakeHashableU.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = M.t"
      },
      {
        "id": "Belt.Id.MakeHashableU.hash",
        "kind": "value",
        "name": "hash",
        "docstrings": [],
        "signature": "let hash: hash<t, identity>"
      },
      {
        "id": "Belt.Id.MakeHashableU.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [],
        "signature": "let eq: eq<t, identity>"
      }
    ]
  },
  "belt/id/makecomparable": {
    "id": "Belt.Id.MakeComparable",
    "name": "MakeComparable",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Id.MakeComparable.identity",
        "kind": "type",
        "name": "identity",
        "docstrings": [],
        "signature": "type identity"
      },
      {
        "id": "Belt.Id.MakeComparable.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = M.t"
      },
      {
        "id": "Belt.Id.MakeComparable.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: cmp<t, identity>"
      }
    ]
  },
  "belt/id/makecomparableu": {
    "id": "Belt.Id.MakeComparableU",
    "name": "MakeComparableU",
    "docstrings": [],
    "items": [
      {
        "id": "Belt.Id.MakeComparableU.identity",
        "kind": "type",
        "name": "identity",
        "docstrings": [],
        "signature": "type identity"
      },
      {
        "id": "Belt.Id.MakeComparableU.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t = M.t"
      },
      {
        "id": "Belt.Id.MakeComparableU.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [],
        "signature": "let cmp: cmp<t, identity>"
      }
    ]
  },
  "belt/float": {
    "id": "Belt.Float",
    "name": "Float",
    "docstrings": [
      "[`Belt.Float`]()\n\n  Utilities for Float."
    ],
    "items": [
      {
        "id": "Belt.Float.toInt",
        "kind": "value",
        "name": "toInt",
        "docstrings": [
          "Converts a given `float` to an `int`.\n\n```rescript\nJs.log(Belt.Float.toInt(1.0) === 1) /* true */\n```"
        ],
        "signature": "let toInt: float => int"
      },
      {
        "id": "Belt.Float.fromInt",
        "kind": "value",
        "name": "fromInt",
        "docstrings": [
          "Converts a given `int` to a `float`.\n\n  ```rescript\n  Js.log(Belt.Float.fromInt(1) === 1.0) /* true */\n  ```"
        ],
        "signature": "let fromInt: int => float"
      },
      {
        "id": "Belt.Float.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [
          "Converts a given `string` to a `float`. Returns `Some(float)` when the input is a number, `None` otherwise.\n\n  ```rescript\n  Js.log(Belt.Float.fromString(\"1.0\") === Some(1.0)) /* true */\n  ```"
        ],
        "signature": "let fromString: string => option<float>"
      },
      {
        "id": "Belt.Float.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "Converts a given `float` to a `string`. Uses the JavaScript `String` constructor under the hood.\n\n  ```rescript\n  Js.log(Belt.Float.toString(1.0) === \"1.0\") /* true */\n  ```"
        ],
        "signature": "let toString: float => string"
      },
      {
        "id": "Belt.Float.+",
        "kind": "value",
        "name": "+",
        "docstrings": [
          "Addition of two `float` values.\n  Can be opened in a module to avoid dot-notation (`+.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n  ```rescript\n  open Belt.Float\n  Js.log(2.0 + 2.0 === 4.0) /* true */\n  ```"
        ],
        "signature": "let _: %rescript.typehole"
      },
      {
        "id": "Belt.Float.-",
        "kind": "value",
        "name": "-",
        "docstrings": [
          "Subtraction of two `float` values.\n  Can be opened in a module to avoid dot-notation (`-.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n  ```rescript\n  open Belt.Float\n  Js.log(2.0 - 1.0 === 1.0) /* true */\n  ```"
        ],
        "signature": "let _: %rescript.typehole"
      },
      {
        "id": "Belt.Float.*",
        "kind": "value",
        "name": "*",
        "docstrings": [
          "Multiplication of two `float` values.\n  Can be opened in a module to avoid dot-notation (`*.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n  ```rescript\n  open Belt.Float\n  Js.log(2.0 * 2.0 === 4.0) /* true */\n  ```"
        ],
        "signature": "let _: %rescript.typehole"
      },
      {
        "id": "Belt.Float./",
        "kind": "value",
        "name": "/",
        "docstrings": [
          "Division of two `float` values.\n  Can be opened in a module to avoid dot-notation (`/.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n  ```rescript\n  open Belt.Float\n  Js.log(4.0 / 2.0 === 2.0) /* true */\n  ```"
        ],
        "signature": "let _: %rescript.typehole"
      }
    ]
  },
  "belt/int": {
    "id": "Belt.Int",
    "name": "Int",
    "docstrings": [
      "[`Belt.Int`]()\n\n  Utilities for Int."
    ],
    "items": [
      {
        "id": "Belt.Int.toFloat",
        "kind": "value",
        "name": "toFloat",
        "docstrings": [
          "Converts a given `int` to a `float`.\n\n  ```rescript\n  Js.log(Belt.Int.toFloat(1) === 1.0) /* true */\n  ```"
        ],
        "signature": "let toFloat: int => float"
      },
      {
        "id": "Belt.Int.fromFloat",
        "kind": "value",
        "name": "fromFloat",
        "docstrings": [
          "Converts a given `float` to an `int`.\n\n  ```rescript\n  Js.log(Belt.Int.fromFloat(1.0) === 1) /* true */\n  ```"
        ],
        "signature": "let fromFloat: float => int"
      },
      {
        "id": "Belt.Int.fromString",
        "kind": "value",
        "name": "fromString",
        "docstrings": [
          "Converts a given `string` to an `int`. Returns `Some(int)` when the input is a number, `None` otherwise.\n\n  ```rescript\n  Js.log(Belt.Int.fromString(\"1\") === Some(1)) /* true */\n  ```"
        ],
        "signature": "let fromString: string => option<int>"
      },
      {
        "id": "Belt.Int.toString",
        "kind": "value",
        "name": "toString",
        "docstrings": [
          "Converts a given `int` to a `string`. Uses the JavaScript `String` constructor under the hood.\n\n  ```rescript\n  Js.log(Belt.Int.toString(1) === \"1\") /* true */\n  ```"
        ],
        "signature": "let toString: int => string"
      },
      {
        "id": "Belt.Int.+",
        "kind": "value",
        "name": "+",
        "docstrings": [
          "Addition of two `int` values. Same as the addition from `Pervasives`.\n\n  ```rescript\n  open Belt.Int\n  Js.log(2 + 2 === 4) /* true */\n  ```"
        ],
        "signature": "let _: %rescript.typehole"
      },
      {
        "id": "Belt.Int.-",
        "kind": "value",
        "name": "-",
        "docstrings": [
          "Subtraction of two `int` values. Same as the subtraction from `Pervasives`.\n\n  ```rescript\n  open Belt.Int\n  Js.log(2 - 1 === 1) /* true */\n  ```"
        ],
        "signature": "let _: %rescript.typehole"
      },
      {
        "id": "Belt.Int.*",
        "kind": "value",
        "name": "*",
        "docstrings": [
          "Multiplication of two `int` values. Same as the multiplication from `Pervasives`.\n\n  ```rescript\n  open Belt.Int\n  Js.log(2 * 2 === 4) /* true */\n  ```"
        ],
        "signature": "let _: %rescript.typehole"
      },
      {
        "id": "Belt.Int./",
        "kind": "value",
        "name": "/",
        "docstrings": [
          "Division of two `int` values. Same as the division from `Pervasives`.\n\n  ```rescript\n  open Belt.Int\n  Js.log(4 / 2 === 2); /* true */\n  ```"
        ],
        "signature": "let _: %rescript.typehole"
      }
    ]
  },
  "belt/result": {
    "id": "Belt.Result",
    "name": "Result",
    "docstrings": [
      "[`Belt.Result`]()\n\n  Utilities for result data type."
    ],
    "items": [
      {
        "id": "Belt.Result.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a, 'b> = Ok('a) | Error('b)"
      },
      {
        "id": "Belt.Result.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "`getExn(res)`: when `res` is `Ok(n)`, returns `n` when `res` is `Error(m)`, raise an exception\n\n  ```rescript\n  Belt.Result.getExn(Belt.Result.Ok(42)) == 42\n\n  Belt.Result.getExn(Belt.Result.Error(\"Invalid data\")) /* raises exception */\n  ```"
        ],
        "signature": "let getExn: t<'a, 'b> => 'a"
      },
      {
        "id": "Belt.Result.mapWithDefaultU",
        "kind": "value",
        "name": "mapWithDefaultU",
        "docstrings": [],
        "signature": "let mapWithDefaultU: (t<'a, 'c>, 'b, (. 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.Result.mapWithDefault",
        "kind": "value",
        "name": "mapWithDefault",
        "docstrings": [
          "`mapWithDefault(res, default, f)`: When res is `Ok(n)`, returns `f(n)`,\n  otherwise `default`.\n\n  ```rescript\n  let ok = Belt.Result.Ok(42)\n  Belt.Result.mapWithDefault(ok, 0, (x) => x / 2) == 21\n\n  let error = Belt.Result.Error(\"Invalid data\")\n  Belt.Result.mapWithDefault(error, 0, (x) => x / 2) == 0\n  ```"
        ],
        "signature": "let mapWithDefault: (t<'a, 'c>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Belt.Result.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a, 'c>, (. 'a) => 'b) => t<'b, 'c>"
      },
      {
        "id": "Belt.Result.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(res, f)`: When res is `Ok(n)`, returns `Ok(f(n))`. Otherwise returns res\n  unchanged. Function `f` takes a value of the same type as `n` and returns an\n  ordinary value.\n\n  ```rescript\n  let f = (x) => sqrt(Belt.Int.toFloat(x))\n\n  Belt.Result.map(Ok(64), f) == Ok(8.0)\n\n  Belt.Result.map(Error(\"Invalid data\"), f) == Error(\"Invalid data\")\n  ```"
        ],
        "signature": "let map: (t<'a, 'c>, 'a => 'b) => t<'b, 'c>"
      },
      {
        "id": "Belt.Result.flatMapU",
        "kind": "value",
        "name": "flatMapU",
        "docstrings": [],
        "signature": "let flatMapU: (t<'a, 'c>, (. 'a) => t<'b, 'c>) => t<'b, 'c>"
      },
      {
        "id": "Belt.Result.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(res, f)`: When res is `Ok(n)`, returns `f(n)`. Otherwise, returns res\n  unchanged. Function `f` takes a value of the same type as `n` and returns a\n  `Belt.Result`.\n\n  ```rescript\n  let recip = (x) =>\n    if (x !== 0.0) {\n      Belt.Result.Ok(1.0 /. x)\n    } else {\n      Belt.Result.Error(\"Divide by zero\")\n    }\n\n  Belt.Result.flatMap(Ok(2.0), recip) == Ok(0.5)\n\n  Belt.Result.flatMap(Ok(0.0), recip) == Error(\"Divide by zero\")\n\n  Belt.Result.flatMap(Error(\"Already bad\"), recip) == Error(\"Already bad\")\n  ```"
        ],
        "signature": "let flatMap: (t<'a, 'c>, 'a => t<'b, 'c>) => t<'b, 'c>"
      },
      {
        "id": "Belt.Result.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [
          "`getWithDefault(res, defaultValue)`: If `res` is `Ok(n)`, returns `n`,\n  otherwise `default`\n\n  ```rescript\n  Belt.Result.getWithDefault(Ok(42), 0) == 42\n\n  Belt.Result.getWithDefault(Error(\"Invalid Data\"), 0) == 0\n  ```"
        ],
        "signature": "let getWithDefault: (t<'a, 'b>, 'a) => 'a"
      },
      {
        "id": "Belt.Result.isOk",
        "kind": "value",
        "name": "isOk",
        "docstrings": [
          "`isOk(res)`: Returns `true` if `res` is of the form `Ok(n)`, `false` if it is\n  the `Error(e)` variant."
        ],
        "signature": "let isOk: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.Result.isError",
        "kind": "value",
        "name": "isError",
        "docstrings": [
          "`isError(res)`: Returns `true` if `res` is of the form `Error(e)`, `false` if\n  it is the `Ok(n)` variant."
        ],
        "signature": "let isError: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.Result.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'a, 'c>, t<'b, 'd>, (. 'a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Result.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(res1, res2, f)`: Determine if two `Belt.Result` variables are equal with\n  respect to an equality function. If `res1` and `res2` are of the form `Ok(n)`\n  and `Ok(m)`, return the result of `f(n, m)`. If one of `res1` and `res2` are of\n  the form `Error(e)`, return false If both `res1` and `res2` are of the form\n  `Error(e)`, return true\n\n  ```rescript\n  let good1 = Belt.Result.Ok(42)\n\n  let good2 = Belt.Result.Ok(32)\n\n  let bad1 = Belt.Result.Error(\"invalid\")\n\n  let bad2 = Belt.Result.Error(\"really invalid\")\n\n  let mod10equal = (a, b) => mod(a, 10) === mod(b, 10)\n\n  Belt.Result.eq(good1, good2, mod10equal) == true\n\n  Belt.Result.eq(good1, bad1, mod10equal) == false\n\n  Belt.Result.eq(bad2, good2, mod10equal) == false\n\n  Belt.Result.eq(bad1, bad2, mod10equal) == true\n  ```"
        ],
        "signature": "let eq: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Result.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'a, 'c>, t<'b, 'd>, (. 'a, 'b) => int) => int"
      },
      {
        "id": "Belt.Result.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(res1, res2, f)`: Compare two `Belt.Result` variables with respect to a\n  comparison function. The comparison function returns -1 if the first variable\n  is \"less than\" the second, 0 if the two variables are equal, and 1 if the first\n  is \"greater than\" the second.\n\n  If `res1` and `res2` are of the form `Ok(n)` and `Ok(m)`, return the result of\n  `f(n, m)`. If `res1` is of the form `Error(e)` and `res2` of the form `Ok(n)`,\n  return -1 (nothing is less than something) If `res1` is of the form `Ok(n)` and\n  `res2` of the form `Error(e)`, return 1 (something is greater than nothing) If\n  both `res1` and `res2` are of the form `Error(e)`, return 0 (equal)\n\n  ```rescript\n  let good1 = Belt.Result.Ok(59)\n\n  let good2 = Belt.Result.Ok(37)\n\n  let bad1 = Belt.Result.Error(\"invalid\")\n\n  let bad2 = Belt.Result.Error(\"really invalid\")\n\n  let mod10cmp = (a, b) => Pervasives.compare(mod(a, 10), mod(b, 10))\n\n  Belt.Result.cmp(Ok(39), Ok(57), mod10cmp) == 1\n\n  Belt.Result.cmp(Ok(57), Ok(39), mod10cmp) == (-1)\n\n  Belt.Result.cmp(Ok(39), Error(\"y\"), mod10cmp) == 1\n\n  Belt.Result.cmp(Error(\"x\"), Ok(57), mod10cmp) == (-1)\n\n  Belt.Result.cmp(Error(\"x\"), Error(\"y\"), mod10cmp) == 0\n  ```"
        ],
        "signature": "let cmp: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => int) => int"
      }
    ]
  },
  "belt/option": {
    "id": "Belt.Option",
    "name": "Option",
    "docstrings": [
      "[`Belt.Option`]()\n\n  Utilities for option data type."
    ],
    "items": [
      {
        "id": "Belt.Option.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [
          "Uncurried version of `keep`"
        ],
        "signature": "let keepU: (option<'a>, (. 'a) => bool) => option<'a>"
      },
      {
        "id": "Belt.Option.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "If `optionValue` is `Some(value)` and `p(value) = true`, it returns `Some(value)`; otherwise returns `None`\n\n   ```rescript\n   Belt.Option.keep(Some(10), x => x > 5) /* returns `Some(10)` */\n   Belt.Option.keep(Some(4), x => x > 5) /* returns `None` */\n   Belt.Option.keep(None, x => x > 5) /* returns `None` */\n   ```"
        ],
        "signature": "let keep: (option<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.Option.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Uncurried version of `forEach`"
        ],
        "signature": "let forEachU: (option<'a>, (. 'a) => unit) => unit"
      },
      {
        "id": "Belt.Option.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "If `optionValue` is `Some(value`), it calls `f(value)`; otherwise returns `()`\n\n   ```rescript\n   Belt.Option.forEach(Some(\"thing\"), x => Js.log(x)) /* logs \"thing\" */\n   Belt.Option.forEach(None, x => Js.log(x)) /* returns () */\n   ```"
        ],
        "signature": "let forEach: (option<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.Option.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Raises an Error in case `None` is provided. Use with care.\n\n   ```rescript\n   Belt.Option.getExn(Some(3)) /* 3 */\n\n   Belt.Option.getExn(None) /* Raises an Error */\n   ```"
        ],
        "signature": "let getExn: option<'a> => 'a"
      },
      {
        "id": "Belt.Option.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(x)` returns `x`\n\n   This is an unsafe operation, it assumes `x` is neither `None`\n   nor `Some(None(...)))`"
        ],
        "signature": "let getUnsafe: option<'a> => 'a"
      },
      {
        "id": "Belt.Option.mapWithDefaultU",
        "kind": "value",
        "name": "mapWithDefaultU",
        "docstrings": [
          "Uncurried version of `mapWithDefault`"
        ],
        "signature": "let mapWithDefaultU: (option<'a>, 'b, (. 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.Option.mapWithDefault",
        "kind": "value",
        "name": "mapWithDefault",
        "docstrings": [
          "If `optionValue` is of `Some(value)`,\n   this function returns that value applied with `f`, in other words `f(value)`.\n\n   If `optionValue` is `None`, the default is returned.\n\n   ```rescript\n   let someValue = Some(3)\n   someValue->Belt.Option.mapWithDefault(0, x => x + 5) /* 8 */\n\n   let noneValue = None\n   noneValue->Belt.Option.mapWithDefault(0, x => x + 5) /* 0 */\n   ```"
        ],
        "signature": "let mapWithDefault: (option<'a>, 'b, 'a => 'b) => 'b"
      },
      {
        "id": "Belt.Option.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [
          "Uncurried version of `map`"
        ],
        "signature": "let mapU: (option<'a>, (. 'a) => 'b) => option<'b>"
      },
      {
        "id": "Belt.Option.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "If `optionValue` is `Some(value)` this returns `f(value)`, otherwise it returns `None`.\n\n   ```rescript\n   Belt.Option.map(Some(3), x => x * x) /* Some(9) */\n\n   Belt.Option.map(None, x => x * x) /* None */\n   ```"
        ],
        "signature": "let map: (option<'a>, 'a => 'b) => option<'b>"
      },
      {
        "id": "Belt.Option.flatMapU",
        "kind": "value",
        "name": "flatMapU",
        "docstrings": [
          "Uncurried version of `flatMap`"
        ],
        "signature": "let flatMapU: (option<'a>, (. 'a) => option<'b>) => option<'b>"
      },
      {
        "id": "Belt.Option.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "If `optionValue` is `Some(value)`, returns `f(value)`, otherwise returns\n   `None`.<br/>\n   The function `f` must have a return type of `option<'b>`.\n\n   ```rescript\n   let addIfAboveOne = value =>\n     if (value > 1) {\n       Some(value + 1)\n     } else {\n       None\n     }\n\n   Belt.Option.flatMap(Some(2), addIfAboveOne) /* Some(3) */\n\n   Belt.Option.flatMap(Some(-4), addIfAboveOne) /* None */\n\n   Belt.Option.flatMap(None, addIfAboveOne) /* None */\n   ```"
        ],
        "signature": "let flatMap: (option<'a>, 'a => option<'b>) => option<'b>"
      },
      {
        "id": "Belt.Option.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [
          "If `optionalValue` is `Some(value)`, returns `value`, otherwise default.\n\n   ```rescript\n   Belt.Option.getWithDefault(None, \"Banana\") /* Banana */\n\n   Belt.Option.getWithDefault(Some(\"Apple\"), \"Banana\") /* Apple */\n   ```\n\n   ```rescript\n   let greet = (firstName: option<string>) =>\n     \"Greetings \" ++ firstName->Belt.Option.getWithDefault(\"Anonymous\")\n\n   Some(\"Jane\")->greet /* \"Greetings Jane\" */\n\n   None->greet /* \"Greetings Anonymous\" */\n   ```"
        ],
        "signature": "let getWithDefault: (option<'a>, 'a) => 'a"
      },
      {
        "id": "Belt.Option.orElse",
        "kind": "value",
        "name": "orElse",
        "docstrings": [
          "`orElse optionalValue otherOptional`\n\n   If `optionalValue` is `Some value`, returns `Some value`, otherwise `otherOptional`\n\n   ```\n   orElse (Some 1812) (Some 1066) = Some 1812;;\n   orElse None (Some 1066) = Some 1066;;\n   orElse None None = None;;\n   ```"
        ],
        "signature": "let orElse: (option<'a>, option<'a>) => option<'a>"
      },
      {
        "id": "Belt.Option.isSome",
        "kind": "value",
        "name": "isSome",
        "docstrings": [
          "Returns `true` if the argument is `Some(value)`, `false` otherwise.\n\n   ```rescript\n   Belt.Option.isSome(None) /* false */\n\n   Belt.Option.isSome(Some(1)) /* true */\n   ```"
        ],
        "signature": "let isSome: option<'a> => bool"
      },
      {
        "id": "Belt.Option.isNone",
        "kind": "value",
        "name": "isNone",
        "docstrings": [
          "Returns `true` if the argument is `None`, `false` otherwise.\n\n   ```rescript\n   Belt.Option.isNone(None) /* true */\n\n   Belt.Option.isNone(Some(1)) /* false */\n   ```"
        ],
        "signature": "let isNone: option<'a> => bool"
      },
      {
        "id": "Belt.Option.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [
          "Uncurried version of `eq`"
        ],
        "signature": "let eqU: (option<'a>, option<'b>, (. 'a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Option.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Evaluates two optional values for equality with respect to a predicate\n   function. If both `optValue1` and `optValue2` are `None`, returns `true`.\n   If one of the arguments is `Some(value)` and the other is `None`, returns\n   `false`.\n\n   If arguments are `Some(value1)` and `Some(value2)`, returns the result of\n   `predicate(value1, value2)`; the predicate function must return a bool.\n\n   ```rescript\n   let clockEqual = (a, b) => mod(a, 12) == mod(b, 12)\n\n   open Belt.Option\n\n   eq(Some(3), Some(15), clockEqual) /* true */\n\n   eq(Some(3), None, clockEqual) /* false */\n\n   eq(None, Some(3), clockEqual) /* false */\n\n   eq(None, None, clockEqual) /* true */\n   ```"
        ],
        "signature": "let eq: (option<'a>, option<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Option.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [
          "Uncurried version of `cmp`"
        ],
        "signature": "let cmpU: (option<'a>, option<'b>, (. 'a, 'b) => int) => int"
      },
      {
        "id": "Belt.Option.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(optValue1, optValue2, comparisonFunction)` compares two optional values\n   with respect to given `comparisonFunction`.\n\n   If both `optValue1` and `optValue2` are `None`, it returns `0`.\n\n   If the first argument is `Some(value1)` and the second is `None`, returns `1`\n   (something is greater than nothing).\n\n   If the first argument is `None` and the second is `Some(value2)`, returns `-1`\n   (nothing is less than something).\n\n   If the arguments are `Some(value1)` and `Some(value2)`, returns the result of\n   `comparisonFunction(value1, value2)`; comparisonFunction takes two arguments\n   and returns `-1` if the first argument is less than the second, `0` if the\n   arguments are equal, and `1` if the first argument is greater than the second.\n\n   ```rescript\n   let clockCompare = (a, b) => compare(mod(a, 12), mod(b, 12))\n\n   open Belt.Option\n\n   cmp(Some(3), Some(15), clockCompare) /* 0 */\n\n   cmp(Some(3), Some(14), clockCompare) /* 1 */\n\n   cmp(Some(2), Some(15), clockCompare) /* (-1) */\n\n   cmp(None, Some(15), clockCompare) /* (-1) */\n\n   cmp(Some(14), None, clockCompare) /* 1 */\n\n   cmp(None, None, clockCompare) /* 0 */\n   ```"
        ],
        "signature": "let cmp: (option<'a>, option<'b>, ('a, 'b) => int) => int"
      }
    ]
  },
  "belt/hashmap": {
    "id": "Belt.HashMap",
    "name": "HashMap",
    "docstrings": [
      "[`Belt.HashMap`]()\n\n  The top level provides generic **mutable** hash map operations.\n\n  It also has two specialized inner modules\n  [`Belt.HashMap.Int`]() and [`Belt.HashMap.String`]()"
    ],
    "items": [
      {
        "id": "Belt.HashMap.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of hash tables from type `'key` to type `'value`."
        ],
        "signature": "type t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.HashMap.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The identity needed for making an empty hash map."
        ],
        "signature": "type id<'a, 'id> = Belt_Id.hashable<'a, 'id>"
      },
      {
        "id": "Belt.HashMap.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(~hintSize=10, ~id)` creates a new map by taking in the comparator and `hintSize`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n\n  Belt.HashMap.set(hMap, 0, \"a\")\n  ```"
        ],
        "signature": "let make: (~hintSize: int, ~id: id<'key, 'id>) => t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.HashMap.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "Clears a hash table.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let hMap = Belt.HashMap.fromArray([(1, \"1\")], ~id=module(IntHash))\n  Belt.HashMap.clear(hMap)\n  Belt.HashMap.isEmpty(hMap) == true\n  ```"
        ],
        "signature": "let clear: t<'key, 'value, 'id> => unit"
      },
      {
        "id": "Belt.HashMap.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "`isEmpty(m)` checks whether a hash map is empty.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  Belt.HashMap.isEmpty(Belt.HashMap.fromArray([(1, \"1\")], ~id=module(IntHash))) == false\n  ```"
        ],
        "signature": "let isEmpty: t<'a, 'b, 'c> => bool"
      },
      {
        "id": "Belt.HashMap.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(hMap, k, v)` if `k` does not exist, add the binding `k,v`, otherwise, update the old value with the new `v`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntHash))\n\n  Belt.HashMap.set(s0, 2, \"3\")\n\n  Belt.HashMap.valuesToArray(s0) == [\"1\", \"3\", \"3\"]\n  ```"
        ],
        "signature": "let set: (t<'key, 'value, 'id>, 'key, 'value) => unit"
      },
      {
        "id": "Belt.HashMap.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "Creates copy of a hash map.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntHash))\n  let s1 = Belt.HashMap.copy(s0)\n\n  Belt.HashMap.set(s0, 2, \"3\")\n\n  Belt.HashMap.get(s0, 2) != Belt.HashMap.get(s1, 2)\n  ```"
        ],
        "signature": "let copy: t<'key, 'value, 'id> => t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.HashMap.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns value bound under specific key. If values not exist returns `None`.\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\n\nBelt.HashMap.get(s0, 1) == Some(\"value1\")\nBelt.HashMap.get(s0, 2) == None\n```"
        ],
        "signature": "let get: (t<'key, 'value, 'id>, 'key) => option<'value>"
      },
      {
        "id": "Belt.HashMap.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks if `x` is bound in `tbl`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n\n  Belt.HashMap.has(s0, 1) == true\n  Belt.HashMap.has(s0, 2) == false\n  ```"
        ],
        "signature": "let has: (t<'key, 'value, 'id>, 'key) => bool"
      },
      {
        "id": "Belt.HashMap.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "If bound exists, removes it from the hash map.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.remove(s0, 1)\n  Belt.HashMap.has(s0, 1) == false\n  ```"
        ],
        "signature": "let remove: (t<'key, 'value, 'id>, 'key) => unit"
      },
      {
        "id": "Belt.HashMap.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Same as [forEach](#forEach) but takes uncurried function."
        ],
        "signature": "let forEachU: (t<'key, 'value, 'id>, (. 'key, 'value) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(tbl, f)` applies `f` to all bindings in table `tbl`. `f` receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to `f`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.forEach(s0, (key, value) => Js.log2(key, value))\n  // prints (1, \"value1\")\n  ```"
        ],
        "signature": "let forEach: (t<'key, 'value, 'id>, ('key, 'value) => unit) => unit"
      },
      {
        "id": "Belt.HashMap.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'key, 'value, 'id>, 'c, (. 'c, 'key, 'value) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(tbl, init, f)` computes `(f(kN, dN) ... (f(k1, d1, init))...)`, where `k1 ... kN` are the keys of all bindings in `tbl`, and `d1 ... dN` are the associated values. Each binding is presented exactly once to `f`.\n\n  The order in which the bindings are passed to `f` is unspecified. However, if the table contains several bindings for the same key, they are passed to `f` in reverse order of introduction, that is, the most recent binding is passed first.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.reduce(s0, \"\", (acc, key, value) => acc ++ (\", \" ++ value)) == \"value1, value2\"\n  ```"
        ],
        "signature": "let reduce: (t<'key, 'value, 'id>, 'c, ('c, 'key, 'value) => 'c) => 'c"
      },
      {
        "id": "Belt.HashMap.keepMapInPlaceU",
        "kind": "value",
        "name": "keepMapInPlaceU",
        "docstrings": [
          "Same as [keepMapInPlace](#keepMapInPlace) but takes uncurried function."
        ],
        "signature": "let keepMapInPlaceU: (t<'key, 'value, 'id>, (. 'key, 'value) => option<'value>) => unit"
      },
      {
        "id": "Belt.HashMap.keepMapInPlace",
        "kind": "value",
        "name": "keepMapInPlace",
        "docstrings": [
          "Filters out values for which function `f` returned `None`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.keepMapInPlace(s0, (key, value) => key == 1 ? None : Some(value))\n  ```"
        ],
        "signature": "let keepMapInPlace: (t<'key, 'value, 'id>, ('key, 'value) => option<'value>) => unit"
      },
      {
        "id": "Belt.HashMap.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "`size(tbl)` returns the number of bindings in `tbl`. It takes constant time.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.size(s0) == 2\n  ```"
        ],
        "signature": "let size: t<'a, 'b, 'c> => int"
      },
      {
        "id": "Belt.HashMap.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Returns array of key value pairs.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.toArray(s0) == [(1, \"value1\"), (2, \"value2\")]\n  ```"
        ],
        "signature": "let toArray: t<'key, 'value, 'id> => array<('key, 'value)>"
      },
      {
        "id": "Belt.HashMap.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [
          "Returns array of keys.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.keysToArray(s0) == [1, 2]\n  ```"
        ],
        "signature": "let keysToArray: t<'key, 'a, 'b> => array<'key>"
      },
      {
        "id": "Belt.HashMap.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [
          "Returns array of values.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.valuesToArray(s0) == [\"value1\", \"value2\"]\n  ```"
        ],
        "signature": "let valuesToArray: t<'a, 'value, 'b> => array<'value>"
      },
      {
        "id": "Belt.HashMap.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Creates new hash map from array of pairs.\n\nReturns array of values.\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.fromArray([(1, \"value1\"), (2, \"value2\")], ~id=module(IntHash))\nBelt.HashMap.toArray(s0) == [(1, \"value1\"), (2, \"value2\")]\n```"
        ],
        "signature": "let fromArray: (array<('key, 'value)>, ~id: id<'key, 'id>) => t<'key, 'value, 'id>"
      },
      {
        "id": "Belt.HashMap.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.mergeMany(hMap, [(1, \"1\"), (2, \"2\")])\n```"
        ],
        "signature": "let mergeMany: (t<'key, 'value, 'id>, array<('key, 'value)>) => unit"
      },
      {
        "id": "Belt.HashMap.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [
          "```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n  let hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(hMap, 1, \"1\")\n\n  Belt.HashMap.getBucketHistogram(hMap)\n  ```"
        ],
        "signature": "let getBucketHistogram: t<'a, 'b, 'c> => array<int>"
      },
      {
        "id": "Belt.HashMap.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [
          "```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n  let hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(hMap, 1, \"1\")\n\n  Belt.HashMap.logStats(hMap)\n  ```"
        ],
        "signature": "let logStats: t<'a, 'b, 'c> => unit"
      }
    ]
  },
  "belt/hashset": {
    "id": "Belt.HashSet",
    "name": "HashSet",
    "docstrings": [
      "[`Belt.HashSet`]()\n\n  The top level provides generic **mutable** hash set operations.\n\n  It also has two specialized inner modules\n  [`Belt.HashSet.Int`]() and [`Belt.HashSet.String`]()"
    ],
    "items": [
      {
        "id": "Belt.HashSet.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The type of hash tables from type `'a` to type `'b`."
        ],
        "signature": "type id<'a, 'id> = Belt_Id.hashable<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~hintSize: int, ~id: id<'a, 'id>) => t<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'a, 'id> => unit"
      },
      {
        "id": "Belt.HashSet.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.HashSet.add",
        "kind": "value",
        "name": "add",
        "docstrings": [],
        "signature": "let add: (t<'a, 'id>, 'a) => unit"
      },
      {
        "id": "Belt.HashSet.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [],
        "signature": "let copy: t<'a, 'id> => t<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'a, 'id>, 'a) => bool"
      },
      {
        "id": "Belt.HashSet.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [],
        "signature": "let remove: (t<'a, 'id>, 'a) => unit"
      },
      {
        "id": "Belt.HashSet.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a, 'id>, (. 'a) => unit) => unit"
      },
      {
        "id": "Belt.HashSet.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Order unspecified."
        ],
        "signature": "let forEach: (t<'a, 'id>, 'a => unit) => unit"
      },
      {
        "id": "Belt.HashSet.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'a, 'id>, 'c, (. 'c, 'a) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Order unspecified."
        ],
        "signature": "let reduce: (t<'a, 'id>, 'c, ('c, 'a) => 'c) => 'c"
      },
      {
        "id": "Belt.HashSet.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a, 'id> => int"
      },
      {
        "id": "Belt.HashSet.logStats",
        "kind": "value",
        "name": "logStats",
        "docstrings": [],
        "signature": "let logStats: t<'a, 'b> => unit"
      },
      {
        "id": "Belt.HashSet.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'a, 'id> => array<'a>"
      },
      {
        "id": "Belt.HashSet.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: (array<'a>, ~id: id<'a, 'id>) => t<'a, 'id>"
      },
      {
        "id": "Belt.HashSet.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'a, 'id>, array<'a>) => unit"
      },
      {
        "id": "Belt.HashSet.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "docstrings": [],
        "signature": "let getBucketHistogram: t<'a, 'b> => array<int>"
      }
    ]
  },
  "belt/mutablemap": {
    "id": "Belt.MutableMap",
    "name": "MutableMap",
    "docstrings": [
      "[`Belt.MutableMap`]()\n\n  The top level provides generic **mutable** map operations.\n\n  It also has two specialized inner modules\n  [`Belt.MutableMap.Int`]() and [`Belt.MutableMap.String`]()"
    ],
    "items": [
      {
        "id": "Belt.MutableMap.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.MutableMap.id",
        "kind": "type",
        "name": "id",
        "docstrings": [],
        "signature": "type id<'key, 'id> = Belt_Id.comparable<'key, 'id>"
      },
      {
        "id": "Belt.MutableMap.make",
        "kind": "value",
        "name": "make",
        "docstrings": [],
        "signature": "let make: (~id: id<'k, 'id>) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.MutableMap.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [],
        "signature": "let clear: t<'a, 'b, 'c> => unit"
      },
      {
        "id": "Belt.MutableMap.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a, 'b, 'c> => bool"
      },
      {
        "id": "Belt.MutableMap.has",
        "kind": "value",
        "name": "has",
        "docstrings": [],
        "signature": "let has: (t<'k, 'a, 'b>, 'k) => bool"
      },
      {
        "id": "Belt.MutableMap.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(m1, m2, cmp)` First compare by size, if size is the same, compare by\n    key, value pair."
        ],
        "signature": "let cmp: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.MutableMap.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, (. 'a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2, eqf)` tests whether the maps `m1` and `m2` are equal, that is,\n    contain equal keys and associate them with equal data. `eqf` is the\n    equality predicate used to compare the data associated with the keys."
        ],
        "signature": "let eq: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'k, 'a, 'id>, (. 'k, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies f to all bindings in map `m`. `f` receives the `'k`\n    as first argument, and the associated value as second argument. The\n    bindings are passed to `f` in increasing order with respect to the ordering\n    over the type of the keys."
        ],
        "signature": "let forEach: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableMap.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'k, 'a, 'id>, 'b, (. 'b, 'k, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f), computes`(f(kN, dN) ... (f(k1, d1, a))...)`, where`k1 ...\n    kN`are the keys of all bindings in`m`(in increasing order), and`d1 ... dN`\n    are the associated data."
        ],
        "signature": "let reduce: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableMap.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate\n    `p`."
        ],
        "signature": "let every: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the\n    predicate `p`."
        ],
        "signature": "let some: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool"
      },
      {
        "id": "Belt.MutableMap.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'k, 'a, 'id> => int"
      },
      {
        "id": "Belt.MutableMap.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order."
        ],
        "signature": "let toList: t<'k, 'a, 'id> => list<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [],
        "signature": "let toArray: t<'k, 'a, 'id> => array<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [],
        "signature": "let fromArray: (array<('k, 'a)>, ~id: id<'k, 'id>) => t<'k, 'a, 'id>"
      },
      {
        "id": "Belt.MutableMap.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [],
        "signature": "let keysToArray: t<'k, 'a, 'b> => array<'k>"
      },
      {
        "id": "Belt.MutableMap.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [],
        "signature": "let valuesToArray: t<'a, 'a0, 'b> => array<'a0>"
      },
      {
        "id": "Belt.MutableMap.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [],
        "signature": "let minKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.MutableMap.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [],
        "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.MutableMap.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [],
        "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.MutableMap.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [],
        "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.MutableMap.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [],
        "signature": "let minimum: t<'k, 'a, 'b> => option<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [],
        "signature": "let minUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [],
        "signature": "let maximum: t<'k, 'a, 'b> => option<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [],
        "signature": "let maxUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>"
      },
      {
        "id": "Belt.MutableMap.get",
        "kind": "value",
        "name": "get",
        "docstrings": [],
        "signature": "let get: (t<'k, 'a, 'id>, 'k) => option<'a>"
      },
      {
        "id": "Belt.MutableMap.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [],
        "signature": "let getUndefined: (t<'k, 'a, 'id>, 'k) => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableMap.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [],
        "signature": "let getWithDefault: (t<'k, 'a, 'id>, 'k, 'a) => 'a"
      },
      {
        "id": "Belt.MutableMap.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [],
        "signature": "let getExn: (t<'k, 'a, 'id>, 'k) => 'a"
      },
      {
        "id": "Belt.MutableMap.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "Raise when invariant is not held."
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit"
      },
      {
        "id": "Belt.MutableMap.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` do the in-place modification."
        ],
        "signature": "let remove: (t<'k, 'a, 'id>, 'k) => unit"
      },
      {
        "id": "Belt.MutableMap.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [],
        "signature": "let removeMany: (t<'k, 'a, 'id>, array<'k>) => unit"
      },
      {
        "id": "Belt.MutableMap.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` do the in-place modification"
        ],
        "signature": "let set: (t<'k, 'a, 'id>, 'k, 'a) => unit"
      },
      {
        "id": "Belt.MutableMap.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'k, 'a, 'id>, 'k, (. option<'a>) => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.update",
        "kind": "value",
        "name": "update",
        "docstrings": [],
        "signature": "let update: (t<'k, 'a, 'id>, 'k, option<'a> => option<'a>) => unit"
      },
      {
        "id": "Belt.MutableMap.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [],
        "signature": "let mergeMany: (t<'k, 'a, 'id>, array<('k, 'a)>) => unit"
      },
      {
        "id": "Belt.MutableMap.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'k, 'a, 'id>, (. 'a) => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.MutableMap.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f)` returns a map with same domain as `m`, where the associated\n    value a of all bindings of `m` has been replaced by the result of the\n    application of `f` to `a`. The bindings are passed to `f` in increasing\n    order with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.MutableMap.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'k, 'a, 'id>, (. 'k, 'a) => 'b) => t<'k, 'b, 'id>"
      },
      {
        "id": "Belt.MutableMap.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [],
        "signature": "let mapWithKey: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>"
      }
    ]
  },
  "belt/mutableset": {
    "id": "Belt.MutableSet",
    "name": "MutableSet",
    "docstrings": [
      "[`Belt.MutableSet`]()\n\n  The top level provides generic **mutable** set operations.\n\n  It also has two specialized inner modules\n  [`Belt.MutableSet.Int`]() and [`Belt.MutableSet.String`]()"
    ],
    "items": [
      {
        "id": "Belt.MutableSet.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'value` is the element type\n\n  `'identity` the identity of the collection"
        ],
        "signature": "type t<'value, 'identity>"
      },
      {
        "id": "Belt.MutableSet.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The identity needed for making a set from scratch"
        ],
        "signature": "type id<'value, 'id> = Belt_Id.comparable<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new set by taking in the comparator"
        ],
        "signature": "let make: (~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Creates new set from array of elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.toArray /* [1, 2, 3, 4] */\n  ```"
        ],
        "signature": "let fromArray: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [
          "The same as [fromArray][#fromarray] except it is after assuming the input array is already sorted."
        ],
        "signature": "let fromSortedArrayUnsafe: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "Returns copy of a set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\n  let copied = s0->Belt.MutableSet.copy\n  copied->Belt.MutableSet.toArray /* [1, 2, 3, 4] */\n  ```"
        ],
        "signature": "let copy: t<'value, 'id> => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "Checks if set is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let empty = Belt.MutableSet.fromArray([], ~id=module(IntCmp))\n  let notEmpty = Belt.MutableSet.fromArray([1], ~id=module(IntCmp))\n\n  Belt.MutableSet.isEmpty(empty) /* true */\n  Belt.MutableSet.isEmpty(notEmpty) /* false */\n  ```"
        ],
        "signature": "let isEmpty: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.MutableSet.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks if element exists in set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.MutableSet.fromArray([1, 4, 2, 5], ~id=module(IntCmp))\n\n  set->Belt.MutableSet.has(3) /* false */\n  set->Belt.MutableSet.has(1) /* true */\n  ```"
        ],
        "signature": "let has: (t<'value, 'id>, 'value) => bool"
      },
      {
        "id": "Belt.MutableSet.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds element to set. If element existed in set, value is unchanged.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  s0->Belt.MutableSet.add(1)\n  s0->Belt.MutableSet.add(2)\n  s0->Belt.MutableSet.add(2)\n\n  s0->Belt.MutableSet.toArray /* [1, 2] */\n  ```"
        ],
        "signature": "let add: (t<'value, 'id>, 'value) => unit"
      },
      {
        "id": "Belt.MutableSet.addCheck",
        "kind": "value",
        "name": "addCheck",
        "docstrings": [],
        "signature": "let addCheck: (t<'value, 'id>, 'value) => bool"
      },
      {
        "id": "Belt.MutableSet.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "Adds each element of array to set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.MutableSet.make(~id=module(IntCmp))\n\n  set->Belt.MutableSet.mergeMany([5, 4, 3, 2, 1])\n  set->Belt.MutableSet.toArray /* [1, 2, 3, 4, 5] */\n  ```"
        ],
        "signature": "let mergeMany: (t<'value, 'id>, array<'value>) => unit"
      },
      {
        "id": "Belt.MutableSet.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "Removes element from set. If element did not exist in set, value is unchanged.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([2, 3, 1, 4, 5], ~id=module(IntCmp))\n  s0->Belt.MutableSet.remove(1)\n  s0->Belt.MutableSet.remove(3)\n  s0->Belt.MutableSet.remove(3)\n\n  s0->Belt.MutableSet.toArray /* [2,4,5] */\n  ```"
        ],
        "signature": "let remove: (t<'value, 'id>, 'value) => unit"
      },
      {
        "id": "Belt.MutableSet.removeCheck",
        "kind": "value",
        "name": "removeCheck",
        "docstrings": [],
        "signature": "let removeCheck: (t<'value, 'id>, 'value) => bool"
      },
      {
        "id": "Belt.MutableSet.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [
          "Removes each element of array from set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.MutableSet.fromArray([1, 2, 3, 4], ~id=module(IntCmp))\n\n  set->Belt.MutableSet.removeMany([5, 4, 3, 2, 1])\n  set->Belt.MutableSet.toArray /* [] */\n  ```"
        ],
        "signature": "let removeMany: (t<'value, 'id>, array<'value>) => unit"
      },
      {
        "id": "Belt.MutableSet.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "Returns union of two sets.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\n  let union = Belt.MutableSet.union(s0, s1)\n  union->Belt.MutableSet.toArray /* [1,2,3,4,5,6] */\n  ```"
        ],
        "signature": "let union: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [
          "Returns intersection of two sets.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\n  let intersect = Belt.MutableSet.intersect(s0, s1)\n  intersect->Belt.MutableSet.toArray /* [2,3,5] */\n  ```"
        ],
        "signature": "let intersect: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [
          "Returns elements from first set, not existing in second set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\n  Belt.MutableSet.toArray(Belt.MutableSet.diff(s0, s1)) /* [6] */\n  Belt.MutableSet.toArray(Belt.MutableSet.diff(s1, s0)) /* [1,4] */\n  ```"
        ],
        "signature": "let diff: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "Checks if second set is subset of first set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\n  let s2 = Belt.MutableSet.intersect(s0, s1)\n  Belt.MutableSet.subset(s2, s0) /* true */\n  Belt.MutableSet.subset(s2, s1) /* true */\n  Belt.MutableSet.subset(s1, s0) /* false */\n  ```"
        ],
        "signature": "let subset: (t<'value, 'id>, t<'value, 'id>) => bool"
      },
      {
        "id": "Belt.MutableSet.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compares size first and then iterates over each element following the order of elements."
        ],
        "signature": "let cmp: (t<'value, 'id>, t<'value, 'id>) => int"
      },
      {
        "id": "Belt.MutableSet.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Checks if two sets are equal.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 5], ~id=module(IntCmp))\n\n  Belt.MutableSet.eq(s0, s1) /* true */\n  ```"
        ],
        "signature": "let eq: (t<'value, 'id>, t<'value, 'id>) => bool"
      },
      {
        "id": "Belt.MutableSet.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Same as [forEach](##forEach) but takes uncurried functon."
        ],
        "signature": "let forEachU: (t<'value, 'id>, (. 'value) => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Applies function `f` in turn to all elements of set in increasing order.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let acc = ref(list{})\n  s0->Belt.MutableSet.forEach(x => acc := Belt.List.add(acc.contents, x))\n  acc /* [6,5,3,2] */\n  ```"
        ],
        "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.MutableSet.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'value, 'id>, 'a, (. 'a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an “accumulator”, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  s0->Belt.MutableSet.reduce(list{}, (acc, element) => acc->Belt.List.add(element)) /* [6,5,3,2] */\n  ```"
        ],
        "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.MutableSet.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'value, 'id>, (. 'value) => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.MutableSet.fromArray([2, 4, 6, 8], ~id=module(IntCmp))\n  s0->Belt.MutableSet.every(isEven) /* true */\n  ```"
        ],
        "signature": "let every: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'value, 'id>, (. 'value) => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "Checks if at least one element of the set satisfies the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 4, 6, 8], ~id=module(IntCmp))\n  s0->Belt.MutableSet.some(isOdd) /* true */\n  ```"
        ],
        "signature": "let some: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.MutableSet.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'value, 'id>, (. 'value) => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "Returns the set of all elements that satisfy the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n  let s1 = s0->Belt.MutableSet.keep(isEven)\n\n  s1->Belt.MutableSet.toArray /* [2, 4] */\n  ```"
        ],
        "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.MutableSet.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'value, 'id>, (. 'value) => bool) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.MutableSet.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n  let (s1, s2) = s0->Belt.MutableSet.partition(isOdd)\n\n  s1->Belt.MutableSet.toArray /* [1,3,5] */\n  s2->Belt.MutableSet.toArray /* [2,4] */\n  ```"
        ],
        "signature": "let partition: (t<'value, 'id>, 'value => bool) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.MutableSet.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns size of the set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.size /* 4 */\n  ```"
        ],
        "signature": "let size: t<'value, 'id> => int"
      },
      {
        "id": "Belt.MutableSet.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "Returns list of ordered set elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.toList /* [1,2,3,5] */\n  ```"
        ],
        "signature": "let toList: t<'value, 'id> => list<'value>"
      },
      {
        "id": "Belt.MutableSet.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Returns array of ordered set elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.toArray /* [1,2,3,5] */\n  ```"
        ],
        "signature": "let toArray: t<'value, 'id> => array<'value>"
      },
      {
        "id": "Belt.MutableSet.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [
          "Returns minimum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.minimum /* None */\n  s1->Belt.MutableSet.minimum /* Some(1) */\n  ```"
        ],
        "signature": "let minimum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.MutableSet.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [
          "Returns minimum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.minUndefined /* undefined */\n  s1->Belt.MutableSet.minUndefined /* 1 */\n  ```"
        ],
        "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.MutableSet.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [
          "Returns maximum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.maximum /* None */\n  s1->Belt.MutableSet.maximum /* Some(5) */\n  ```"
        ],
        "signature": "let maximum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.MutableSet.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [
          "Returns maximum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.maxUndefined /* undefined */\n  s1->Belt.MutableSet.maxUndefined /* 5 */\n  ```"
        ],
        "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.MutableSet.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.get(3) /* Some(3) */\n  s0->Belt.MutableSet.get(20) /* None */\n  ```"
        ],
        "signature": "let get: (t<'value, 'id>, 'value) => option<'value>"
      },
      {
        "id": "Belt.MutableSet.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "Same as [get](#get) but returns `undefined` when element does not exist."
        ],
        "signature": "let getUndefined: (t<'value, 'id>, 'value) => Js.undefined<'value>"
      },
      {
        "id": "Belt.MutableSet.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Same as [get](#get) but raise when element does not exist."
        ],
        "signature": "let getExn: (t<'value, 'id>, 'value) => 'value"
      },
      {
        "id": "Belt.MutableSet.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n\n  let ((smaller, larger), present) = s0->Belt.MutableSet.split(3)\n\n  present /* true */\n  smaller->Belt.MutableSet.toArray /* [1,2] */\n  larger->Belt.MutableSet.toArray /* [4,5] */\n  ```"
        ],
        "signature": "let split: (t<'value, 'id>, 'value) => ((t<'value, 'id>, t<'value, 'id>), bool)"
      },
      {
        "id": "Belt.MutableSet.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b> => unit"
      }
    ]
  },
  "belt/map": {
    "id": "Belt.Map",
    "name": "Map",
    "docstrings": [
      "[`Belt.Map`](),\n\n  The top level provides generic **immutable** map operations.\n\n  It also has three specialized inner modules\n  [`Belt.Map.Int`](), [`Belt.Map.String`]() and\n\n  [`Belt.Map.Dict`](): This module separates data from function\n  which  is more verbose but slightly more efficient"
    ],
    "items": [
      {
        "id": "Belt.Map.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'key` is the field type\n\n`'value` is the element type\n\n`'identity` the identity of the collection"
        ],
        "signature": "type t<'key, 'value, 'identity>"
      },
      {
        "id": "Belt.Map.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The identity needed for making an empty map."
        ],
        "signature": "type id<'key, 'id> = Belt_Id.comparable<'key, 'id>"
      },
      {
        "id": "Belt.Map.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(~id)` creates a new map by taking in the comparator.\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nlet m = Belt.Map.make(~id=module(IntCmp))\n\nBelt.Map.set(m, 0, \"a\")\n```"
        ],
        "signature": "let make: (~id: id<'k, 'id>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "`isEmpty(m)` checks whether a map m is empty.\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.isEmpty(Belt.Map.fromArray([(1, \"1\")], ~id=module(IntCmp))) == false\n```"
        ],
        "signature": "let isEmpty: t<'a, 'b, 'c> => bool"
      },
      {
        "id": "Belt.Map.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "`has(m, k)` checks whether `m` has the key `k`.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.has(Belt.Map.fromArray([(1, \"1\")], ~id=module(IntCmp)), 1) == true\n    ```"
        ],
        "signature": "let has: (t<'k, 'v, 'id>, 'k) => bool"
      },
      {
        "id": "Belt.Map.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, (. 'v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(m0, m1, vcmp);`\n\n    Total ordering of map given total ordering of value function.\n\n    It will compare size first and each element following the order one by one."
        ],
        "signature": "let cmp: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => int) => int"
      },
      {
        "id": "Belt.Map.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, (. 'v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(m1, m2, veq)` tests whether the maps `m1` and `m2` are equal, that is,\n    contain equal keys and associate them with equal data. `veq` is the\n    equality predicate used to compare the data associated with the keys."
        ],
        "signature": "let eq: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "docstrings": [],
        "signature": "let findFirstByU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "docstrings": [
          "`findFirstBy(m, p)` uses function `f` to find the first key value pair to\n    match predicate `p`.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"\")])\n\n    Belt.Map.findFirstBy(s0, (k, v) => k == 4) /* (4, \"4\") */\n    ```"
        ],
        "signature": "let findFirstBy: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'k, 'v, 'id>, (. 'k, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the\n    `'k` as first argument, and the associated value as second argument. The\n    bindings are passed to `f` in increasing order with respect to the ordering\n    over the type of the keys.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"\")])\n\n    let acc = ref(list{})\n\n    Belt.Map.forEach(s0, (k, v) => acc := list{(k, v), ...acc.contents})\n\n    acc.contents == list{(4, \"4\"), (3, \"3\"), (2, \"2\"), (1, \"1\")}\n    ```"
        ],
        "signature": "let forEach: (t<'k, 'v, 'id>, ('k, 'v) => unit) => unit"
      },
      {
        "id": "Belt.Map.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'k, 'v, 'id>, 'acc, (. 'acc, 'k, 'v) => 'acc) => 'acc"
      },
      {
        "id": "Belt.Map.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(m, a, f)` computes `(f(kN, dN) ... (f(k1, d1, a))...)`, where `k1\n    ... kN` are the keys of all bindings in m (in increasing order), and `d1\n    ... dN` are the associated data.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"3\")])\n\n    Belt.Map.reduce(s0, list{}, (acc, k, v) => list{\n      (k, v),\n      ...acc,\n    }) /* [(4, \"4\"), (3, \"3\"), (2, \"2\"), (1, \"1\"), 0] */\n    ```"
        ],
        "signature": "let reduce: (t<'k, 'v, 'id>, 'acc, ('acc, 'k, 'v) => 'acc) => 'acc"
      },
      {
        "id": "Belt.Map.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(m, p)` checks if all the bindings of the map satisfy the predicate\n    `p`. Order unspecified"
        ],
        "signature": "let every: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(m, p)` checks if at least one binding of the map satisfy the\n    predicate `p`. Order unspecified"
        ],
        "signature": "let some: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool"
      },
      {
        "id": "Belt.Map.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "`size(s)`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.size(Belt.Map.fromArray([(2, \"2\"), (2, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == 2\n    ```"
        ],
        "signature": "let size: t<'k, 'v, 'id> => int"
      },
      {
        "id": "Belt.Map.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "`toArray(s)`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.toArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        (1, \"1\"),\n        (2, \"2\"),\n        (3, \"3\"),\n      ]\n    ```"
        ],
        "signature": "let toArray: t<'k, 'v, 'id> => array<('k, 'v)>"
      },
      {
        "id": "Belt.Map.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "In increasing order.\n\n    See `Belt.Map.toArray`"
        ],
        "signature": "let toList: t<'k, 'v, 'id> => list<('k, 'v)>"
      },
      {
        "id": "Belt.Map.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray(kvs, ~id);`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.toArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        (1, \"1\"),\n        (2, \"2\"),\n        (3, \"3\"),\n      ]\n    ```"
        ],
        "signature": "let fromArray: (array<('k, 'v)>, ~id: id<'k, 'id>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "docstrings": [
          "`keysToArray(s);`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.keysToArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        1,\n        2,\n        3,\n      ]\n    ```"
        ],
        "signature": "let keysToArray: t<'k, 'v, 'id> => array<'k>"
      },
      {
        "id": "Belt.Map.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "docstrings": [
          "`valuesToArray(s);`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.valuesToArray(\n      Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)),\n    ) == [\"1\", \"2\", \"3\"]\n    ```"
        ],
        "signature": "let valuesToArray: t<'k, 'v, 'id> => array<'v>"
      },
      {
        "id": "Belt.Map.minKey",
        "kind": "value",
        "name": "minKey",
        "docstrings": [
          "`minKey(s)` returns the minimum key, None if not exist."
        ],
        "signature": "let minKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.Map.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "docstrings": [
          "See `Belt.Map.minKey`"
        ],
        "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.Map.maxKey",
        "kind": "value",
        "name": "maxKey",
        "docstrings": [
          "`maxKey(s)` returns the maximum key, None if not exist."
        ],
        "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>"
      },
      {
        "id": "Belt.Map.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "docstrings": [
          "See `Belt.Map.maxKey`"
        ],
        "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>"
      },
      {
        "id": "Belt.Map.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [
          "`minimum(s)` returns the minimum key value pair, None if not exist."
        ],
        "signature": "let minimum: t<'k, 'v, 'a> => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [
          "See `Belt.Map.minimum`"
        ],
        "signature": "let minUndefined: t<'k, 'v, 'a> => Js.undefined<('k, 'v)>"
      },
      {
        "id": "Belt.Map.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [
          "`maximum(s)` returns the maximum key value pair, None if not exist."
        ],
        "signature": "let maximum: t<'k, 'v, 'a> => option<('k, 'v)>"
      },
      {
        "id": "Belt.Map.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [
          "See `Belt.Map.maximum`"
        ],
        "signature": "let maxUndefined: t<'k, 'v, 'a> => Js.undefined<('k, 'v)>"
      },
      {
        "id": "Belt.Map.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "`get(s, k)`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.get(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)), 2) ==\n      Some(\"2\")\n\n    Belt.Map.get(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)), 2) == None\n    ```"
        ],
        "signature": "let get: (t<'k, 'v, 'id>, 'k) => option<'v>"
      },
      {
        "id": "Belt.Map.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "See `Belt.Map.get`\n\n    Returns `undefined` when not found"
        ],
        "signature": "let getUndefined: (t<'k, 'v, 'id>, 'k) => Js.undefined<'v>"
      },
      {
        "id": "Belt.Map.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "docstrings": [
          "`getWithDefault(s, k, default)`\n\n    See `Belt.Map.get`\n\n    Returns default when `k` is not found."
        ],
        "signature": "let getWithDefault: (t<'k, 'v, 'id>, 'k, 'v) => 'v"
      },
      {
        "id": "Belt.Map.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "`getExn(s, k)`\n\n    See `Belt.Map.getExn`\n\n    raise when `k` not exist"
        ],
        "signature": "let getExn: (t<'k, 'v, 'id>, 'k) => 'v"
      },
      {
        "id": "Belt.Map.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "`remove(m, x)` when `x` is not in `m`, `m` is returned reference unchanged.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))\n\n    let s1 = Belt.Map.remove(s0, 1)\n\n    let s2 = Belt.Map.remove(s1, 1)\n\n    s1 === s2\n\n    Belt.Map.keysToArray(s1) == [2, 3]\n    ```"
        ],
        "signature": "let remove: (t<'k, 'v, 'id>, 'k) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [
          "`removeMany(s, xs)`\n\n    Removing each of `xs` to `s`, note unlike `Belt.Map.remove`, the reference\n    of return value might be changed even if none in `xs` exists `s`."
        ],
        "signature": "let removeMany: (t<'k, 'v, 'id>, array<'k>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(m, x, y)` returns a map containing the same bindings as `m`, with a\n    new binding of `x` to `y`. If `x` was already bound in `m`, its previous\n    binding disappears.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))\n\n    let s1 = Belt.Map.set(s0, 2, \"3\")\n\n    Belt.Map.valuesToArray(s1) == [\"1\", \"3\", \"3\"]\n    ```"
        ],
        "signature": "let set: (t<'k, 'v, 'id>, 'k, 'v) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.updateU",
        "kind": "value",
        "name": "updateU",
        "docstrings": [],
        "signature": "let updateU: (t<'k, 'v, 'id>, 'k, (. option<'v>) => option<'v>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.update",
        "kind": "value",
        "name": "update",
        "docstrings": [
          "`update(m, x, f)` returns a map containing the same bindings as `m`, except\n    for the binding of `x`. Depending on the value of `y` where `y` is\n    `f(get(m, x))`, the binding of `x` is added, removed or updated. If `y` is\n    `None`, the binding is removed if it exists; otherwise, if `y` is `Some(z)`\n    then `x` is associated to `z` in the resulting map."
        ],
        "signature": "let update: (t<'k, 'v, 'id>, 'k, option<'v> => option<'v>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "`mergeMany(s, xs)`\n\n    Adding each of `xs` to `s`, note unlike `add`, the reference of return\n    value might be changed even if all values in `xs` exist `s`."
        ],
        "signature": "let mergeMany: (t<'k, 'v, 'id>, array<('k, 'v)>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.mergeU",
        "kind": "value",
        "name": "mergeU",
        "docstrings": [],
        "signature": "let mergeU: (\\n  t<'k, 'v, 'id>,\\n  t<'k, 'v2, 'id>,\\n  (. 'k, option<'v>, option<'v2>) => option<'v3>,\\n) => t<'k, 'v3, 'id>"
      },
      {
        "id": "Belt.Map.merge",
        "kind": "value",
        "name": "merge",
        "docstrings": [
          "`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\n    and of `m2`. The presence of each such binding, and the corresponding\n    value, is determined with the function `f`."
        ],
        "signature": "let merge: (\\n  t<'k, 'v, 'id>,\\n  t<'k, 'v2, 'id>,\\n  ('k, option<'v>, option<'v2>) => option<'v3>,\\n) => t<'k, 'v3, 'id>"
      },
      {
        "id": "Belt.Map.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(m, p)` returns the map with all the bindings in m that satisfy\n    predicate `p`."
        ],
        "signature": "let keep: (t<'k, 'v, 'id>, ('k, 'v) => bool) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => (t<'k, 'v, 'id>, t<'k, 'v, 'id>)"
      },
      {
        "id": "Belt.Map.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains\n    all the bindings of `s` that satisfy the predicate `p`, and `m2` is the map\n    with all the bindings of `s` that do not satisfy `p`."
        ],
        "signature": "let partition: (t<'k, 'v, 'id>, ('k, 'v) => bool) => (t<'k, 'v, 'id>, t<'k, 'v, 'id>)"
      },
      {
        "id": "Belt.Map.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "`split(x, m)` returns a tuple `(l, r)`, data, where `l` is the map with all\n    the bindings of `m` whose 'k is strictly less than `x`; `r` is the map with\n    all the bindings of m whose 'k is strictly greater than `x`; `data` is\n    `None` if `m` contains no binding for `x`, or `Some(v)` if `m` binds `v` to\n    `x`."
        ],
        "signature": "let split: (t<'k, 'v, 'id>, 'k) => ((t<'k, 'v, 'id>, t<'k, 'v, 'id>), option<'v>)"
      },
      {
        "id": "Belt.Map.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'k, 'v, 'id>, (. 'v) => 'v2) => t<'k, 'v2, 'id>"
      },
      {
        "id": "Belt.Map.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(m, f) returns a map with same domain as`m`, where the associated\n    value`a`of all bindings of`m`has been replaced by the result of the\n    application of`f`to`a`. The bindings are passed to`f` in increasing order\n    with respect to the ordering over the type of the keys."
        ],
        "signature": "let map: (t<'k, 'v, 'id>, 'v => 'v2) => t<'k, 'v2, 'id>"
      },
      {
        "id": "Belt.Map.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "docstrings": [],
        "signature": "let mapWithKeyU: (t<'k, 'v, 'id>, (. 'k, 'v) => 'v2) => t<'k, 'v2, 'id>"
      },
      {
        "id": "Belt.Map.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "docstrings": [
          "`mapWithKey(m, f)`\n\n    The same as `Belt.Map.map` except that `f` is supplied with one more\n    argument: the key."
        ],
        "signature": "let mapWithKey: (t<'k, 'v, 'id>, ('k, 'v) => 'v2) => t<'k, 'v2, 'id>"
      },
      {
        "id": "Belt.Map.getData",
        "kind": "value",
        "name": "getData",
        "docstrings": [
          "`getData(s0)`\n\n    Advanced usage only\n\n    Returns the raw data (detached from comparator), but its type is still\n    manifested, so that user can pass identity directly without boxing."
        ],
        "signature": "let getData: t<'k, 'v, 'id> => Belt_MapDict.t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.getId",
        "kind": "value",
        "name": "getId",
        "docstrings": [
          "Advanced usage only\n\n    Returns the identity of s0."
        ],
        "signature": "let getId: t<'k, 'v, 'id> => id<'k, 'id>"
      },
      {
        "id": "Belt.Map.packIdData",
        "kind": "value",
        "name": "packIdData",
        "docstrings": [
          "`packIdData(~id, ~data)`\n\n    Advanced usage only\n\n    Returns the packed collection."
        ],
        "signature": "let packIdData: (~id: id<'k, 'id>, ~data: Belt_MapDict.t<'k, 'v, 'id>) => t<'k, 'v, 'id>"
      },
      {
        "id": "Belt.Map.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit"
      }
    ]
  },
  "belt/set": {
    "id": "Belt.Set",
    "name": "Set",
    "docstrings": [
      "[`Belt.Set`]()\n\n  The top level provides generic **immutable** set operations.\n\n  It also has three specialized inner modules\n  [`Belt.Set.Int`](), [`Belt.Set.String`]() and\n\n  [`Belt.Set.Dict`](): This module separates data from function\n  which is more verbose but slightly more efficient"
    ],
    "items": [
      {
        "id": "Belt.Set.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'value` is the element type\n\n  `'identity` the identity of the collection"
        ],
        "signature": "type t<'value, 'identity>"
      },
      {
        "id": "Belt.Set.id",
        "kind": "type",
        "name": "id",
        "docstrings": [
          "The identity needed for making a set from scratch"
        ],
        "signature": "type id<'value, 'id> = Belt_Id.comparable<'value, 'id>"
      },
      {
        "id": "Belt.Set.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Creates a new set by taking in the comparator\n\n  ```rescript\n  let set = Belt.Set.make(~id=module(IntCmp))\n  ```"
        ],
        "signature": "let make: (~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Creates new set from array of elements.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\n  s0->Belt.Set.toArray /* [1, 2, 3, 4] */\n  ```"
        ],
        "signature": "let fromArray: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "docstrings": [
          "The same as [fromArray][#fromarray] except it is after assuming the input array is already sorted."
        ],
        "signature": "let fromSortedArrayUnsafe: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "Checks if set is empty.\n\n   ```rescript\n   let empty = Belt.Set.fromArray([], ~id=module(IntCmp))\n   let notEmpty = Belt.Set.fromArray([1],~id=module(IntCmp))\n\n   Belt.Set.isEmpty(empty) /* true */\n   Belt.Set.isEmpty(notEmpty) /* false */\n   ```"
        ],
        "signature": "let isEmpty: t<'a, 'b> => bool"
      },
      {
        "id": "Belt.Set.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Checks if element exists in set.\n\n   ```rescript\n   let set = Belt.Set.fromArray([1, 4, 2, 5], ~id=module(IntCmp))\n\n   set->Belt.Set.has(3) /* false */\n   set->Belt.Set.has(1) /* true */\n   ```"
        ],
        "signature": "let has: (t<'value, 'id>, 'value) => bool"
      },
      {
        "id": "Belt.Set.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds element to set. If element existed in set, value is unchanged.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = s0->Belt.Set.add(1)\n  let s2 = s1->Belt.Set.add(2)\n  let s3 = s2->Belt.Set.add(2)\n  s0->Belt.Set.toArray /* [] */\n  s1->Belt.Set.toArray /* [1] */\n  s2->Belt.Set.toArray /* [1, 2] */\n  s3->Belt.Set.toArray /* [1,2 ] */\n  s2 == s3 /* true */\n  ```"
        ],
        "signature": "let add: (t<'value, 'id>, 'value) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "docstrings": [
          "Adds each element of array to set. Unlike [add](#add), the reference of return value might be changed even if all values in array already exist in set\n\n  ```rescript\n  let set = Belt.Set.make(~id=module(IntCmp))\n\n  let newSet = set->Belt.Set.mergeMany([5, 4, 3, 2, 1])\n  newSet->Belt.Set.toArray /* [1, 2, 3, 4, 5] */\n  ```"
        ],
        "signature": "let mergeMany: (t<'value, 'id>, array<'value>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.remove",
        "kind": "value",
        "name": "remove",
        "docstrings": [
          "Removes element from set. If element did not exist in set, value is unchanged.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([2,3,1,4,5], ~id=module(IntCmp))\n  let s1 = s0->Belt.Set.remove(1)\n  let s2 = s1->Belt.Set.remove(3)\n  let s3 = s2->Belt.Set.remove(3)\n\n  s1->Belt.Set.toArray /* [2,3,4,5] */\n  s2->Belt.Set.toArray /* [2,4,5] */\n  s2 == s3 /* true */\n  ```"
        ],
        "signature": "let remove: (t<'value, 'id>, 'value) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.removeMany",
        "kind": "value",
        "name": "removeMany",
        "docstrings": [
          "Removes each element of array from set. Unlike [remove](#remove), the reference of return value might be changed even if none of values in array existed in set.\n\n  ```rescript\n  let set = Belt.Set.fromArray([1, 2, 3, 4],~id=module(IntCmp))\n\n  let newSet = set->Belt.Set.removeMany([5, 4, 3, 2, 1])\n  newSet->Belt.Set.toArray /* [] */\n  ```"
        ],
        "signature": "let removeMany: (t<'value, 'id>, array<'value>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "Returns union of two sets.\n\n   ```rescript\n   let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n   let s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\n   let union = Belt.Set.union(s0, s1)\n   union->Belt.Set.toArray /* [1,2,3,4,5,6] */\n   ```"
        ],
        "signature": "let union: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [
          "Returns intersection of two sets.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\n  let intersect = Belt.Set.intersect(s0, s1)\n  intersect->Belt.Set.toArray /* [2,3,5] */\n  ```"
        ],
        "signature": "let intersect: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [
          "Returns elements from first set, not existing in second set.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\n  Belt.Set.toArray(Belt.Set.diff(s0, s1)) /* [6] */\n  Belt.Set.toArray(Belt.Set.diff(s1,s0)) /* [1,4] */\n  ```"
        ],
        "signature": "let diff: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.subset",
        "kind": "value",
        "name": "subset",
        "docstrings": [
          "Checks if second set is subset of first set.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\n  let s2 = Belt.Set.intersect(s0, s1)\n  Belt.Set.subset(s2, s0) /* true */\n  Belt.Set.subset(s2, s1) /* true */\n  Belt.Set.subset(s1, s0) /* false */\n  ```"
        ],
        "signature": "let subset: (t<'value, 'id>, t<'value, 'id>) => bool"
      },
      {
        "id": "Belt.Set.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compares size first and then iterates over each element following the order of elements."
        ],
        "signature": "let cmp: (t<'value, 'id>, t<'value, 'id>) => int"
      },
      {
        "id": "Belt.Set.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Checks if two sets are equal.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3], ~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,5], ~id=module(IntCmp))\n\n  Belt.Set.eq(s0, s1) /* true */\n  ```"
        ],
        "signature": "let eq: (t<'value, 'id>, t<'value, 'id>) => bool"
      },
      {
        "id": "Belt.Set.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Same as [forEach](##forEach) but takes uncurried functon."
        ],
        "signature": "let forEachU: (t<'value, 'id>, (. 'value) => unit) => unit"
      },
      {
        "id": "Belt.Set.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Applies function `f` in turn to all elements of set in increasing order.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  let acc = ref(list{})\n  s0->Belt.Set.forEach(x => {\n    acc := Belt.List.add(acc.contents, x)\n  })\n  acc /* [6,5,3,2] */\n  ```"
        ],
        "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit"
      },
      {
        "id": "Belt.Set.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'value, 'id>, 'a, (. 'a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an “accumulator”, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  s0->Belt.Set.reduce(list{}, (acc, element) =>\n    acc->Belt.List.add(element)\n  ) /* [6,5,3,2] */\n  ```"
        ],
        "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a"
      },
      {
        "id": "Belt.Set.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'value, 'id>, (. 'value) => bool) => bool"
      },
      {
        "id": "Belt.Set.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.Set.fromArray([2,4,6,8], ~id=module(IntCmp))\n  s0->Belt.Set.every(isEven) /* true */\n  ```"
        ],
        "signature": "let every: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'value, 'id>, (. 'value) => bool) => bool"
      },
      {
        "id": "Belt.Set.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "Checks if at least one element of the set satisfies the predicate.\n\n  ```rescript\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.Set.fromArray([1,2,4,6,8], ~id=module(IntCmp))\n  s0->Belt.Set.some(isOdd) /* true */\n  ```"
        ],
        "signature": "let some: (t<'value, 'id>, 'value => bool) => bool"
      },
      {
        "id": "Belt.Set.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'value, 'id>, (. 'value) => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "Returns the set of all elements that satisfy the predicate.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n  let s1 = s0->Belt.Set.keep(isEven)\n\n  s1->Belt.Set.toArray /* [2,4] */\n  ```"
        ],
        "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>"
      },
      {
        "id": "Belt.Set.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'value, 'id>, (. 'value) => bool) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.Set.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "Returns a pair of sets, where first is the set of all the elements of set that satisfy the predicate, and second is the set of all the elements of set that do not satisfy the predicate.\n\n  ```rescript\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n  let (s1, s2) = s0->Belt.Set.partition(isOdd)\n\n  s1->Belt.Set.toArray /* [1,3,5] */\n  s2->Belt.Set.toArray /* [2,4] */\n  ```"
        ],
        "signature": "let partition: (t<'value, 'id>, 'value => bool) => (t<'value, 'id>, t<'value, 'id>)"
      },
      {
        "id": "Belt.Set.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns size of the set.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([1,2,3,4], ~id=module(IntCmp))\n\n  s0->Belt.Set.size /* 4 */\n  ```"
        ],
        "signature": "let size: t<'value, 'id> => int"
      },
      {
        "id": "Belt.Set.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Returns array of ordered set elements.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.toArray /* [1,2,3,5] */\n  ```"
        ],
        "signature": "let toArray: t<'value, 'id> => array<'value>"
      },
      {
        "id": "Belt.Set.toList",
        "kind": "value",
        "name": "toList",
        "docstrings": [
          "Returns list of ordered set elements.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.toList /* [1,2,3,5] */\n  ```"
        ],
        "signature": "let toList: t<'value, 'id> => list<'value>"
      },
      {
        "id": "Belt.Set.minimum",
        "kind": "value",
        "name": "minimum",
        "docstrings": [
          "Returns minimum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.minimum /* None */\n  s1->Belt.Set.minimum /* Some(1) */\n  ```"
        ],
        "signature": "let minimum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.Set.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "docstrings": [
          "Returns minimum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.minUndefined /* undefined */\n  s1->Belt.Set.minUndefined /* 1 */\n  ```"
        ],
        "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.maximum",
        "kind": "value",
        "name": "maximum",
        "docstrings": [
          "Returns maximum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.maximum /* None */\n  s1->Belt.Set.maximum /* Some(5) */\n  ```"
        ],
        "signature": "let maximum: t<'value, 'id> => option<'value>"
      },
      {
        "id": "Belt.Set.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "docstrings": [
          "Returns maximum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.maxUndefined /* undefined */\n  s1->Belt.Set.maxUndefined /* 5 */\n  ```"
        ],
        "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.get(3) /* Some(3) */\n  s0->Belt.Set.get(20) /* None */\n  ```"
        ],
        "signature": "let get: (t<'value, 'id>, 'value) => option<'value>"
      },
      {
        "id": "Belt.Set.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "Same as [get](#get) but returns `undefined` when element does not exist."
        ],
        "signature": "let getUndefined: (t<'value, 'id>, 'value) => Js.undefined<'value>"
      },
      {
        "id": "Belt.Set.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Same as [get](#get) but raise when element does not exist."
        ],
        "signature": "let getExn: (t<'value, 'id>, 'value) => 'value"
      },
      {
        "id": "Belt.Set.split",
        "kind": "value",
        "name": "split",
        "docstrings": [
          "Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n\n  let ((smaller, larger), present) = s0->Belt.Set.split(3)\n\n  present /* true */\n  smaller->Belt.Set.toArray /* [1,2] */\n  larger->Belt.Set.toArray /* [4,5] */\n\n  ```"
        ],
        "signature": "let split: (t<'value, 'id>, 'value) => ((t<'value, 'id>, t<'value, 'id>), bool)"
      },
      {
        "id": "Belt.Set.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "docstrings": [
          "**raise** when invariant is not held"
        ],
        "signature": "let checkInvariantInternal: t<'a, 'b> => unit"
      },
      {
        "id": "Belt.Set.getData",
        "kind": "value",
        "name": "getData",
        "docstrings": [
          "**Advanced usage only**\n\n  Returns the raw data (detached from comparator), but its type is still manifested, so that user can pass identity directly without boxing."
        ],
        "signature": "let getData: t<'value, 'id> => Belt_SetDict.t<'value, 'id>"
      },
      {
        "id": "Belt.Set.getId",
        "kind": "value",
        "name": "getId",
        "docstrings": [
          "**Advanced usage only**\n\n  Returns the identity of set."
        ],
        "signature": "let getId: t<'value, 'id> => id<'value, 'id>"
      },
      {
        "id": "Belt.Set.packIdData",
        "kind": "value",
        "name": "packIdData",
        "docstrings": [
          "**Advanced usage only**\n\n  Returns the packed collection."
        ],
        "signature": "let packIdData: (~id: id<'value, 'id>, ~data: Belt_SetDict.t<'value, 'id>) => t<'value, 'id>"
      }
    ]
  },
  "belt/range": {
    "id": "Belt.Range",
    "name": "Range",
    "docstrings": [
      "[`Belt.Range`]()\n\n  Utilities for a closed range `(from, start)`"
    ],
    "items": [
      {
        "id": "Belt.Range.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (int, int, (. int) => unit) => unit"
      },
      {
        "id": "Belt.Range.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(start, finish, action)`\n\n  equivalent to `Belt.Array.(forEach(range(start, finish), action))`\n\n  ```rescript\n  Belt.Range.forEach(0, 4, (i) => Js.log(i))\n\n  /**\n   * prints:\n   *   0\n   *   1\n   *   2\n   *   3\n   *   4\n   */\n  ```"
        ],
        "signature": "let forEach: (int, int, int => unit) => unit"
      },
      {
        "id": "Belt.Range.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (int, int, (. int) => bool) => bool"
      },
      {
        "id": "Belt.Range.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(start, finish, p)`\n\n  equivalent to `Belt.Array.(every(range(start, finish), p))`\n\n  ```rescript\n  Belt.Range.every(0, 4, (i) => i < 5) /* true */\n\n  Belt.Range.every(0, 4, (i) => i < 4) /* false */\n  ```"
        ],
        "signature": "let every: (int, int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.everyByU",
        "kind": "value",
        "name": "everyByU",
        "docstrings": [],
        "signature": "let everyByU: (int, int, ~step: int, (. int) => bool) => bool"
      },
      {
        "id": "Belt.Range.everyBy",
        "kind": "value",
        "name": "everyBy",
        "docstrings": [
          "`everyBy(start, finish, ~step, p)`\n\n  See `Belt_Array.rangeBy`\n\n  equivalent to `Belt.Array.(every(rangeBy(start, finish, ~step), p))`\n\n  ```rescript\n  Belt.Range.everyBy(0, 4, ~step=1, (i) => mod(i, 2) === 0) /* false */\n\n  Belt.Range.everyBy(0, 4, ~step=2, (i) => mod(i, 2) === 0) /* true */\n  ```"
        ],
        "signature": "let everyBy: (int, int, ~step: int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (int, int, (. int) => bool) => bool"
      },
      {
        "id": "Belt.Range.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(start, finish, p)`\n\n  equivalent to `Belt.Array.(some(range(start, finish), p))`\n\n  ```rescript\n  Belt.Range.some(0, 4, (i) => i > 5) /* false */\n\n  Belt.Range.some(0, 4, (i) => i > 2) /* true */\n  ```"
        ],
        "signature": "let some: (int, int, int => bool) => bool"
      },
      {
        "id": "Belt.Range.someByU",
        "kind": "value",
        "name": "someByU",
        "docstrings": [],
        "signature": "let someByU: (int, int, ~step: int, (. int) => bool) => bool"
      },
      {
        "id": "Belt.Range.someBy",
        "kind": "value",
        "name": "someBy",
        "docstrings": [
          "`someBy(start, finish, ~step, p)`\n\n  See `Belt_Array.rangeBy`\n\n  equivalent to `Belt.Array.(some(rangeBy(start, finish, ~step), p))`\n\n  ```rescript\n  Belt.Range.someBy(1, 5, ~step=2, (i) => mod(i, 2) === 0) /* false */\n  Belt.Range.someBy(0, 4, ~step=2, (i) => mod(i, 2) === 0) /* true */\n  ```"
        ],
        "signature": "let someBy: (int, int, ~step: int, int => bool) => bool"
      }
    ]
  },
  "belt/list": {
    "id": "Belt.List",
    "name": "List",
    "docstrings": [
      "[`Belt.List`]()\n\n  Utilities for List data type"
    ],
    "items": [
      {
        "id": "Belt.List.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "`'a t` is compatible with built-in `list` type"
        ],
        "signature": "type t<'a> = list<'a>"
      },
      {
        "id": "Belt.List.length",
        "kind": "value",
        "name": "length",
        "docstrings": [
          "Returns the length of a list.\n\n  ```rescript\n  Belt.List.length(list{1, 2, 3}) // 3\n  ```"
        ],
        "signature": "let length: t<'a> => int"
      },
      {
        "id": "Belt.List.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "**See** [`length`](##length)"
        ],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.List.head",
        "kind": "value",
        "name": "head",
        "docstrings": [
          "Returns `Some(value)` where `value` is the first element in the list, or\n  `None` if `someList` is an empty list.\n\n  ```rescript\n  Belt.List.head(list{}) // None\n  Belt.List.head(list{1, 2, 3}) // Some(1)\n  ```"
        ],
        "signature": "let head: t<'a> => option<'a>"
      },
      {
        "id": "Belt.List.headExn",
        "kind": "value",
        "name": "headExn",
        "docstrings": [
          "Same as [head](#head), but raises an exception if `someList` is empty. Use\n  with care.\n\n  ```rescript\n  Belt.List.headExn(list{1, 2, 3}) // 1\n\n  Belt.List.headExn(list{}) // Raises an Error\n  ```"
        ],
        "signature": "let headExn: t<'a> => 'a"
      },
      {
        "id": "Belt.List.tail",
        "kind": "value",
        "name": "tail",
        "docstrings": [
          "Returns `None` if `someList` is empty, otherwise it returns `Some(tail)`\n  where `tail` is everything except the first element of `someList`.\n\n  ```rescript\n  Belt.List.tail(list{1, 2, 3}) // Some(list{2, 3})\n\n  Belt.List.tail(list{}) // None\n  ```"
        ],
        "signature": "let tail: t<'a> => option<t<'a>>"
      },
      {
        "id": "Belt.List.tailExn",
        "kind": "value",
        "name": "tailExn",
        "docstrings": [
          "Same as [tail](#tail), but raises an exception if `someList` is empty. Use\n  with care.\n\n  ```rescript\n  Belt.List.tailExn(list{1, 2, 3}) // list{2, 3}\n\n  Belt.List.tailExn(list{}) // Raises an Error\n  ```"
        ],
        "signature": "let tailExn: t<'a> => t<'a>"
      },
      {
        "id": "Belt.List.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "Adds `value` to the beginning of `someList`.\n\n  ```rescript\n  Belt.List.add(list{2, 3}, 1) // list{1, 2, 3}\n\n  Belt.List.add(list{\"World\", \"!\"}, \"Hello\") // list{\"Hello\", \"World\", \"!\"}\n  ```"
        ],
        "signature": "let add: (t<'a>, 'a) => t<'a>"
      },
      {
        "id": "Belt.List.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "Return the nth element in `someList`, or `None` if `index` is larger than the\n  length.\n\n  ```rescript\n  let abc = list{\"A\", \"B\", \"C\"}\n\n  abc->Belt.List.get(1) // Some(\"B\")\n\n  abc->Belt.List.get(4) // None\n  ```"
        ],
        "signature": "let get: (t<'a>, int) => option<'a>"
      },
      {
        "id": "Belt.List.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Same as [get](#get), but raises an exception if `index` is larger than the\n  length. Use with care.\n\n  ```rescript\n  let abc = list{\"A\", \"B\", \"C\"}\n\n  abc->Belt.List.getExn(1) // \"B\"\n\n  abc->Belt.List.getExn(4) // Raises an Error\n  ```"
        ],
        "signature": "let getExn: (t<'a>, int) => 'a"
      },
      {
        "id": "Belt.List.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Returns a list of length `numItems` with each element filled with value `v`. Returns an empty list if `numItems` is negative.\n\n  ```rescript\n  Belt.List.make(3, 1) // list{1, 1, 1}\n  ```"
        ],
        "signature": "let make: (int, 'a) => t<'a>"
      },
      {
        "id": "Belt.List.makeByU",
        "kind": "value",
        "name": "makeByU",
        "docstrings": [
          "Uncurried version of [makeBy](#makeBy)"
        ],
        "signature": "let makeByU: (int, (. int) => 'a) => t<'a>"
      },
      {
        "id": "Belt.List.makeBy",
        "kind": "value",
        "name": "makeBy",
        "docstrings": [
          "Return a list of length `numItems` with element `i` initialized with `f(i)`.\nReturns an empty list if `numItems` is negative.\n\n```rescript\nBelt.List.makeBy(5, i => i) // list{0, 1, 2, 3, 4}\n\nBelt.List.makeBy(5, i => i * i) // list{0, 1, 4, 9, 16}\n```"
        ],
        "signature": "let makeBy: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.List.shuffle",
        "kind": "value",
        "name": "shuffle",
        "docstrings": [
          "Returns a new list in random order.\n\n  ```rescript\n  Belt.List.shuffle(list{1, 2, 3}) // list{2, 1, 3}\n  ```"
        ],
        "signature": "let shuffle: t<'a> => t<'a>"
      },
      {
        "id": "Belt.List.drop",
        "kind": "value",
        "name": "drop",
        "docstrings": [
          "Return a new list, dropping the first `n` elements. Returns `None` if `someList` has fewer than `n` elements.\n\n  ```rescript\n  list{1, 2, 3}->Belt.List.drop(2) // Some(list{3})\n\n  list{1, 2, 3}->Belt.List.drop(3) // Some(list{})\n\n  list{1, 2, 3}->Belt.List.drop(4) // None\n  ```"
        ],
        "signature": "let drop: (t<'a>, int) => option<t<'a>>"
      },
      {
        "id": "Belt.List.take",
        "kind": "value",
        "name": "take",
        "docstrings": [
          "Returns a list with the first `n` elements from `someList`, or `None` if `someList` has fewer than `n` elements.\n\n```rescript\nlist{1, 2, 3}->Belt.List.take(1) // Some(list{1})\n\nlist{1, 2, 3}->Belt.List.take(2) // Some(list{1, 2})\n\nlist{1, 2, 3}->Belt.List.take(4) // None\n```"
        ],
        "signature": "let take: (t<'a>, int) => option<t<'a>>"
      },
      {
        "id": "Belt.List.splitAt",
        "kind": "value",
        "name": "splitAt",
        "docstrings": [
          "Split the list `someList` at `index`. Returns `None` when the length of `someList` is less than `index`.\n\n  ```rescript\n  list{\"Hello\", \"World\"}->Belt.List.splitAt(1) // Some((list{\"Hello\"}, list{\"World\"}))\n\n  list{0, 1, 2, 3, 4}->Belt.List.splitAt(2) // Some((list{0, 1}, list{2, 3, 4}))\n  ```"
        ],
        "signature": "let splitAt: (t<'a>, int) => option<(list<'a>, list<'a>)>"
      },
      {
        "id": "Belt.List.concat",
        "kind": "value",
        "name": "concat",
        "docstrings": [
          "Returns the list obtained by adding `secondList` after `firstList`.\n\n  ```rescript\n  Belt.List.concat(list{1, 2, 3}, list{4, 5}) // list{1, 2, 3, 4, 5}\n  ```"
        ],
        "signature": "let concat: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Belt.List.concatMany",
        "kind": "value",
        "name": "concatMany",
        "docstrings": [
          "Returns the list obtained by concatenating all the lists in array `a`, in\n  order.\n\n  ```rescript\n  Belt.List.concatMany([list{1, 2, 3}, list{}, list{3}]) // list{1, 2, 3, 3}\n  ```"
        ],
        "signature": "let concatMany: array<t<'a>> => t<'a>"
      },
      {
        "id": "Belt.List.reverseConcat",
        "kind": "value",
        "name": "reverseConcat",
        "docstrings": [
          "Equivalent to writing: `concat(reverse(firstList, secondList)`\n\n  ```rescript\n  Belt.List.reverseConcat(list{1, 2}, list{3, 4}) // list{2, 1, 3, 4}\n  ```"
        ],
        "signature": "let reverseConcat: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Belt.List.flatten",
        "kind": "value",
        "name": "flatten",
        "docstrings": [
          "Return the list obtained by concatenating all the lists in list `ls`, in order.\n\n  ```rescript\n  Belt.List.flatten(list{list{1, 2, 3}, list{}, list{3}}) // list{1, 2, 3, 3}\n  ```"
        ],
        "signature": "let flatten: t<t<'a>> => t<'a>"
      },
      {
        "id": "Belt.List.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [
          "Uncurried version of [map](#map)."
        ],
        "signature": "let mapU: (t<'a>, (. 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "Returns a new list with `f` applied to each element of `someList`.\n\n  ```rescript\n  list{1, 2}->Belt.List.map(x => x + 1) // list{3, 4}\n  ```"
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.zip",
        "kind": "value",
        "name": "zip",
        "docstrings": [
          "Returns a list of pairs from the two lists with the length of the shorter list.\n\n  ```rescript\n  Belt.List.zip(list{1, 2}, list{3, 4, 5}) // list{(1, 3), (2, 4)}\n  ```"
        ],
        "signature": "let zip: (t<'a>, t<'b>) => t<('a, 'b)>"
      },
      {
        "id": "Belt.List.zipByU",
        "kind": "value",
        "name": "zipByU",
        "docstrings": [
          "Uncurried version of [zipBy](#zipBy)."
        ],
        "signature": "let zipByU: (t<'a>, t<'b>, (. 'a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Belt.List.zipBy",
        "kind": "value",
        "name": "zipBy",
        "docstrings": [
          "**See:** [zip](#zip)\n\n  ```rescript\n  Belt.List.zipBy(list{1, 2, 3}, list{4, 5}, (a, b) => 2 * a + b) // list{6, 9}\n  ```"
        ],
        "signature": "let zipBy: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Belt.List.mapWithIndexU",
        "kind": "value",
        "name": "mapWithIndexU",
        "docstrings": [
          "Uncurried version of [mapWithIndex](#mapWithIndex)."
        ],
        "signature": "let mapWithIndexU: (t<'a>, (. int, 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.mapWithIndex",
        "kind": "value",
        "name": "mapWithIndex",
        "docstrings": [
          "Applies `f` to each element of `someList`.\n  Function `f` takes two arguments: the index starting from 0 and the element from `someList`, in that order.\n\n  ```rescript\n  list{1, 2, 3}->Belt.List.mapWithIndex((index, x) => index + x) // list{1, 3, 5}\n  ```"
        ],
        "signature": "let mapWithIndex: (t<'a>, (int, 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "Converts the given array to a list.\n\n  ```rescript\n  Belt.List.fromArray([1, 2, 3]) // list{1, 2, 3}\n  ```"
        ],
        "signature": "let fromArray: array<'a> => t<'a>"
      },
      {
        "id": "Belt.List.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "Converts the given list to an array.\n\n  ```rescript\n  Belt.List.toArray(list{1, 2, 3}) // [1, 2, 3]\n  ```"
        ],
        "signature": "let toArray: t<'a> => array<'a>"
      },
      {
        "id": "Belt.List.reverse",
        "kind": "value",
        "name": "reverse",
        "docstrings": [
          "Returns a new list whose elements are those of `someList` in reversed order.\n\n  ```rescript\n  Belt.List.reverse(list{1, 2, 3}) /* list{3, 2, 1} */\n  ```"
        ],
        "signature": "let reverse: t<'a> => t<'a>"
      },
      {
        "id": "Belt.List.mapReverseU",
        "kind": "value",
        "name": "mapReverseU",
        "docstrings": [
          "Uncurried version of [mapReverse](#mapReverse)."
        ],
        "signature": "let mapReverseU: (t<'a>, (. 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.mapReverse",
        "kind": "value",
        "name": "mapReverse",
        "docstrings": [
          "Equivalent to:\n\n  ```res\n  map(someList, f)->reverse\n  ```\n\n  ```rescript\n  list{3, 4, 5}->Belt.List.mapReverse(x => x * x) /* list{25, 16, 9} */\n  ```"
        ],
        "signature": "let mapReverse: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.List.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [
          "Uncurried version of [forEach](#forEach)."
        ],
        "signature": "let forEachU: (t<'a>, (. 'a) => 'b) => unit"
      },
      {
        "id": "Belt.List.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "Call `f` on each element of `someList` from the beginning to end.\n  `f` returns `unit`, so no new array is created. Use `forEach` when you are primarily concerned with repetitively creating side effects.\n\n  ```rescript\n  Belt.List.forEach(list{\"a\", \"b\", \"c\"}, x => Js.log(\"Item: \" ++ x))\n  /*\n    prints:\n    Item: a\n    Item: b\n    Item: c\n  */\n  ```"
        ],
        "signature": "let forEach: (t<'a>, 'a => 'b) => unit"
      },
      {
        "id": "Belt.List.forEachWithIndexU",
        "kind": "value",
        "name": "forEachWithIndexU",
        "docstrings": [
          "Uncurried version of [forEachWithIndex](#forEachWithIndex)."
        ],
        "signature": "let forEachWithIndexU: (t<'a>, (. int, 'a) => 'b) => unit"
      },
      {
        "id": "Belt.List.forEachWithIndex",
        "kind": "value",
        "name": "forEachWithIndex",
        "docstrings": [
          "Call `f` on each element of `someList` from beginning to end.\n  Function `f` takes two arguments: the index starting from 0 and the element from `someList`. `f` returns `unit`.\n\n  ```rescript\n  Belt.List.forEachWithIndex(list{\"a\", \"b\", \"c\"}, (index, x) => {\n    Js.log(\"Item \" ++ Belt.Int.toString(index) ++ \" is \" ++ x)\n  })\n  /*\n    prints:\n    Item 0 is a\n    Item 1 is b\n    Item 2 is cc\n  */\n  ```"
        ],
        "signature": "let forEachWithIndex: (t<'a>, (int, 'a) => 'b) => unit"
      },
      {
        "id": "Belt.List.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [
          "Uncurried version of [reduce](#reduce)."
        ],
        "signature": "let reduceU: (t<'a>, 'b, (. 'b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "Applies `f` to each element of `someList` from beginning to end. Function `f` has two parameters: the item from the list and an “accumulator”, which starts with a value of `initialValue`. reduce returns the final value of the accumulator.\n\n  ```rescript\n  list{1, 2, 3, 4}->Belt.List.reduce(0, (a, b) => a + b) /* 10 */\n\n  /* same as */\n\n  list{1, 2, 3, 4}->Belt.List.reduce(0, (acc, item) => acc + item) /* 10 */\n  ```"
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduceWithIndexU",
        "kind": "value",
        "name": "reduceWithIndexU",
        "docstrings": [
          "Uncurried version of [reduceWithIndex](#reduceWithIndex)."
        ],
        "signature": "let reduceWithIndexU: (t<'a>, 'b, (. 'b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduceWithIndex",
        "kind": "value",
        "name": "reduceWithIndex",
        "docstrings": [
          "Applies `f` to each element of `someList` from beginning to end. Function `f` has three parameters: the item from the list and an “accumulator”, which starts with a value of `initialValue` and the index of each element. `reduceWithIndex` returns the final value of the accumulator.\n\n  ```rescript\n  list{1, 2, 3, 4}->Belt.List.reduceWithIndex(0, (acc, item, index) => acc + item + index) /* 16 */\n  ```"
        ],
        "signature": "let reduceWithIndex: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduceReverseU",
        "kind": "value",
        "name": "reduceReverseU",
        "docstrings": [
          "Uncurried version of [reduceReverse](#reduceReverse)."
        ],
        "signature": "let reduceReverseU: (t<'a>, 'b, (. 'b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.List.reduceReverse",
        "kind": "value",
        "name": "reduceReverse",
        "docstrings": [
          "Works like [reduce](#reduce), except that function `f` is applied to each\n  item of `someList` from the last back to the first.\n\n  ```rescript\n  list{1, 2, 3, 4}->Belt.List.reduceReverse(0, (a, b) => a + b) /* 10 */\n\n  list{1, 2, 3, 4}->Belt.List.reduceReverse(10, (a, b) => a - b) /* 0 */\n\n  list{1, 2, 3, 4}->Belt.List.reduceReverse(list{}, Belt.List.add) // list{1, 2, 3, 4}\n  ```"
        ],
        "signature": "let reduceReverse: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.List.mapReverse2U",
        "kind": "value",
        "name": "mapReverse2U",
        "docstrings": [
          "Uncurried version of [mapReverse2](#mapReverse2)."
        ],
        "signature": "let mapReverse2U: (t<'a>, t<'b>, (. 'a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Belt.List.mapReverse2",
        "kind": "value",
        "name": "mapReverse2",
        "docstrings": [
          "Equivalent to: `zipBy(xs, ys, f)->reverse`\n\n  ```rescript\n\n  Belt.List.mapReverse2(list{1, 2, 3}, list{1, 2}, (a, b) => a + b) // list{4, 2}\n  ```"
        ],
        "signature": "let mapReverse2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>"
      },
      {
        "id": "Belt.List.forEach2U",
        "kind": "value",
        "name": "forEach2U",
        "docstrings": [
          "Uncurried version of [forEach2](#forEach2)."
        ],
        "signature": "let forEach2U: (t<'a>, t<'b>, (. 'a, 'b) => 'c) => unit"
      },
      {
        "id": "Belt.List.forEach2",
        "kind": "value",
        "name": "forEach2",
        "docstrings": [
          "Stops at the length of the shorter list.\n\n  ```rescript\n  Belt.List.forEach2(list{\"Z\", \"Y\"}, list{\"A\", \"B\", \"C\"}, (x, y) => Js.log2(x, y))\n\n  /*\n    prints:\n    \"Z\" \"A\"\n    \"Y\" \"B\"\n  */\n  ```"
        ],
        "signature": "let forEach2: (t<'a>, t<'b>, ('a, 'b) => 'c) => unit"
      },
      {
        "id": "Belt.List.reduce2U",
        "kind": "value",
        "name": "reduce2U",
        "docstrings": [
          "Uncurried version of [reduce2](#reduce2)."
        ],
        "signature": "let reduce2U: (t<'b>, t<'c>, 'a, (. 'a, 'b, 'c) => 'a) => 'a"
      },
      {
        "id": "Belt.List.reduce2",
        "kind": "value",
        "name": "reduce2",
        "docstrings": [
          "Applies `f` to each element of `firstList` and `secondList` from beginning to end. Stops with the shorter list. Function `f` has three parameters: an “accumulator” which starts with a value of `initialValue`, an item from `firstList`, and an item from `secondList`. `reduce2` returns the final value of the accumulator.\n\n  ```rescript\n  Belt.List.reduce2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) /* 0 + (1 * 1 + 4) + (2 * 2 + 5) */\n  ```"
        ],
        "signature": "let reduce2: (t<'b>, t<'c>, 'a, ('a, 'b, 'c) => 'a) => 'a"
      },
      {
        "id": "Belt.List.reduceReverse2U",
        "kind": "value",
        "name": "reduceReverse2U",
        "docstrings": [
          "Uncurried version of [reduceReverse2](#reduceReverse2)."
        ],
        "signature": "let reduceReverse2U: (t<'a>, t<'b>, 'c, (. 'c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.List.reduceReverse2",
        "kind": "value",
        "name": "reduceReverse2",
        "docstrings": [
          "Applies `f` to each element of `firstList` and `secondList` from end to\n  beginning. Stops with the shorter list. Function `f` has three parameters: an\n  “accumulator” which starts with a value of init, an item from `firstList`,\n  and an item from `secondList`. `reduce2` returns the final value of the\n  accumulator.\n\n  ```rescript\n  Belt.List.reduceReverse2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) /*  + (1 * 1 + 4) + (2 * 2 + 5) */\n  ```"
        ],
        "signature": "let reduceReverse2: (t<'a>, t<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.List.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [
          "Uncurried version of [every](#every)."
        ],
        "signature": "let everyU: (t<'a>, (. 'a) => bool) => bool"
      },
      {
        "id": "Belt.List.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "Returns `true` if all elements satisfy `pred`, where `pred` is a predicate: a function taking an element and returning a bool.\n\n  ```rescript\n  let isBelow10 = value => value < 10\n\n  list{1, 9, 8, 2}->Belt.List.every(isBelow10) /* true */\n\n  list{1, 99, 8, 2}->Belt.List.every(isBelow10) /* false */\n  ```"
        ],
        "signature": "let every: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.List.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [
          "Uncurried version of [some](#some)."
        ],
        "signature": "let someU: (t<'a>, (. 'a) => bool) => bool"
      },
      {
        "id": "Belt.List.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "Returns `true` if at least _one_ of the elements in `someList` satisfies\n  `pred`, where `pred` is a predicate: a function taking an element and\n  returning a bool.\n\n  ```rescript\n  let isAbove100 = value => value > 100\n\n  list{101, 1, 2, 3}->Belt.List.some(isAbove100) /* true */\n\n  list{1, 2, 3, 4}->Belt.List.some(isAbove100) /* false */\n  ```"
        ],
        "signature": "let some: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.List.every2U",
        "kind": "value",
        "name": "every2U",
        "docstrings": [
          "Uncurried version of [every2](#every2)."
        ],
        "signature": "let every2U: (t<'a>, t<'b>, (. 'a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.every2",
        "kind": "value",
        "name": "every2",
        "docstrings": [
          "Returns `true` if predicate `pred(a, b)` is `true` for all pairs of elements\n  up to the shorter length (i.e. `min(length(firstList), length(secondList))`)\n\n  ```rescript\n  Belt.List.every2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) /* true */\n\n  Belt.List.every2(list{}, list{1}, (a, b) => a > b) /* true */\n\n  Belt.List.every2(list{2, 3}, list{1}, (a, b) => a > b) /* true */\n\n  Belt.List.every2(list{0, 1}, list{5, 0}, (a, b) => a > b) /* false */\n  ```"
        ],
        "signature": "let every2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.some2U",
        "kind": "value",
        "name": "some2U",
        "docstrings": [
          "Uncurried version of [some2](#some2)."
        ],
        "signature": "let some2U: (t<'a>, t<'b>, (. 'a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.some2",
        "kind": "value",
        "name": "some2",
        "docstrings": [
          "Returns `true` if predicate `pred(a, b)` is true for any pair of elements up\n  to the shorter length (i.e. `min(length(firstList), length(secondList))`)\n\n  ```rescript\n  Belt.List.some2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) /* true */\n\n  Belt.List.some2(list{}, list{1}, (a, b) => a > b) /* false */\n\n  Belt.List.some2(list{2, 3}, list{1}, (a, b) => a > b) /* true */\n\n  Belt.List.some2(list{0, 1}, list{5, 0}, (a, b) => a > b) /* true */\n  ```"
        ],
        "signature": "let some2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.cmpByLength",
        "kind": "value",
        "name": "cmpByLength",
        "docstrings": [
          "Compare two lists solely by length. Returns `-1` if `length(firstList)` is\n  less than `length(secondList)`, `0` if `length(firstList)` equals\n  `length(secondList)`, and `1` if `length(firstList)` is greater than\n  `length(secondList)`.\n\n  ```rescript\n  Belt.List.cmpByLength(list{1, 2}, list{3, 4, 5, 6}) /* -1 */\n\n  Belt.List.cmpByLength(list{1, 2, 3}, list{4, 5, 6}) /* = 0 */\n\n  Belt.List.cmpByLength(list{1, 2, 3, 4}, list{5, 6}) /* = 1 */\n  ```"
        ],
        "signature": "let cmpByLength: (t<'a>, t<'a>) => int"
      },
      {
        "id": "Belt.List.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [
          "Uncurried version of [cmp](#cmp)."
        ],
        "signature": "let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.List.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "Compare elements one by one `compareFn(a, b)`. `compareFn` returns a negative number if `a` is \"less than\" `b`, zero if `a` is \"equal to\" `b`, a positive number if `a` is \"greater than\" `b`.\n\n  The comparison returns the first non-zero result of `compareFn`, or zero if `compareFn` returns zero for all `a` and `b`.\n\n  If all items have compared equal, but `firstList` is exhausted first, return `-1`. (`firstList` is shorter).\n  If all items have compared equal, but `secondList` is exhausted first, return `1` (`firstList` is longer).\n\n  ```rescript\n  Belt.List.cmp(list{3}, list{3, 7}, (a, b) => compare(a, b)) /* (-1) */\n\n  Belt.List.cmp(list{5, 3}, list{5}, (a, b) => compare(a, b)) /* 1 */\n\n  Belt.List.cmp(list{1, 3, 5}, list{1, 4, 2}, (a, b) => compare(a, b)) /* (-1) */\n\n  Belt.List.cmp(list{1, 3, 5}, list{1, 2, 3}, (a, b) => compare(a, b)) /* 1 */\n\n  Belt.List.cmp(list{1, 3, 5}, list{1, 3, 5}, (a, b) => compare(a, b)) /* 0 */\n  ```\n\n  **Please note:** The total ordering of List is different from Array,\n  for Array, we compare the length first and, only if the lengths are equal, elements one by one.\n  For lists, we just compare elements one by one."
        ],
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.List.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [
          "Uncurried version of [eq](#eq)."
        ],
        "signature": "let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.List.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "Check equality of `firstList` and `secondList` using `eqElem` for equality on\n  elements, where `eqElem` is a function that returns `true` if items `x` and\n  `y` meet some criterion for equality, `false` otherwise. eq `false` if length\n  of `firstList` and `secondList` are not the same.\n\n  ```rescript\n  Belt.List.eq(list{1, 2, 3}, list{1, 2}, (a, b) => a == b) /* false */\n\n  Belt.List.eq(list{1, 2}, list{1, 2}, (a, b) => a == b) /* true */\n\n  Belt.List.eq(list{1, 2, 3}, list{(-1), (-2), (-3)}, (a, b) => abs(a) == abs(b)) /* true */\n  ```"
        ],
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.List.hasU",
        "kind": "value",
        "name": "hasU",
        "docstrings": [
          "Uncurried version of [has](#has)."
        ],
        "signature": "let hasU: (t<'a>, 'b, (. 'a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.has",
        "kind": "value",
        "name": "has",
        "docstrings": [
          "Returns `true` if the list contains at least one element for which\n  `eqFunction(x)` returns true.\n\n  ```rescript\n  list{1, 2, 3}->Belt.List.has(2, (a, b) => a == b) /* true */\n\n  list{1, 2, 3}->Belt.List.has(4, (a, b) => a == b) /* false */\n\n  list{(-1), (-2), (-3)}->Belt.List.has(2, (a, b) => abs(a) == abs(b)) /* true */\n  ```"
        ],
        "signature": "let has: (t<'a>, 'b, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.getByU",
        "kind": "value",
        "name": "getByU",
        "docstrings": [
          "Uncurried version of [getBy](#getBy)."
        ],
        "signature": "let getByU: (t<'a>, (. 'a) => bool) => option<'a>"
      },
      {
        "id": "Belt.List.getBy",
        "kind": "value",
        "name": "getBy",
        "docstrings": [
          "Returns `Some(value)` for the first value in `someList` that satisfies the\n  predicate function `pred`. Returns `None` if no element satisfies the function.\n\n  ```rescript\n  Belt.List.getBy(list{1, 4, 3, 2}, x => x > 3) /* Some(4) */\n\n  Belt.List.getBy(list{1, 4, 3, 2}, x => x > 4) /* None */\n  ```"
        ],
        "signature": "let getBy: (t<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.List.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [
          "Uncurried version of [keep](#keep)."
        ],
        "signature": "let keepU: (t<'a>, (. 'a) => bool) => t<'a>"
      },
      {
        "id": "Belt.List.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  Belt.List.keep(list{1, 2, 3, 4}, isEven) /* list{2, 4} */\n\n  Belt.List.keep(list{None, Some(2), Some(3), None}, Belt.Option.isSome) /* list{Some(2), Some(3)} */\n  ```"
        ],
        "signature": "let keep: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Belt.List.filter",
        "kind": "value",
        "name": "filter",
        "docstrings": [
          "Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  Belt.List.filter(list{1, 2, 3, 4}, isEven) /* list{2, 4} */\n\n  Belt.List.filter(list{None, Some(2), Some(3), None}, Belt.Option.isSome) /* list{Some(2), Some(3)} */\n  ```"
        ],
        "signature": "let filter: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Belt.List.keepWithIndexU",
        "kind": "value",
        "name": "keepWithIndexU",
        "docstrings": [
          "Uncurried version of [keepWithIndex](#keepWithIndex)."
        ],
        "signature": "let keepWithIndexU: (t<'a>, (. 'a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.List.keepWithIndex",
        "kind": "value",
        "name": "keepWithIndex",
        "docstrings": [
          "Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  Belt.List.keepWithIndex(list{1, 2, 3, 4}, (_x, index) => isEven(index)) /* list{1, 3} */\n  ```"
        ],
        "signature": "let keepWithIndex: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.List.filterWithIndex",
        "kind": "value",
        "name": "filterWithIndex",
        "docstrings": [
          "Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  Belt.List.filterWithIndex(list{1, 2, 3, 4}, (_x, index) => isEven(index)) /* list{1, 3} */\n  ```"
        ],
        "signature": "let filterWithIndex: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.List.keepMapU",
        "kind": "value",
        "name": "keepMapU",
        "docstrings": [
          "Uncurried version of [keepMap](#keepMap)."
        ],
        "signature": "let keepMapU: (t<'a>, (. 'a) => option<'b>) => t<'b>"
      },
      {
        "id": "Belt.List.keepMap",
        "kind": "value",
        "name": "keepMap",
        "docstrings": [
          "Applies `f` to each element of `someList`. If `f(x)` returns `Some(value)`, then `value` is _kept_ in the resulting list.\n  If `f(x)` returns `None`, the element is _not_ retained in the result.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  list{1, 2, 3, 4}\n  ->Belt.List.keepMap(x =>\n      if (isEven(x)) {\n        Some(x)\n      } else {\n        None\n      }\n    ) /* list{2, 4} */\n\n  list{Some(1), Some(2), None}->Belt.List.keepMap(x => x) /* list{1, 2} */\n  ```"
        ],
        "signature": "let keepMap: (t<'a>, 'a => option<'b>) => t<'b>"
      },
      {
        "id": "Belt.List.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [
          "Uncurried version of [partition](#partition)."
        ],
        "signature": "let partitionU: (t<'a>, (. 'a) => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Belt.List.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "Creates a pair of lists; the first list consists of all elements of `someList` that satisfy the predicate function `pred`; the second list consists of all elements of `someList` that _do not_ satisfy `pred.\n\n  In other words:\n\n  ```res\n  (elementsThatSatisfies, elementsThatDoesNotSatisfy)\n  ```\n\n  ```rescript\n  Belt.List.partition(list{1, 2, 3, 4}, x => x > 2) /* (list{3, 4}, list{1, 2}) */\n  ```"
        ],
        "signature": "let partition: (t<'a>, 'a => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Belt.List.unzip",
        "kind": "value",
        "name": "unzip",
        "docstrings": [
          "Takes a list of pairs and creates a pair of lists. The first list contains all the first items of the pairs; the second list contains all the second items.\n\n  ```rescript\n  Belt.List.unzip(list{(1, 2), (3, 4)}) /* (list{1, 3}, list{2, 4}) */\n\n  Belt.List.unzip(list{(\"H\", \"W\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"l\", \"l\"), (\"o\", \"d\"), (\" \", \"!\")})\n  /* (list{\"H\", \"e\", \"l\", \"l\", \"o\", \" \"}, list{\"W\", \"o\", \"r\", \"l\", \"d\", \"!\"}) */\n  ```"
        ],
        "signature": "let unzip: t<('a, 'b)> => (t<'a>, t<'b>)"
      },
      {
        "id": "Belt.List.getAssocU",
        "kind": "value",
        "name": "getAssocU",
        "docstrings": [
          "Uncurried version of [getAssoc](#getAssoc)."
        ],
        "signature": "let getAssocU: (t<('a, 'c)>, 'b, (. 'a, 'b) => bool) => option<'c>"
      },
      {
        "id": "Belt.List.getAssoc",
        "kind": "value",
        "name": "getAssoc",
        "docstrings": [
          "Return the second element of a pair in `someList` where the first element equals `k` as per the predicate function `eqFunction`, or `None` if not found.\n\n  ```rescript\n  list{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.getAssoc(3, (a, b) => a == b) /* Some(\"c\") */\n\n  list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n  ->Belt.List.getAssoc(15, (k, item) => k /* 15 */ == item /* 9, 5, 22 */)\n  /* Some(\"afternoon\") */\n  ```"
        ],
        "signature": "let getAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => option<'c>"
      },
      {
        "id": "Belt.List.hasAssocU",
        "kind": "value",
        "name": "hasAssocU",
        "docstrings": [
          "Uncurried version of [hasAssoc](#hasAssoc)."
        ],
        "signature": "let hasAssocU: (t<('a, 'c)>, 'b, (. 'a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.hasAssoc",
        "kind": "value",
        "name": "hasAssoc",
        "docstrings": [
          "Returns `true` if there is a pair in `someList` where the first element equals `k` as per the predicate function `eqFunction`.\n\n  ```rescript\n  list{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.hasAssoc(1, (a, b) => a == b) /* true */\n\n  list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n  ->Belt.List.hasAssoc(25, (k, item) => k /* 25 */ == item /* 9, 5, 22 */) /* false */\n  ```"
        ],
        "signature": "let hasAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.List.removeAssocU",
        "kind": "value",
        "name": "removeAssocU",
        "docstrings": [
          "Uncurried version of [removeAssoc](#removeAssoc)."
        ],
        "signature": "let removeAssocU: (t<('a, 'c)>, 'b, (. 'a, 'b) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Belt.List.removeAssoc",
        "kind": "value",
        "name": "removeAssoc",
        "docstrings": [
          "Return a list after removing the first pair whose first value is `k` per the equality predicate `eqFunction`; if not found, return a new list identical to `someList`.\n\n  ```rescript\n  list{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.removeAssoc(1, (a, b) => a == b) /* list{(2, \"b\"), (3, \"c\")} */\n\n  list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n  ->Belt.List.removeAssoc(9, (k, item) => k /* 9 */ == item /* 9, 5, 22 */)\n  /* list{(15, \"afternoon\"), (22, \"night\")} */\n  ```"
        ],
        "signature": "let removeAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Belt.List.setAssocU",
        "kind": "value",
        "name": "setAssocU",
        "docstrings": [
          "Uncurried version of [setAssoc](#setAssoc)."
        ],
        "signature": "let setAssocU: (t<('a, 'c)>, 'a, 'c, (. 'a, 'a) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Belt.List.setAssoc",
        "kind": "value",
        "name": "setAssoc",
        "docstrings": [
          "If `k` exists in `someList` by satisfying the `eqFunction` predicate, return a new list with the key and value replaced by the new `k` and `v`; otherwise, return a new list with the pair `k`, `v` added to the head of `someList`.\n\n  ```rescript\n  list{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.setAssoc(2, \"x\", (a, b) => a == b) /* list{(1, \"a\"), (2, \"x\"), (3, \"c\")} */\n\n  list{(1, \"a\"), (3, \"c\")}->Belt.List.setAssoc(2, \"b\", (a, b) => a == b) /* list{(2, \"b\"), (1, \"a\"), (3, \"c\")} */\n\n  list{(9, \"morning\"), (3, \"morning?!\"), (22, \"night\")}\n  ->Belt.List.setAssoc(15, \"afternoon\", (a, b) => mod(a, 12) == mod(b, 12))\n  /* list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")} */\n  ```\n\n  **Please note**\n\n  In the last example, since: `15 mod 12` equals `3 mod 12`\n\n  Both the key _and_ the value are replaced in the list."
        ],
        "signature": "let setAssoc: (t<('a, 'c)>, 'a, 'c, ('a, 'a) => bool) => t<('a, 'c)>"
      },
      {
        "id": "Belt.List.sortU",
        "kind": "value",
        "name": "sortU",
        "docstrings": [
          "Uncurried version of [sort](#sort)."
        ],
        "signature": "let sortU: (t<'a>, (. 'a, 'a) => int) => t<'a>"
      },
      {
        "id": "Belt.List.sort",
        "kind": "value",
        "name": "sort",
        "docstrings": [
          "Returns a sorted list.\n\n  ```rescript\n  Belt.List.sort(list{5, 4, 9, 3, 7}, (a, b) => a - b) // list{3, 4, 5, 7, 9}\n  ```"
        ],
        "signature": "let sort: (t<'a>, ('a, 'a) => int) => t<'a>"
      }
    ]
  },
  "belt/mutablestack": {
    "id": "Belt.MutableStack",
    "name": "MutableStack",
    "docstrings": [
      "[`Belt.MutableStack`]()\n\n  An FILO(first in last out) stack data structure"
    ],
    "items": [
      {
        "id": "Belt.MutableStack.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a>"
      },
      {
        "id": "Belt.MutableStack.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Returns a new stack, initially empty."
        ],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Belt.MutableStack.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "Discard all elements from the stack."
        ],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Belt.MutableStack.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "`copy(x)` O(1) operation, return a new stack."
        ],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.MutableStack.push",
        "kind": "value",
        "name": "push",
        "docstrings": [],
        "signature": "let push: (t<'a>, 'a) => unit"
      },
      {
        "id": "Belt.MutableStack.popUndefined",
        "kind": "value",
        "name": "popUndefined",
        "docstrings": [],
        "signature": "let popUndefined: t<'a> => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableStack.pop",
        "kind": "value",
        "name": "pop",
        "docstrings": [],
        "signature": "let pop: t<'a> => option<'a>"
      },
      {
        "id": "Belt.MutableStack.topUndefined",
        "kind": "value",
        "name": "topUndefined",
        "docstrings": [],
        "signature": "let topUndefined: t<'a> => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableStack.top",
        "kind": "value",
        "name": "top",
        "docstrings": [],
        "signature": "let top: t<'a> => option<'a>"
      },
      {
        "id": "Belt.MutableStack.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.MutableStack.size",
        "kind": "value",
        "name": "size",
        "docstrings": [],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.MutableStack.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, (. 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableStack.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.MutableStack.dynamicPopIterU",
        "kind": "value",
        "name": "dynamicPopIterU",
        "docstrings": [],
        "signature": "let dynamicPopIterU: (t<'a>, (. 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableStack.dynamicPopIter",
        "kind": "value",
        "name": "dynamicPopIter",
        "docstrings": [
          "`dynamicPopIter(s, f)` apply `f` to each element of `s`. The item is poped\n  before applying `f`, `s` will be empty after this opeartion. This function is\n  useful for worklist algorithm."
        ],
        "signature": "let dynamicPopIter: (t<'a>, 'a => unit) => unit"
      }
    ]
  },
  "belt/mutablequeue": {
    "id": "Belt.MutableQueue",
    "name": "MutableQueue",
    "docstrings": [
      "[`Belt.MutableQueue`]()\n\n  An FIFO(first in first out) queue data structure"
    ],
    "items": [
      {
        "id": "Belt.MutableQueue.t",
        "kind": "type",
        "name": "t",
        "docstrings": [
          "The type of queues containing elements of `type('a)`."
        ],
        "signature": "type t<'a>"
      },
      {
        "id": "Belt.MutableQueue.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "Returns a new queue, initially empty."
        ],
        "signature": "let make: unit => t<'a>"
      },
      {
        "id": "Belt.MutableQueue.clear",
        "kind": "value",
        "name": "clear",
        "docstrings": [
          "Discard all elements from the queue."
        ],
        "signature": "let clear: t<'a> => unit"
      },
      {
        "id": "Belt.MutableQueue.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "docstrings": [
          "Returns `true` if the given queue is empty, `false` otherwise."
        ],
        "signature": "let isEmpty: t<'a> => bool"
      },
      {
        "id": "Belt.MutableQueue.fromArray",
        "kind": "value",
        "name": "fromArray",
        "docstrings": [
          "`fromArray` a is equivalent to `Array.forEach(a, add(q, a));`"
        ],
        "signature": "let fromArray: array<'a> => t<'a>"
      },
      {
        "id": "Belt.MutableQueue.add",
        "kind": "value",
        "name": "add",
        "docstrings": [
          "`add(q, x)` adds the element `x` at the end of the queue `q`."
        ],
        "signature": "let add: (t<'a>, 'a) => unit"
      },
      {
        "id": "Belt.MutableQueue.peek",
        "kind": "value",
        "name": "peek",
        "docstrings": [
          "`peekOpt(q)` returns the first element in queue `q`, without removing it from the queue."
        ],
        "signature": "let peek: t<'a> => option<'a>"
      },
      {
        "id": "Belt.MutableQueue.peekUndefined",
        "kind": "value",
        "name": "peekUndefined",
        "docstrings": [
          "`peekUndefined(q)` returns `undefined` if not found."
        ],
        "signature": "let peekUndefined: t<'a> => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableQueue.peekExn",
        "kind": "value",
        "name": "peekExn",
        "docstrings": [
          "raise an exception if `q` is empty"
        ],
        "signature": "let peekExn: t<'a> => 'a"
      },
      {
        "id": "Belt.MutableQueue.pop",
        "kind": "value",
        "name": "pop",
        "docstrings": [
          "`pop(q)` removes and returns the first element in queue `q`."
        ],
        "signature": "let pop: t<'a> => option<'a>"
      },
      {
        "id": "Belt.MutableQueue.popUndefined",
        "kind": "value",
        "name": "popUndefined",
        "docstrings": [
          "`popUndefined(q)` removes and returns the first element in queue `q`. it will return `undefined` if it is already empty."
        ],
        "signature": "let popUndefined: t<'a> => Js.undefined<'a>"
      },
      {
        "id": "Belt.MutableQueue.popExn",
        "kind": "value",
        "name": "popExn",
        "docstrings": [
          "`popExn(q)` raise an exception if q is empty."
        ],
        "signature": "let popExn: t<'a> => 'a"
      },
      {
        "id": "Belt.MutableQueue.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "`copy(q)` returns a fresh queue."
        ],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.MutableQueue.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "Returns the number of elements in a queue."
        ],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.MutableQueue.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a>, (. 'a) => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableQueue.map",
        "kind": "value",
        "name": "map",
        "docstrings": [],
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>"
      },
      {
        "id": "Belt.MutableQueue.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, (. 'a) => unit) => unit"
      },
      {
        "id": "Belt.MutableQueue.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(q, f) applies`f`in turn to all elements of`q`, from the least\n  recently entered to the most recently entered. The queue itself is unchanged."
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.MutableQueue.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (t<'a>, 'b, (. 'b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableQueue.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(q, accu, f)` is equivalent to `List.reduce(l, accu, f)`, where `l` is the list of `q`'s elements. The queue remains unchanged."
        ],
        "signature": "let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b"
      },
      {
        "id": "Belt.MutableQueue.transfer",
        "kind": "value",
        "name": "transfer",
        "docstrings": [
          "`transfer(q1, q2)` adds all of `q1`'s elements at the end of the queue `q2`, then clears `q1`. It is equivalent to the sequence `forEach((x) => add(x, q2), q1);`; clear `q1`, but runs in constant time."
        ],
        "signature": "let transfer: (t<'a>, t<'a>) => unit"
      },
      {
        "id": "Belt.MutableQueue.toArray",
        "kind": "value",
        "name": "toArray",
        "docstrings": [
          "First added will be in the beginning of the array."
        ],
        "signature": "let toArray: t<'a> => array<'a>"
      }
    ]
  },
  "belt/sortarray": {
    "id": "Belt.SortArray",
    "name": "SortArray",
    "docstrings": [
      "[`Belt.SortArray`]()\n\n  The top level provides some generic sort related utilities.\n\n  It also has two specialized inner modules\n  [`Belt.SortArray.Int`]() and [`Belt.SortArray.String`]()"
    ],
    "items": [
      {
        "id": "Belt.SortArray.strictlySortedLengthU",
        "kind": "value",
        "name": "strictlySortedLengthU",
        "docstrings": [],
        "signature": "let strictlySortedLengthU: (array<'a>, (. 'a, 'a) => bool) => int"
      },
      {
        "id": "Belt.SortArray.strictlySortedLength",
        "kind": "value",
        "name": "strictlySortedLength",
        "docstrings": [
          "`strictlySortedLenght(xs, cmp);` return `+n` means increasing order `-n` means negative order\n\n  ```rescript\n  Belt.SortArray.strictlySortedLength([1, 2, 3, 4, 3], (x, y) => x < y) == 4\n\n  Belt.SortArray.strictlySortedLength([], (x, y) => x < y) == 0\n\n  Belt.SortArray.strictlySortedLength([1], (x, y) => x < y) == 1\n\n  Belt.SortArray.strictlySortedLength([4, 3, 2, 1], (x, y) => x < y) == -4\n  ```"
        ],
        "signature": "let strictlySortedLength: (array<'a>, ('a, 'a) => bool) => int"
      },
      {
        "id": "Belt.SortArray.isSortedU",
        "kind": "value",
        "name": "isSortedU",
        "docstrings": [],
        "signature": "let isSortedU: (array<'a>, (. 'a, 'a) => int) => bool"
      },
      {
        "id": "Belt.SortArray.isSorted",
        "kind": "value",
        "name": "isSorted",
        "docstrings": [
          "`isSorted(arr, cmp)`: Returns true if array is increasingly sorted (equal is okay)"
        ],
        "signature": "let isSorted: (array<'a>, ('a, 'a) => int) => bool"
      },
      {
        "id": "Belt.SortArray.stableSortInPlaceByU",
        "kind": "value",
        "name": "stableSortInPlaceByU",
        "docstrings": [],
        "signature": "let stableSortInPlaceByU: (array<'a>, (. 'a, 'a) => int) => unit"
      },
      {
        "id": "Belt.SortArray.stableSortInPlaceBy",
        "kind": "value",
        "name": "stableSortInPlaceBy",
        "docstrings": [],
        "signature": "let stableSortInPlaceBy: (array<'a>, ('a, 'a) => int) => unit"
      },
      {
        "id": "Belt.SortArray.stableSortByU",
        "kind": "value",
        "name": "stableSortByU",
        "docstrings": [],
        "signature": "let stableSortByU: (array<'a>, (. 'a, 'a) => int) => array<'a>"
      },
      {
        "id": "Belt.SortArray.stableSortBy",
        "kind": "value",
        "name": "stableSortBy",
        "docstrings": [
          "`stableSortBy(xs, cmp)`: Returns a fresh array Sort `xs` in place using\n  comparator `cmp`, the stable means if the elements are equal, their order will\n  be preserved"
        ],
        "signature": "let stableSortBy: (array<'a>, ('a, 'a) => int) => array<'a>"
      },
      {
        "id": "Belt.SortArray.binarySearchByU",
        "kind": "value",
        "name": "binarySearchByU",
        "docstrings": [],
        "signature": "let binarySearchByU: (array<'a>, 'a, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.binarySearchBy",
        "kind": "value",
        "name": "binarySearchBy",
        "docstrings": [
          "If value is not found and value is less than one or more elements in array, the\n  negative number returned is the bitwise complement of the index of the first\n  element that is larger than value.\n\n  If value is not found and value is greater\n  than all elements in array, the negative number returned is the bitwise\n  complement of (the index of the last element plus 1)for example, if `key` is\n  smaller than all elements return `-1` since `lnot(-1) == 0` if `key` is larger\n  than all elements return `lnot(-1) == 0` since `lnot(- (len + 1)) == len`\n\n  ```rescript\n  Belt.SortArray.binarySearchBy([1, 2, 3, 4, 33, 35, 36], 33, Pervasives.compare) == 4\n\n  lnot(Belt.SortArray.binarySearchBy([1, 3, 5, 7], 4, Pervasives.compare)) == 2\n  ```"
        ],
        "signature": "let binarySearchBy: (array<'a>, 'a, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.unionU",
        "kind": "value",
        "name": "unionU",
        "docstrings": [],
        "signature": "let unionU: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.union",
        "kind": "value",
        "name": "union",
        "docstrings": [
          "`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n  assume `src` and `src2` is strictly sorted.\n  for equivalent elements, it is picked from `src`\n  also assume that `dst` is large enough to store all elements"
        ],
        "signature": "let union: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.intersectU",
        "kind": "value",
        "name": "intersectU",
        "docstrings": [],
        "signature": "let intersectU: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.intersect",
        "kind": "value",
        "name": "intersect",
        "docstrings": [
          "`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n\n  **return** the `offset` in the output array"
        ],
        "signature": "let intersect: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.diffU",
        "kind": "value",
        "name": "diffU",
        "docstrings": [],
        "signature": "let diffU: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.SortArray.diff",
        "kind": "value",
        "name": "diff",
        "docstrings": [],
        "signature": "let diff: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, ('a, 'a) => int) => int"
      }
    ]
  },
  "belt/array": {
    "id": "Belt.Array",
    "name": "Array",
    "docstrings": [
      "[`Belt.Array`]()\n\n  **mutable array**: Utilities functions"
    ],
    "items": [
      {
        "id": "Belt.Array.t",
        "kind": "type",
        "name": "t",
        "docstrings": [],
        "signature": "type t<'a> = array<'a>"
      },
      {
        "id": "Belt.Array.length",
        "kind": "value",
        "name": "length",
        "docstrings": [
          "return the size of the array\n\n```rescript\n// Returns 1\nBelt.Array.length([\"test\"])\n```"
        ],
        "signature": "let length: t<'a> => int"
      },
      {
        "id": "Belt.Array.size",
        "kind": "value",
        "name": "size",
        "docstrings": [
          "**See** [`length`]()"
        ],
        "signature": "let size: t<'a> => int"
      },
      {
        "id": "Belt.Array.get",
        "kind": "value",
        "name": "get",
        "docstrings": [
          "If `i <= 0 <= length(arr)` returns `Some(value)` where `value` is the item at index `i`.\n  If `i` is out of range returns `None`.\n\n  ```rescript\n  Belt.Array.get([\"a\", \"b\", \"c\"], 0) == Some(\"a\")\n  Belt.Array.get([\"a\", \"b\", \"c\"], 3) == None\n  Belt.Array.get([\"a\", \"b\", \"c\"], -1) == None\n  ```"
        ],
        "signature": "let get: (t<'a>, int) => option<'a>"
      },
      {
        "id": "Belt.Array.getExn",
        "kind": "value",
        "name": "getExn",
        "docstrings": [
          "Raise an exception if `i` is out of range.\n  Otherwise return the value at index `i` in `arr`."
        ],
        "signature": "let getExn: (t<'a>, int) => 'a"
      },
      {
        "id": "Belt.Array.getUnsafe",
        "kind": "value",
        "name": "getUnsafe",
        "docstrings": [
          "`getUnsafe(arr, i)`\n\n  **Unsafe**\n\n  no bounds checking; this would cause type error if `i` does not stay within range"
        ],
        "signature": "let getUnsafe: (t<'a>, int) => 'a"
      },
      {
        "id": "Belt.Array.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "docstrings": [
          "`getUndefined(arr, i)`\n\n  It does the samething in the runtime as [`getUnsafe`]();\n  it is _type safe_ since the return type still track whether it is\n  in range or not"
        ],
        "signature": "let getUndefined: (t<'a>, int) => Js.undefined<'a>"
      },
      {
        "id": "Belt.Array.set",
        "kind": "value",
        "name": "set",
        "docstrings": [
          "`set(arr, n, x)` modifies `arr` in place; it replaces the nth element of `arr` with `x`.\n  Returning `false` means not updated due to out of range."
        ],
        "signature": "let set: (t<'a>, int, 'a) => bool"
      },
      {
        "id": "Belt.Array.setExn",
        "kind": "value",
        "name": "setExn",
        "docstrings": [
          "`setExn(arr, i, x)` raise an exception if `i` is out of range."
        ],
        "signature": "let setExn: (t<'a>, int, 'a) => unit"
      },
      {
        "id": "Belt.Array.setUnsafe",
        "kind": "value",
        "name": "setUnsafe",
        "docstrings": [],
        "signature": "let setUnsafe: (t<'a>, int, 'a) => unit"
      },
      {
        "id": "Belt.Array.shuffleInPlace",
        "kind": "value",
        "name": "shuffleInPlace",
        "docstrings": [
          "`shuffleInPlace(arr)` randomly re-orders the items in `arr`"
        ],
        "signature": "let shuffleInPlace: t<'a> => unit"
      },
      {
        "id": "Belt.Array.shuffle",
        "kind": "value",
        "name": "shuffle",
        "docstrings": [
          "Returns a fresh array with items in original array randomly shuffled."
        ],
        "signature": "let shuffle: t<'a> => t<'a>"
      },
      {
        "id": "Belt.Array.reverseInPlace",
        "kind": "value",
        "name": "reverseInPlace",
        "docstrings": [
          "`reverseInPlace(arr)` reverses items in `arr` in place.\n\n  ```rescript\n  let arr = [10, 11, 12, 13, 14]\n\n  let () = Belt.Array.reverseInPlace(arr)\n\n  arr == [14, 13, 12, 11, 10]\n  ```"
        ],
        "signature": "let reverseInPlace: t<'a> => unit"
      },
      {
        "id": "Belt.Array.reverse",
        "kind": "value",
        "name": "reverse",
        "docstrings": [
          "`reverse(arr)` returns a fresh array with items in arr in reverse order.\n\n  ```rescript\n  Belt.Array.reverse([10, 11, 12, 13, 14]) == [14, 13, 12, 11, 10]\n  ```"
        ],
        "signature": "let reverse: t<'a> => t<'a>"
      },
      {
        "id": "Belt.Array.makeUninitialized",
        "kind": "value",
        "name": "makeUninitialized",
        "docstrings": [
          "`makeUninitialized(n)` creates an array of length `n` filled with the undefined value. You must specify the type of data that will eventually fill the array.\n\n  ```rescript\n  let arr: array<Js.undefined<string>> = Belt.Array.makeUninitialized(5)\n\n  Belt.Array.getExn(arr, 0) == Js.undefined\n  ```"
        ],
        "signature": "let makeUninitialized: int => array<Js.undefined<'a>>"
      },
      {
        "id": "Belt.Array.makeUninitializedUnsafe",
        "kind": "value",
        "name": "makeUninitializedUnsafe",
        "docstrings": [
          "**Unsafe**\n\n  ```rescript\n  let arr = Belt.Array.makeUninitializedUnsafe(5)\n\n  Js.log(Belt.Array.getExn(arr, 0)) // undefined\n\n  Belt.Array.setExn(arr, 0, \"example\")\n\n  Js.log(Belt.Array.getExn(arr, 0) == \"example\")\n  ```"
        ],
        "signature": "let makeUninitializedUnsafe: int => t<'a>"
      },
      {
        "id": "Belt.Array.make",
        "kind": "value",
        "name": "make",
        "docstrings": [
          "`make(n, e)` return an array of size `n` filled with value `e`.\n  Returns an empty array when `n` is negative."
        ],
        "signature": "let make: (int, 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.range",
        "kind": "value",
        "name": "range",
        "docstrings": [
          "`range(start, finish)` create an inclusive array.\n\n  ```rescript\n  Belt.Array.range(0, 3) == [0, 1, 2, 3]\n\n  Belt.Array.range(3, 0) == []\n\n  Belt.Array.range(3, 3) == [3]\n  ```"
        ],
        "signature": "let range: (int, int) => array<int>"
      },
      {
        "id": "Belt.Array.rangeBy",
        "kind": "value",
        "name": "rangeBy",
        "docstrings": [
          "`rangeBy(start, finish, ~step)`\n\n  Returns empty array when step is 0 or negative. It also return an empty array when `start > finish`.\n\n  ```rescript\n  Belt.Array.rangeBy(0, 10, ~step=3) == [0, 3, 6, 9]\n\n  Belt.Array.rangeBy(0, 12, ~step=3) == [0, 3, 6, 9, 12]\n\n  Belt.Array.rangeBy(33, 0, ~step=1) == []\n\n  Belt.Array.rangeBy(33, 0, ~step=-1) == []\n\n  Belt.Array.rangeBy(3, 12, ~step=-1) == []\n\n  Belt.Array.rangeBy(3, 3, ~step=0) == []\n\n  Belt.Array.rangeBy(3, 3, ~step=1) == [3]\n  ```"
        ],
        "signature": "let rangeBy: (int, int, ~step: int) => array<int>"
      },
      {
        "id": "Belt.Array.makeByU",
        "kind": "value",
        "name": "makeByU",
        "docstrings": [],
        "signature": "let makeByU: (int, (. int) => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.makeBy",
        "kind": "value",
        "name": "makeBy",
        "docstrings": [
          "`makeBy(n, f)`\n\n  Return an empty array when n is negative return an array of size n populated by `f(i)` start from `0` to `n - 1`.\n\n  ```rescript\n  Belt.Array.makeBy(5, (i) => i) == [0, 1, 2, 3, 4]\n\n  Belt.Array.makeBy(5, (i) => i * i) == [0, 1, 4, 9, 16]\n  ```"
        ],
        "signature": "let makeBy: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.makeByAndShuffleU",
        "kind": "value",
        "name": "makeByAndShuffleU",
        "docstrings": [],
        "signature": "let makeByAndShuffleU: (int, (. int) => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.makeByAndShuffle",
        "kind": "value",
        "name": "makeByAndShuffle",
        "docstrings": [
          "Equivalent to `shuffle(makeBy(n, f))`"
        ],
        "signature": "let makeByAndShuffle: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.zip",
        "kind": "value",
        "name": "zip",
        "docstrings": [
          "`zip(a, b)`\n\n  Create an array of pairs from corresponding elements of a and b. Stop with the shorter array.\n\n  ```rescript\n  Belt.Array.zip([1, 2], [3, 4, 5]) == [(1, 3), (2, 4)]\n  ```"
        ],
        "signature": "let zip: (t<'a>, array<'b>) => array<('a, 'b)>"
      },
      {
        "id": "Belt.Array.zipByU",
        "kind": "value",
        "name": "zipByU",
        "docstrings": [],
        "signature": "let zipByU: (t<'a>, array<'b>, (. 'a, 'b) => 'c) => array<'c>"
      },
      {
        "id": "Belt.Array.zipBy",
        "kind": "value",
        "name": "zipBy",
        "docstrings": [
          "`zipBy(xs, ys, f)`\n\n  Create an array by applying `f` to corresponding elements of `xs` and `ys`. Stops with shorter array.\n\n  Equivalent to `map(zip(xs, ys), ((a, b)) => f(a, b))`\n\n  ```rescript\n  Belt.Array.zipBy([1, 2, 3], [4, 5], (a, b) => 2 * a + b) == [6, 9]\n  ```"
        ],
        "signature": "let zipBy: (t<'a>, array<'b>, ('a, 'b) => 'c) => array<'c>"
      },
      {
        "id": "Belt.Array.unzip",
        "kind": "value",
        "name": "unzip",
        "docstrings": [
          "`unzip(a)` takes an array of pairs and creates a pair of arrays. The first array contains all the first items of the pairs; the second array contains all the second items.\n\n  ```rescript\n  Belt.Array.unzip([(1, 2), (3, 4)]) == ([1, 3], [2, 4])\n\n  Belt.Array.unzip([(1, 2), (3, 4), (5, 6), (7, 8)]) == ([1, 3, 5, 7], [2, 4, 6, 8])\n  ```"
        ],
        "signature": "let unzip: array<('a, 'b)> => (t<'a>, array<'b>)"
      },
      {
        "id": "Belt.Array.concat",
        "kind": "value",
        "name": "concat",
        "docstrings": [
          "`concat(xs, ys)`\n\n  Returns a fresh array containing the concatenation of the arrays `v1` and `v2`;so even if `v1` or `v2` is empty; it can not be shared\n\n  ```rescript\n  Belt.Array.concat([1, 2, 3], [4, 5]) == [1, 2, 3, 4, 5]\n\n  Belt.Array.concat([], [\"a\", \"b\", \"c\"]) == [\"a\", \"b\", \"c\"]\n  ```"
        ],
        "signature": "let concat: (t<'a>, t<'a>) => t<'a>"
      },
      {
        "id": "Belt.Array.concatMany",
        "kind": "value",
        "name": "concatMany",
        "docstrings": [
          "`concatMany(xss)`\n\n  Returns a fresh array as the concatenation of `xss` (an array of arrays)\n\n  ```rescript\n  Belt.Array.concatMany([[1, 2, 3], [4, 5, 6], [7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]\n  ```"
        ],
        "signature": "let concatMany: array<t<'a>> => t<'a>"
      },
      {
        "id": "Belt.Array.slice",
        "kind": "value",
        "name": "slice",
        "docstrings": [
          "`slice(xs, offset, len)` creates a new array with the len elements of `xs`\n  starting at `offset` for `offset` can be negative;and is evaluated as\n  `length(xs) - offset(slice, xs) - 1(1)` means get the last element as a\n  singleton array `slice(xs, ~-len, len)` will return a copy of the array if the\n  array does not have enough data; `slice` extracts through the end of sequence.\n\n  if `len` is negative; returns the empty array.\n\n  ```rescript\n  Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=2, ~len=3) == [12, 13, 14]\n\n  Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=-4, ~len=3) == [13, 14, 15]\n\n  Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=4, ~len=9) == [14, 15, 16]\n  ```"
        ],
        "signature": "let slice: (t<'a>, ~offset: int, ~len: int) => t<'a>"
      },
      {
        "id": "Belt.Array.sliceToEnd",
        "kind": "value",
        "name": "sliceToEnd",
        "docstrings": [
          "`sliceToEnd(xs, offset)` creates a new array with the elements of `xs` starting at `offset`\n\n  `offset` can be negative; and is evaluated as `length(xs) - offset(sliceToEnd, xs) - 1` means get the last element as a singleton array\n\n  `sliceToEnd(xs, 0)` will return a copy of the array\n\n  ```rescript\n  Belt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], 2) == [12, 13, 14, 15, 16]\n\n  Belt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], -4) == [13, 14, 15, 16]\n  ```"
        ],
        "signature": "let sliceToEnd: (t<'a>, int) => t<'a>"
      },
      {
        "id": "Belt.Array.copy",
        "kind": "value",
        "name": "copy",
        "docstrings": [
          "`copy(a)`\n\n  Returns a copy of a; that is; a fresh array containing the same elements as a."
        ],
        "signature": "let copy: t<'a> => t<'a>"
      },
      {
        "id": "Belt.Array.fill",
        "kind": "value",
        "name": "fill",
        "docstrings": [
          "`fill(arr, ~offset, ~len, x)`\n\n  Modifies `arr` in place, storing `x` in elements number `offset` to `offset + len - 1`.\n  `offset` can be negative; and is evaluated as `length(arr - offset)`\n\n  `fill(arr, ~offset=-1, ~len=1)` means fill the last element, if the array does not have enough data; `fill` will ignore it\n\n  ```rescript\n  let arr = Belt.Array.makeBy(5, (i) => i)\n\n  Belt.Array.fill(arr, ~offset=2, ~len=2, 9)\n\n  arr == [0, 1, 9, 9, 4]\n\n  Belt.Array.fill(arr, ~offset=7, ~len=2, 8)\n\n  arr == [0, 1, 9, 9, 4]"
        ],
        "signature": "let fill: (t<'a>, ~offset: int, ~len: int, 'a) => unit"
      },
      {
        "id": "Belt.Array.blit",
        "kind": "value",
        "name": "blit",
        "docstrings": [
          "`blit(~src=v1, ~srcOffset=o1, ~dst=v2, ~dstOffset=o2, ~len)`\n\n  copies `len` elements from array `v1`;starting at element number `o1`;to array `v2`, starting at element number `o2`.\n\n  It works correctly even if `v1` and `v2` are the same array;and the source and destination chunks overlap.\n\n  `offset` can be negative; `-1` means `len - 1`; if `len + offset` is still negative;it will be set as 0\n\n  For each of the examples;presume that `v1 == [10, 11, 12, 13, 14, 15, 16, 17]` and `v2 == [20, 21, 22, 23, 24, 25, 26, 27]`. The result shown is the content of the destination array.\n\n  ```rescript\n  let v1 = [10, 11, 12, 13, 14, 15, 16, 17]\n  let v2 = [20, 21, 22, 23, 24, 25, 26, 27]\n\n  Belt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v2, ~dstOffset=2, ~len=3)\n  v2 == [20, 21, 14, 15, 16, 25, 26, 27]\n\n  Belt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v1, ~dstOffset=2, ~len=3)\n  v1 == [10, 11, 14, 15, 16, 15, 16, 17]\n  ```"
        ],
        "signature": "let blit: (~src: t<'a>, ~srcOffset: int, ~dst: t<'a>, ~dstOffset: int, ~len: int) => unit"
      },
      {
        "id": "Belt.Array.blitUnsafe",
        "kind": "value",
        "name": "blitUnsafe",
        "docstrings": [
          "Unsafe blit without bounds checking."
        ],
        "signature": "let blitUnsafe: (~src: t<'a>, ~srcOffset: int, ~dst: t<'a>, ~dstOffset: int, ~len: int) => unit"
      },
      {
        "id": "Belt.Array.forEachU",
        "kind": "value",
        "name": "forEachU",
        "docstrings": [],
        "signature": "let forEachU: (t<'a>, (. 'a) => unit) => unit"
      },
      {
        "id": "Belt.Array.forEach",
        "kind": "value",
        "name": "forEach",
        "docstrings": [
          "`forEach(xs, f)`\n\n  Call `f` on each element of `xs` from the beginning to end. `f` returns `unit`;so no new array is created. Use `forEach` when you are primarily concerned with repetitively creating side effects.\n\n  ```rescript\n  Belt.Array.forEach([\"a\", \"b\", \"c\"], x => Js.log(\"Item: \" ++ x))\n\n  /*\n    prints:\n    Item: a\n    Item: b\n    Item: c\n  */\n  let total = ref(0)\n\n  Belt.Array.forEach([1, 2, 3, 4], x => total := total.contents + x)\n\n  total.contents == 1 + 2 + 3 + 4\n  ```"
        ],
        "signature": "let forEach: (t<'a>, 'a => unit) => unit"
      },
      {
        "id": "Belt.Array.mapU",
        "kind": "value",
        "name": "mapU",
        "docstrings": [],
        "signature": "let mapU: (t<'a>, (. 'a) => 'b) => array<'b>"
      },
      {
        "id": "Belt.Array.map",
        "kind": "value",
        "name": "map",
        "docstrings": [
          "`map(xs, f)`\n\n  Returns a new array by calling `f` for each element of `xs` from the beginning to end.\n\n  ```rescript\n  Belt.Array.map([1, 2], (x) => x + 1) == [3, 4]\n  ```"
        ],
        "signature": "let map: (t<'a>, 'a => 'b) => array<'b>"
      },
      {
        "id": "Belt.Array.flatMapU",
        "kind": "value",
        "name": "flatMapU",
        "docstrings": [],
        "signature": "let flatMapU: (t<'a>, (. 'a) => array<'b>) => array<'b>"
      },
      {
        "id": "Belt.Array.flatMap",
        "kind": "value",
        "name": "flatMap",
        "docstrings": [
          "`flatMap(xs, f)`\n\n  **Returns** a new array by calling `f` for each element of `xs` from\n  the beginning to end, concatenating the results.\n\n  ```rescript\n  flatMap([1, 2], x => [x + 10, x + 20]) == [11, 21, 12, 22]\n  ```"
        ],
        "signature": "let flatMap: (t<'a>, 'a => array<'b>) => array<'b>"
      },
      {
        "id": "Belt.Array.getByU",
        "kind": "value",
        "name": "getByU",
        "docstrings": [],
        "signature": "let getByU: (t<'a>, (. 'a) => bool) => option<'a>"
      },
      {
        "id": "Belt.Array.getBy",
        "kind": "value",
        "name": "getBy",
        "docstrings": [
          "`getBy(xs, p)`\n\n  Returns `Some(value)` for the first value in `xs` that satisifies the predicate function `p`; returns `None` if no element satisifies the function.\n\n  ```rescript\n  Belt.Array.getBy([1, 4, 3, 2], (x) => mod(x, 2) == 0) == Some(4)\n  Belt.Array.getBy([15, 13, 11], (x) => mod(x, 2) == 0) == None\n  ```"
        ],
        "signature": "let getBy: (t<'a>, 'a => bool) => option<'a>"
      },
      {
        "id": "Belt.Array.getIndexByU",
        "kind": "value",
        "name": "getIndexByU",
        "docstrings": [],
        "signature": "let getIndexByU: (t<'a>, (. 'a) => bool) => option<int>"
      },
      {
        "id": "Belt.Array.getIndexBy",
        "kind": "value",
        "name": "getIndexBy",
        "docstrings": [
          "`getIndexBy(xs, p)` returns `Some(index)` for the first value in `xs` that satisifies the predicate function `p`;\n  returns `None` if no element satisifies the function.\n\n  ```rescript\n  Belt.Array.getIndexBy([1, 4, 3, 2], (x) => mod(x, 2) == 0) == Some(1)\n  Belt.Array.getIndexBy([15, 13, 11], (x) => mod(x, 2) == 0) == None\n  ```"
        ],
        "signature": "let getIndexBy: (t<'a>, 'a => bool) => option<int>"
      },
      {
        "id": "Belt.Array.keepU",
        "kind": "value",
        "name": "keepU",
        "docstrings": [],
        "signature": "let keepU: (t<'a>, (. 'a) => bool) => t<'a>"
      },
      {
        "id": "Belt.Array.keep",
        "kind": "value",
        "name": "keep",
        "docstrings": [
          "`keep(xs, p)` returns a new array that keep all elements satisfy `p`."
        ],
        "signature": "let keep: (t<'a>, 'a => bool) => t<'a>"
      },
      {
        "id": "Belt.Array.keepWithIndexU",
        "kind": "value",
        "name": "keepWithIndexU",
        "docstrings": [],
        "signature": "let keepWithIndexU: (t<'a>, (. 'a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.Array.keepWithIndex",
        "kind": "value",
        "name": "keepWithIndex",
        "docstrings": [
          "`keepWithIndex(xs, p)`\n\n  Returns a new array that keep all elements satisfy `p`.\n\n  ```rescript\n  Belt.Array.keepWithIndex([1, 2, 3], (_x, i) => i == 1) == [2]\n  ```"
        ],
        "signature": "let keepWithIndex: (t<'a>, ('a, int) => bool) => t<'a>"
      },
      {
        "id": "Belt.Array.keepMapU",
        "kind": "value",
        "name": "keepMapU",
        "docstrings": [],
        "signature": "let keepMapU: (t<'a>, (. 'a) => option<'b>) => array<'b>"
      },
      {
        "id": "Belt.Array.keepMap",
        "kind": "value",
        "name": "keepMap",
        "docstrings": [
          "`keepMap(xs, p)`\n\n  Returns a new array that keep all elements that return a non-None applied `p`.\n\n  ```rescript\n  Belt.Array.keepMap([1, 2, 3], x =>\n    if mod(x, 2) == 0 {\n      Some(x)\n    } else {\n      None\n    }\n  )\n  == [2]\n  ```"
        ],
        "signature": "let keepMap: (t<'a>, 'a => option<'b>) => array<'b>"
      },
      {
        "id": "Belt.Array.forEachWithIndexU",
        "kind": "value",
        "name": "forEachWithIndexU",
        "docstrings": [],
        "signature": "let forEachWithIndexU: (t<'a>, (. int, 'a) => unit) => unit"
      },
      {
        "id": "Belt.Array.forEachWithIndex",
        "kind": "value",
        "name": "forEachWithIndex",
        "docstrings": [
          "`forEachWithIndex(xs, f)`\n\n  The same as `Belt.Array.forEach`;\n  except that `f` is supplied two arguments: the index starting from 0 and the element from `xs`.\n\n  ```rescript\n  Belt.Array.forEachWithIndex([\"a\", \"b\", \"c\"], (i, x) => Js.log(\"Item \" ++ Belt.Int.toString(i) ++ \" is \" ++ x))\n\n  /*\n    prints:\n    Item 0 is a\n    Item 1 is b\n    Item 2 is cc\n  */\n  let total = ref(0)\n\n  Belt.Array.forEachWithIndex([10, 11, 12, 13], (i, x) => total := total.contents + x + i)\n\n  total.contents == 0 + 10 + 1 + 11 + 2 + 12 + 3 + 13\n  ```"
        ],
        "signature": "let forEachWithIndex: (t<'a>, (int, 'a) => unit) => unit"
      },
      {
        "id": "Belt.Array.mapWithIndexU",
        "kind": "value",
        "name": "mapWithIndexU",
        "docstrings": [],
        "signature": "let mapWithIndexU: (t<'a>, (. int, 'a) => 'b) => array<'b>"
      },
      {
        "id": "Belt.Array.mapWithIndex",
        "kind": "value",
        "name": "mapWithIndex",
        "docstrings": [
          "`mapWithIndex(xs, f)`\n\n  `mapWithIndex(xs, f)` applies `f` to each element of `xs`. Function `f` takes two arguments: the index starting from 0 and the element from `xs`.\n\n  ```rescript\n  Belt.Array.mapWithIndex([1, 2, 3], (i, x) => i + x) == [0 + 1, 1 + 2, 2 + 3]\n  ```"
        ],
        "signature": "let mapWithIndex: (t<'a>, (int, 'a) => 'b) => array<'b>"
      },
      {
        "id": "Belt.Array.partitionU",
        "kind": "value",
        "name": "partitionU",
        "docstrings": [],
        "signature": "let partitionU: (t<'a>, (. 'a) => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Belt.Array.partition",
        "kind": "value",
        "name": "partition",
        "docstrings": [
          "`partition(f, a)` split array into tuple of two arrays based on predicate `f`; first of tuple where predicate cause true, second where predicate cause false\n\n  ```rescript\n  Belt.Array.partition([1, 2, 3, 4, 5], (x) => mod(x, 2) == 0) == ([2, 4], [1, 3, 5])\n\n  Belt.Array.partition([1, 2, 3, 4, 5], (x) => mod(x, 2) != 0) == ([1, 3, 5], [2, 4])\n  ```"
        ],
        "signature": "let partition: (t<'a>, 'a => bool) => (t<'a>, t<'a>)"
      },
      {
        "id": "Belt.Array.reduceU",
        "kind": "value",
        "name": "reduceU",
        "docstrings": [],
        "signature": "let reduceU: (array<'b>, 'a, (. 'a, 'b) => 'a) => 'a"
      },
      {
        "id": "Belt.Array.reduce",
        "kind": "value",
        "name": "reduce",
        "docstrings": [
          "`reduce(xs, init, f)`\n\n  Applies `f` to each element of `xs` from beginning to end. Function `f` has two parameters: the item from the list and an “accumulator”; which starts with a value of `init`. `reduce` returns the final value of the accumulator.\n\n  ```rescript\n  Belt.Array.reduce([2, 3, 4], 1, (a, b) => a + b) == 10\n\n  Belt.Array.reduce([\"a\", \"b\", \"c\", \"d\"], \"\", (a, b) => a ++ b) == \"abcd\"\n  ```"
        ],
        "signature": "let reduce: (array<'b>, 'a, ('a, 'b) => 'a) => 'a"
      },
      {
        "id": "Belt.Array.reduceReverseU",
        "kind": "value",
        "name": "reduceReverseU",
        "docstrings": [],
        "signature": "let reduceReverseU: (array<'b>, 'a, (. 'a, 'b) => 'a) => 'a"
      },
      {
        "id": "Belt.Array.reduceReverse",
        "kind": "value",
        "name": "reduceReverse",
        "docstrings": [
          "`reduceReverse(xs, init, f)`\n\n  Works like `Belt_Array.reduce`; except that function `f` is applied to each item of `xs` from the last back to the first.\n\n  ```rescript\n  Belt.Array.reduceReverse([\"a\", \"b\", \"c\", \"d\"], \"\", (a, b) => a ++ b) == \"dcba\"\n  ```"
        ],
        "signature": "let reduceReverse: (array<'b>, 'a, ('a, 'b) => 'a) => 'a"
      },
      {
        "id": "Belt.Array.reduceReverse2U",
        "kind": "value",
        "name": "reduceReverse2U",
        "docstrings": [],
        "signature": "let reduceReverse2U: (t<'a>, array<'b>, 'c, (. 'c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.Array.reduceReverse2",
        "kind": "value",
        "name": "reduceReverse2",
        "docstrings": [
          "`reduceReverse2(xs, ys, init, f)`\n\n  Reduces two arrays xs and ys;taking items starting at `min(length(xs), length(ys))` down to and including zero.\n\n  ```rescript\n  Belt.Array.reduceReverse2([1, 2, 3], [1, 2], 0, (acc, x, y) => acc + x + y) == 6\n  ```"
        ],
        "signature": "let reduceReverse2: (t<'a>, array<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c"
      },
      {
        "id": "Belt.Array.reduceWithIndexU",
        "kind": "value",
        "name": "reduceWithIndexU",
        "docstrings": [],
        "signature": "let reduceWithIndexU: (t<'a>, 'b, (. 'b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Belt.Array.reduceWithIndex",
        "kind": "value",
        "name": "reduceWithIndex",
        "docstrings": [
          "Applies `f` to each element of `xs` from beginning to end. Function `f` has three parameters: the item from the array and an “accumulator”, which starts with a value of `init` and the index of each element. `reduceWithIndex` returns the final value of the accumulator.\n\n  ```rescript\n  Belt.Array.reduceWithIndex([1, 2, 3, 4], 0, (acc, x, i) => acc + x + i) == 16\n  ```"
        ],
        "signature": "let reduceWithIndex: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b"
      },
      {
        "id": "Belt.Array.joinWithU",
        "kind": "value",
        "name": "joinWithU",
        "docstrings": [],
        "signature": "let joinWithU: (t<'a>, string, (. 'a) => string) => string"
      },
      {
        "id": "Belt.Array.joinWith",
        "kind": "value",
        "name": "joinWith",
        "docstrings": [
          "`joinWith(xs, sep, toString)`\n\n  Concatenates all the elements of `xs` converted to string with `toString`, each separated by `sep`, the string\n  given as the second argument, into a single string.\n  If the array has only one element, then that element will be returned\n  without using the separator.\n  If the array is empty, the empty string will be returned.\n\n  ```rescript\n  joinWith([0, 1], \", \", string_of_int) == \"0, 1\"\n  joinWith([], \" \", string_of_int) == \"\"\n  joinWith([1], \" \", string_of_int) == \"1\"\n  ```"
        ],
        "signature": "let joinWith: (t<'a>, string, 'a => string) => string"
      },
      {
        "id": "Belt.Array.someU",
        "kind": "value",
        "name": "someU",
        "docstrings": [],
        "signature": "let someU: (t<'a>, (. 'a) => bool) => bool"
      },
      {
        "id": "Belt.Array.some",
        "kind": "value",
        "name": "some",
        "docstrings": [
          "`some(xs, p)`\n\n  Returns true if at least one of the elements in `xs` satifies `p`; where `p` is a predicate: a function taking an element and returning a `bool`.\n\n  ```rescript\n  Belt.Array.some([2, 3, 4], (x) => mod(x, 2) == 1) == true\n\n  Belt.Array.some([(-1), (-3), (-5)], (x) => x > 0) == false\n  ```"
        ],
        "signature": "let some: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.Array.everyU",
        "kind": "value",
        "name": "everyU",
        "docstrings": [],
        "signature": "let everyU: (t<'a>, (. 'a) => bool) => bool"
      },
      {
        "id": "Belt.Array.every",
        "kind": "value",
        "name": "every",
        "docstrings": [
          "`every(xs, p)`\n\n  Returns `true` if all elements satisfy `p`; where `p` is a predicate: a function taking an element and returning a `bool`.\n\n  ```rescript\n  Belt.Array.every([1, 3, 5], (x) => mod(x, 2) == 1) == true\n\n  Belt.Array.every([1, (-3), 5], (x) => x > 0) == false\n  ```"
        ],
        "signature": "let every: (t<'a>, 'a => bool) => bool"
      },
      {
        "id": "Belt.Array.every2U",
        "kind": "value",
        "name": "every2U",
        "docstrings": [],
        "signature": "let every2U: (t<'a>, array<'b>, (. 'a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Array.every2",
        "kind": "value",
        "name": "every2",
        "docstrings": [
          "`every2(xs, ys, p)`\n\n  returns true if `p(xi, yi)` is true for all pairs of elements up to the shorter length (i.e. `min(length(xs), length(ys))`)\n\n  ```rescript\n  Belt.Array.every2([1, 2, 3], [0, 1], (a, b) => a > b) == true\n\n  Belt.Array.every2([], [1], (x, y) => x > y) == true\n\n  Belt.Array.every2([2, 3], [1], (x, y) => x > y) == true\n\n  Belt.Array.every2([0, 1], [5, 0], (x, y) => x > y) == false\n  ```"
        ],
        "signature": "let every2: (t<'a>, array<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Array.some2U",
        "kind": "value",
        "name": "some2U",
        "docstrings": [],
        "signature": "let some2U: (t<'a>, array<'b>, (. 'a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Array.some2",
        "kind": "value",
        "name": "some2",
        "docstrings": [
          "`some2(xs, ys, p)`\n\n  returns true if `p(xi, yi)` is true for any pair of elements up to the shorter length (i.e. `min(length(xs), length(ys))`)\n\n  ```rescript\n  Belt.Array.some2([0, 2], [1, 0, 3], (a, b) => a > b) == true\n\n  Belt.Array.some2([], [1], (x, y) => x > y) == false\n\n  Belt.Array.some2([2, 3], [1, 4], (x, y) => x > y) == true\n  ```"
        ],
        "signature": "let some2: (t<'a>, array<'b>, ('a, 'b) => bool) => bool"
      },
      {
        "id": "Belt.Array.cmpU",
        "kind": "value",
        "name": "cmpU",
        "docstrings": [],
        "signature": "let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int"
      },
      {
        "id": "Belt.Array.cmp",
        "kind": "value",
        "name": "cmp",
        "docstrings": [
          "`cmp(xs, ys, f)`\n\n  Compared by length if `length(xs) != length(ys)`; returning -1 if `length(xs) < length(ys)` or 1 if `length(xs) > length(ys)`\n  Otherwise compare one by one `f(x, y)`. `f` returns\n  a negative number if `x` is “less than” `y`\n  zero if `x` is “equal to” `y`\n  a positive number if `x` is “greater than” `y`\n  The comparison returns the first non-zero result of `f`;or zero if `f` returns zero for all `x` and `y`.\n\n  ```rescript\n  Belt.Array.cmp([1, 3, 5], [1, 4, 2], (a, b) => compare(a, b)) == -1\n\n  Belt.Array.cmp([1, 3, 5], [1, 2, 3], (a, b) => compare(a, b)) == 1\n\n  Belt.Array.cmp([1, 3, 5], [1, 3, 5], (a, b) => compare(a, b)) == 0\n  ```"
        ],
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int"
      },
      {
        "id": "Belt.Array.eqU",
        "kind": "value",
        "name": "eqU",
        "docstrings": [],
        "signature": "let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Array.eq",
        "kind": "value",
        "name": "eq",
        "docstrings": [
          "`eq(xs, ys)`\n\n  return false if length is not the same\n  otherwise compare items one by one using `f(xi, yi)`; and return true if all results are truefalse otherwise\n\n  ```rescript\n  Belt.Array.eq([1, 2, 3], [(-1), (-2), (-3)], (a, b) => abs(a) == abs(b)) == true\n  ```"
        ],
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool"
      },
      {
        "id": "Belt.Array.truncateToLengthUnsafe",
        "kind": "value",
        "name": "truncateToLengthUnsafe",
        "docstrings": [
          "Unsafe `truncateToLengthUnsafe(xs, n)` sets length of array `xs` to `n`.\n\n  If `n` is greater than the length of `xs`; the extra elements are set to `Js.Null_undefined.null`.\n\n  If `n` is less than zero; raises a `RangeError`.\n\n  ```rescript\n  let arr = [\"ant\", \"bee\", \"cat\", \"dog\", \"elk\"]\n\n  Belt.Array.truncateToLengthUnsafe(arr, 3)\n\n  arr == [\"ant\", \"bee\", \"cat\"]\n  ```"
        ],
        "signature": "let truncateToLengthUnsafe: (t<'a>, int) => unit"
      },
      {
        "id": "Belt.Array.initU",
        "kind": "value",
        "name": "initU",
        "docstrings": [],
        "signature": "let initU: (int, (. int) => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.init",
        "kind": "value",
        "name": "init",
        "docstrings": [],
        "signature": "let init: (int, int => 'a) => t<'a>"
      },
      {
        "id": "Belt.Array.push",
        "kind": "value",
        "name": "push",
        "docstrings": [
          "`arr->push(item)` pushes an element `item` into an array `arr`."
        ],
        "signature": "let push: (t<'a>, 'a) => unit"
      }
    ]
  },
  "belt/id": {
    "id": "Belt.Id",
    "name": "Id",
    "docstrings": [
      "[`Belt.Id`]()\n\n  Provide utilities to create identified comparators or hashes for\n  data structures used below.\n\n  It create a unique identifier per module of\n  functions so that different data structures with slightly different\n  comparison functions won't mix"
    ],
    "items": [
      {
        "id": "Belt.Id.hash",
        "kind": "type",
        "name": "hash",
        "docstrings": [
          "`('a, 'id) hash`\n\n  Its runtime represenation is a `hash` function, but signed with a\n  type parameter, so that different hash functions type mismatch"
        ],
        "signature": "type hash<'a, 'id>"
      },
      {
        "id": "Belt.Id.eq",
        "kind": "type",
        "name": "eq",
        "docstrings": [
          "`('a, 'id) eq`\n\n  Its runtime represenation is an `eq` function, but signed with a\n  type parameter, so that different hash functions type mismatch"
        ],
        "signature": "type eq<'a, 'id>"
      },
      {
        "id": "Belt.Id.cmp",
        "kind": "type",
        "name": "cmp",
        "docstrings": [
          "`('a,'id) cmp`\n\n  Its runtime representation is a `cmp` function, but signed with a\n  type parameter, so that different hash functions type mismatch"
        ],
        "signature": "type cmp<'a, 'id>"
      },
      {
        "id": "Belt.Id.comparable",
        "kind": "type",
        "name": "comparable",
        "docstrings": [
          "`('key, 'id) cmparable` is a module of functions, here it only includes `cmp`.\n\n  Unlike normal functions, when created, it comes with a unique identity (guaranteed\n  by the type system).\n\n  It can be created using function [`comparableU`]() or [`comparable`]().\n\n  The idea of a unique identity when created is that it makes sure two sets would type\n  mismatch if they use different comparison function"
        ],
        "signature": "type comparable<'key, 'id> = module(Comparable with type identity = 'id)\\ntype t = 'key"
      },
      {
        "id": "Belt.Id.comparableU",
        "kind": "value",
        "name": "comparableU",
        "docstrings": [],
        "signature": "let comparableU: (~cmp: (. 'a, 'a) => int) => module(Comparable with type t = 'a)"
      },
      {
        "id": "Belt.Id.comparable",
        "kind": "value",
        "name": "comparable",
        "docstrings": [
          "```\n  module C = (\n    val Belt.Id.comparable ~cmp:(compare : int -> int -> int)\n  )\n  let m = Belt.Set.make(module C)\n  ```\n\n  Note that the name of C can not be ignored"
        ],
        "signature": "let comparable: (~cmp: ('a, 'a) => int) => module(Comparable with type t = 'a)"
      },
      {
        "id": "Belt.Id.hashable",
        "kind": "type",
        "name": "hashable",
        "docstrings": [
          "`('key, 'id) hashable` is a module of functions, here it only includes `hash`, `eq`.\n\n  Unlike normal functions, when created, it comes with a unique identity (guaranteed\n  by the type system).\n\n  It can be created using function [`hashableU`]() or [`hashable`]().\n\n  The idea of a unique identity when created is that it makes sure two hash sets would type\n  mismatch if they use different comparison function"
        ],
        "signature": "type hashable<'key, 'id> = module(Hashable with type identity = 'id)\\ntype t = 'key"
      },
      {
        "id": "Belt.Id.hashableU",
        "kind": "value",
        "name": "hashableU",
        "docstrings": [],
        "signature": "let hashableU: (~hash: (. 'a) => int, ~eq: (. 'a, 'a) => bool) => module(Hashable with type t = 'a)"
      },
      {
        "id": "Belt.Id.hashable",
        "kind": "value",
        "name": "hashable",
        "docstrings": [],
        "signature": "let hashable: (~hash: 'a => int, ~eq: ('a, 'a) => bool) => module(Hashable with type t = 'a)"
      },
      {
        "id": "Belt.Id.getHashInternal",
        "kind": "value",
        "name": "getHashInternal",
        "docstrings": [],
        "signature": "let getHashInternal: hash<'a, 'id> => (. 'a) => int"
      },
      {
        "id": "Belt.Id.getEqInternal",
        "kind": "value",
        "name": "getEqInternal",
        "docstrings": [],
        "signature": "let getEqInternal: eq<'a, 'id> => (. 'a, 'a) => bool"
      },
      {
        "id": "Belt.Id.getCmpInternal",
        "kind": "value",
        "name": "getCmpInternal",
        "docstrings": [],
        "signature": "let getCmpInternal: cmp<'a, 'id> => (. 'a, 'a) => int"
      }
    ]
  }
}