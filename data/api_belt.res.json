{
  "name": "Belt",
  "docstrings": ["The ReScript standard library.\n\nBelt is currently mostly covering collection types. It has no string or date functions yet, although Belt.String is in the works. In the meantime, use [Js.String](js/string) for string functions and [Js.Date](js/date) for date functions.\n\n## Motivation\n\nBelt provides:\n\n- The **highest quality** immutable data structures in JavaScript.\n- Safety by default: A Belt function will never throw exceptions, unless it is\n  indicated explicitly in the function name (suffix \"Exn\").\n- Better performance and smaller code size running on the JS platform.\n- Ready for [Tree Shaking](https://webpack.js.org/guides/tree-shaking/).\n\n## Usage\n\nTo use modules from Belt, either refer to them by their fully qualified name (`Belt.List`, `Belt.Array` etc.) or open the `Belt` module by putting\n\n```rescript\nopen Belt\n```\n\nat the top of your source files. After opening Belt this way, `Array` will refer to `Belt.Array`, `List` will refer to `Belt.List` etc. in the subsequent code.\n\nIf you want to open Belt globally for all files in your project instead, you can put\n\n```json\n\"bsc-flags\": [\"-open Belt\"]\n```\n\ninto your `bsconfig.json`.\n\n**Note**: this is the **only** `open` we encourage.\n\nExample usage:\n\n```rescript\nlet someNumbers = [1, 1, 4, 2, 3, 6, 3, 4, 2]\n\nlet greaterThan2UniqueAndSorted =\n  someNumbers\n  ->Belt.Array.keep(x => x > 2)\n  // convert to and from set to make values unique\n  ->Belt.Set.Int.fromArray\n  ->Belt.Set.Int.toArray // output is already sorted\n\nJs.log2(\"result\", greaterThan2UniqueAndSorted)\n```\n\n## Curried vs. Uncurried Callbacks\n\nFor functions taking a callback parameter, there are usually two versions\navailable:\n\n- curried (no suffix)\n- uncurried (suffixed with `U`)\n\nE.g.:\n\n```rescript\nlet forEach: (t<'a>, 'a => unit) => unit\n\nlet forEachU: (t<'a>, (. 'a) => unit) => unit\n```\n\nThe uncurried version will be faster in some cases, but for simplicity we recommend to stick with the curried version unless you need the extra performance.\n\nThe two versions can be invoked as follows:\n\n```rescript\n[\"a\", \"b\", \"c\"]->Belt.Array.forEach(x => Js.log(x))\n\n[\"a\", \"b\", \"c\"]->Belt.Array.forEachU((. x) => Js.log(x))\n```\n\n## Specialized Collections\n\nFor collections types like set or map, Belt provides both a generic module as well as specialized, more efficient implementations for string and int keys.\n\nFor example, Belt has the following set modules:\n\n- [Belt.Set](belt/set)\n- [Belt.Set.Int](belt/set-int)\n- [Belt.Set.String](belt/set-string)\n\n## Implementation Details\n\n### Array access runtime safety\n\nOne common confusion comes from the way Belt handles array access. It differs from than the default standard library's.\n\n```rescript\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0] // a == \"a\"\nlet capitalA = Js.String.toUpperCase(a)\nlet k = letters[10] // Raises an exception! The 10th index doesn't exist.\n```\n\nBecause Belt avoids exceptions and returns `options` instead, this code behaves differently:\n\n```rescript\nopen Belt\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0] // a == Some(\"a\")\nlet captialA = Js.String.toUpperCase(a) // Type error! This code will not compile.\nlet k = letters[10] // k == None\n```\n\nAlthough we've fixed the problem where `k` raises an exception, we now have a type error when trying to capitalize `a`. There are a few things going on here:\n\n- Reason transforms array index access to the function `Array.get`. So `letters[0]` is the same as `Array.get(letters, 0)`.\n- The compiler uses whichever `Array` module is in scope. If you `open Belt`, then it uses `Belt.Array`.\n- `Belt.Array.get` returns values wrapped in options, so `letters[0] == Some(\"a\")`.\n\nFortunately, this is easy to fix:\n\n```rescript\nopen Belt\nlet letters = [\"a\", \"b\", \"c\"]\nlet a = letters[0]\n\n// Use a switch statement:\nlet capitalA =\n  switch a {\n  | Some(a) => Some(Js.String.toUpperCase(a))\n  | None => None\n  }\n\nlet k = letters[10] // k == None\n```\n\nWith that little bit of tweaking, our code now compiles successfully and is 100% free of runtime errors!\n\n### A Special Encoding for Collection Safety\n\nWhen we create a collection library for a custom data type we need a way to provide a comparator function. Take Set for example, suppose its element type is a pair of ints, it needs a custom compare function that takes two tuples and returns their order. The Set could not just be typed as Set.t (int \\* int) , its customized compare function needs to manifest itself in the signature, otherwise, if the user creates another customized compare function, the two collection could mix which would result in runtime error.\n\nWe use a phantom type to solve the problem:\n\n```rescript\nmodule Comparable1 =\n  Belt.Id.MakeComparable(\n    {\n      type t = (int, int)\n      let cmp = ((a0, a1), (b0, b1)) =>\n        switch Pervasives.compare(a0, b0) {\n        | 0 => Pervasives.compare(a1, b1)\n        | c => c\n        }\n    }\n  )\n\nlet mySet1 = Belt.Set.make(~id=module(Comparable1))\n\nmodule Comparable2 =\n  Belt.Id.MakeComparable(\n    {\n      type t = (int, int)\n      let cmp = ((a0, a1), (b0, b1)) =>\n        switch Pervasives.compare(a0, b0) {\n        | 0 => Pervasives.compare(a1, b1)\n        | c => c\n        }\n    }\n  )\n\nlet mySet2 = Belt.Set.make(~id=module(Comparable2))\n```\n\nHere, the compiler would infer `mySet1` and `mySet2` having different type, so e.g. a `merge` operation that tries to merge these two sets will correctly fail.\n\n```rescript\nlet mySet1: t<(int, int), Comparable1.identity>\nlet mySet2: t<(int, int), Comparable2.identity>\n```\n\n`Comparable1.identity` and `Comparable2.identity` are not the same using our encoding scheme."],
  "items": [
  {
    "id": "Belt.Belt_Id",
    "kind": "moduleAlias",
    "name": "Id",
    "docstrings": ["[`Belt.Id`]()\n\n  Provide utilities to create identified comparators or hashes for\n  data structures used below.\n\n  It create a unique identifier per module of\n  functions so that different data structures with slightly different\n  comparison functions won't mix"],
    "items": [
    {
      "id": "Belt.Belt_Id.hash",
      "kind": "type",
      "name": "hash",
      "signature": "type hash<'a, 'id>",
      "docstrings": ["`('a, 'id) hash`\n\n  Its runtime represenation is a `hash` function, but signed with a\n  type parameter, so that different hash functions type mismatch"]
    }, 
    {
      "id": "Belt.Belt_Id.eq",
      "kind": "type",
      "name": "eq",
      "signature": "type eq<'a, 'id>",
      "docstrings": ["`('a, 'id) eq`\n\n  Its runtime represenation is an `eq` function, but signed with a\n  type parameter, so that different hash functions type mismatch"]
    }, 
    {
      "id": "Belt.Belt_Id.cmp",
      "kind": "type",
      "name": "cmp",
      "signature": "type cmp<'a, 'id>",
      "docstrings": ["`('a,'id) cmp`\n\n  Its runtime representation is a `cmp` function, but signed with a\n  type parameter, so that different hash functions type mismatch"]
    }, 
    {
      "id": "Belt.Belt_Id.comparable",
      "kind": "type",
      "name": "comparable",
      "signature": "type comparable<'key, 'id> = module(Comparable with type identity = 'id)\\ntype t = 'key",
      "docstrings": ["`('key, 'id) cmparable` is a module of functions, here it only includes `cmp`.\n\n  Unlike normal functions, when created, it comes with a unique identity (guaranteed\n  by the type system).\n\n  It can be created using function [`comparableU`]() or [`comparable`]().\n\n  The idea of a unique identity when created is that it makes sure two sets would type\n  mismatch if they use different comparison function"]
    }, 
    {
      "id": "MakeComparableU.Belt_Id.Belt",
      "name": "MakeComparableU",
      "kind": "module",
      "items": [
      {
        "id": "Belt.Belt_Id.MakeComparableU.identity",
        "kind": "type",
        "name": "identity",
        "signature": "type identity",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeComparableU.t",
        "kind": "type",
        "name": "t",
        "signature": "type t = M.t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeComparableU.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: cmp<t, identity>",
        "docstrings": []
      }]
    }, 
    {
      "id": "MakeComparable.Belt_Id.Belt",
      "name": "MakeComparable",
      "kind": "module",
      "items": [
      {
        "id": "Belt.Belt_Id.MakeComparable.identity",
        "kind": "type",
        "name": "identity",
        "signature": "type identity",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeComparable.t",
        "kind": "type",
        "name": "t",
        "signature": "type t = M.t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeComparable.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: cmp<t, identity>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_Id.comparableU",
      "kind": "value",
      "name": "comparableU",
      "signature": "let comparableU: (~cmp: (. 'a, 'a) => int) => module(Comparable with type t = 'a)",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Id.comparable",
      "kind": "value",
      "name": "comparable",
      "signature": "let comparable: (~cmp: ('a, 'a) => int) => module(Comparable with type t = 'a)",
      "docstrings": ["```\n  module C = (\n    val Belt.Id.comparable ~cmp:(compare : int -> int -> int)\n  )\n  let m = Belt.Set.make(module C)\n  ```\n\n  Note that the name of C can not be ignored"]
    }, 
    {
      "id": "Belt.Belt_Id.hashable",
      "kind": "type",
      "name": "hashable",
      "signature": "type hashable<'key, 'id> = module(Hashable with type identity = 'id)\\ntype t = 'key",
      "docstrings": ["`('key, 'id) hashable` is a module of functions, here it only includes `hash`, `eq`.\n\n  Unlike normal functions, when created, it comes with a unique identity (guaranteed\n  by the type system).\n\n  It can be created using function [`hashableU`]() or [`hashable`]().\n\n  The idea of a unique identity when created is that it makes sure two hash sets would type\n  mismatch if they use different comparison function"]
    }, 
    {
      "id": "MakeHashableU.Belt_Id.Belt",
      "name": "MakeHashableU",
      "kind": "module",
      "items": [
      {
        "id": "Belt.Belt_Id.MakeHashableU.identity",
        "kind": "type",
        "name": "identity",
        "signature": "type identity",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeHashableU.t",
        "kind": "type",
        "name": "t",
        "signature": "type t = M.t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeHashableU.hash",
        "kind": "value",
        "name": "hash",
        "signature": "let hash: hash<t, identity>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeHashableU.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: eq<t, identity>",
        "docstrings": []
      }]
    }, 
    {
      "id": "MakeHashable.Belt_Id.Belt",
      "name": "MakeHashable",
      "kind": "module",
      "items": [
      {
        "id": "Belt.Belt_Id.MakeHashable.identity",
        "kind": "type",
        "name": "identity",
        "signature": "type identity",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeHashable.t",
        "kind": "type",
        "name": "t",
        "signature": "type t = M.t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeHashable.hash",
        "kind": "value",
        "name": "hash",
        "signature": "let hash: hash<t, identity>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Id.MakeHashable.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: eq<t, identity>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_Id.hashableU",
      "kind": "value",
      "name": "hashableU",
      "signature": "let hashableU: (~hash: (. 'a) => int, ~eq: (. 'a, 'a) => bool) => module(Hashable with type t = 'a)",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Id.hashable",
      "kind": "value",
      "name": "hashable",
      "signature": "let hashable: (~hash: 'a => int, ~eq: ('a, 'a) => bool) => module(Hashable with type t = 'a)",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Id.getHashInternal",
      "kind": "value",
      "name": "getHashInternal",
      "signature": "let getHashInternal: hash<'a, 'id> => (. 'a) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Id.getEqInternal",
      "kind": "value",
      "name": "getEqInternal",
      "signature": "let getEqInternal: eq<'a, 'id> => (. 'a, 'a) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Id.getCmpInternal",
      "kind": "value",
      "name": "getCmpInternal",
      "signature": "let getCmpInternal: cmp<'a, 'id> => (. 'a, 'a) => int",
      "docstrings": []
    }]
  }, 
  {
    "id": "Belt.Belt_Array",
    "kind": "moduleAlias",
    "name": "Array",
    "docstrings": ["[`Belt.Array`]()\n\n  **mutable array**: Utilities functions"],
    "items": [
    {
      "id": "Belt.Belt_Array.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = array<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: t<'a> => int",
      "docstrings": ["return the size of the array\n\n```rescript\n// Returns 1\nBelt.Array.length([\"test\"])\n```"]
    }, 
    {
      "id": "Belt.Belt_Array.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'a> => int",
      "docstrings": ["**See** [`length`]()"]
    }, 
    {
      "id": "Belt.Belt_Array.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'a>, int) => option<'a>",
      "docstrings": ["If `i <= 0 <= length(arr)` returns `Some(value)` where `value` is the item at index `i`.\n  If `i` is out of range returns `None`.\n\n  ```rescript\n  Belt.Array.get([\"a\", \"b\", \"c\"], 0) == Some(\"a\")\n  Belt.Array.get([\"a\", \"b\", \"c\"], 3) == None\n  Belt.Array.get([\"a\", \"b\", \"c\"], -1) == None\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'a>, int) => 'a",
      "docstrings": ["Raise an exception if `i` is out of range.\n  Otherwise return the value at index `i` in `arr`."]
    }, 
    {
      "id": "Belt.Belt_Array.getUnsafe",
      "kind": "value",
      "name": "getUnsafe",
      "signature": "let getUnsafe: (t<'a>, int) => 'a",
      "docstrings": ["`getUnsafe(arr, i)`\n\n  **Unsafe**\n\n  no bounds checking; this would cause type error if `i` does not stay within range"]
    }, 
    {
      "id": "Belt.Belt_Array.getUndefined",
      "kind": "value",
      "name": "getUndefined",
      "signature": "let getUndefined: (t<'a>, int) => Js.undefined<'a>",
      "docstrings": ["`getUndefined(arr, i)`\n\n  It does the samething in the runtime as [`getUnsafe`]();\n  it is _type safe_ since the return type still track whether it is\n  in range or not"]
    }, 
    {
      "id": "Belt.Belt_Array.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'a>, int, 'a) => bool",
      "docstrings": ["`set(arr, n, x)` modifies `arr` in place; it replaces the nth element of `arr` with `x`.\n  Returning `false` means not updated due to out of range."]
    }, 
    {
      "id": "Belt.Belt_Array.setExn",
      "kind": "value",
      "name": "setExn",
      "signature": "let setExn: (t<'a>, int, 'a) => unit",
      "docstrings": ["`setExn(arr, i, x)` raise an exception if `i` is out of range."]
    }, 
    {
      "id": "Belt.Belt_Array.setUnsafe",
      "kind": "value",
      "name": "setUnsafe",
      "signature": "let setUnsafe: (t<'a>, int, 'a) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.shuffleInPlace",
      "kind": "value",
      "name": "shuffleInPlace",
      "signature": "let shuffleInPlace: t<'a> => unit",
      "docstrings": ["`shuffleInPlace(arr)` randomly re-orders the items in `arr`"]
    }, 
    {
      "id": "Belt.Belt_Array.shuffle",
      "kind": "value",
      "name": "shuffle",
      "signature": "let shuffle: t<'a> => t<'a>",
      "docstrings": ["Returns a fresh array with items in original array randomly shuffled."]
    }, 
    {
      "id": "Belt.Belt_Array.reverseInPlace",
      "kind": "value",
      "name": "reverseInPlace",
      "signature": "let reverseInPlace: t<'a> => unit",
      "docstrings": ["`reverseInPlace(arr)` reverses items in `arr` in place.\n\n  ```rescript\n  let arr = [10, 11, 12, 13, 14]\n\n  let () = Belt.Array.reverseInPlace(arr)\n\n  arr == [14, 13, 12, 11, 10]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.reverse",
      "kind": "value",
      "name": "reverse",
      "signature": "let reverse: t<'a> => t<'a>",
      "docstrings": ["`reverse(arr)` returns a fresh array with items in arr in reverse order.\n\n  ```rescript\n  Belt.Array.reverse([10, 11, 12, 13, 14]) == [14, 13, 12, 11, 10]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.makeUninitialized",
      "kind": "value",
      "name": "makeUninitialized",
      "signature": "let makeUninitialized: int => array<Js.undefined<'a>>",
      "docstrings": ["`makeUninitialized(n)` creates an array of length `n` filled with the undefined value. You must specify the type of data that will eventually fill the array.\n\n  ```rescript\n  let arr: array<Js.undefined<string>> = Belt.Array.makeUninitialized(5)\n\n  Belt.Array.getExn(arr, 0) == Js.undefined\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.makeUninitializedUnsafe",
      "kind": "value",
      "name": "makeUninitializedUnsafe",
      "signature": "let makeUninitializedUnsafe: int => t<'a>",
      "docstrings": ["**Unsafe**\n\n  ```rescript\n  let arr = Belt.Array.makeUninitializedUnsafe(5)\n\n  Js.log(Belt.Array.getExn(arr, 0)) // undefined\n\n  Belt.Array.setExn(arr, 0, \"example\")\n\n  Js.log(Belt.Array.getExn(arr, 0) == \"example\")\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (int, 'a) => t<'a>",
      "docstrings": ["`make(n, e)` return an array of size `n` filled with value `e`.\n  Returns an empty array when `n` is negative."]
    }, 
    {
      "id": "Belt.Belt_Array.range",
      "kind": "value",
      "name": "range",
      "signature": "let range: (int, int) => array<int>",
      "docstrings": ["`range(start, finish)` create an inclusive array.\n\n  ```rescript\n  Belt.Array.range(0, 3) == [0, 1, 2, 3]\n\n  Belt.Array.range(3, 0) == []\n\n  Belt.Array.range(3, 3) == [3]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.rangeBy",
      "kind": "value",
      "name": "rangeBy",
      "signature": "let rangeBy: (int, int, ~step: int) => array<int>",
      "docstrings": ["`rangeBy(start, finish, ~step)`\n\n  Returns empty array when step is 0 or negative. It also return an empty array when `start > finish`.\n\n  ```rescript\n  Belt.Array.rangeBy(0, 10, ~step=3) == [0, 3, 6, 9]\n\n  Belt.Array.rangeBy(0, 12, ~step=3) == [0, 3, 6, 9, 12]\n\n  Belt.Array.rangeBy(33, 0, ~step=1) == []\n\n  Belt.Array.rangeBy(33, 0, ~step=-1) == []\n\n  Belt.Array.rangeBy(3, 12, ~step=-1) == []\n\n  Belt.Array.rangeBy(3, 3, ~step=0) == []\n\n  Belt.Array.rangeBy(3, 3, ~step=1) == [3]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.makeByU",
      "kind": "value",
      "name": "makeByU",
      "signature": "let makeByU: (int, (. int) => 'a) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.makeBy",
      "kind": "value",
      "name": "makeBy",
      "signature": "let makeBy: (int, int => 'a) => t<'a>",
      "docstrings": ["`makeBy(n, f)`\n\n  Return an empty array when n is negative return an array of size n populated by `f(i)` start from `0` to `n - 1`.\n\n  ```rescript\n  Belt.Array.makeBy(5, (i) => i) == [0, 1, 2, 3, 4]\n\n  Belt.Array.makeBy(5, (i) => i * i) == [0, 1, 4, 9, 16]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.makeByAndShuffleU",
      "kind": "value",
      "name": "makeByAndShuffleU",
      "signature": "let makeByAndShuffleU: (int, (. int) => 'a) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.makeByAndShuffle",
      "kind": "value",
      "name": "makeByAndShuffle",
      "signature": "let makeByAndShuffle: (int, int => 'a) => t<'a>",
      "docstrings": ["Equivalent to `shuffle(makeBy(n, f))`"]
    }, 
    {
      "id": "Belt.Belt_Array.zip",
      "kind": "value",
      "name": "zip",
      "signature": "let zip: (t<'a>, array<'b>) => array<('a, 'b)>",
      "docstrings": ["`zip(a, b)`\n\n  Create an array of pairs from corresponding elements of a and b. Stop with the shorter array.\n\n  ```rescript\n  Belt.Array.zip([1, 2], [3, 4, 5]) == [(1, 3), (2, 4)]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.zipByU",
      "kind": "value",
      "name": "zipByU",
      "signature": "let zipByU: (t<'a>, array<'b>, (. 'a, 'b) => 'c) => array<'c>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.zipBy",
      "kind": "value",
      "name": "zipBy",
      "signature": "let zipBy: (t<'a>, array<'b>, ('a, 'b) => 'c) => array<'c>",
      "docstrings": ["`zipBy(xs, ys, f)`\n\n  Create an array by applying `f` to corresponding elements of `xs` and `ys`. Stops with shorter array.\n\n  Equivalent to `map(zip(xs, ys), ((a, b)) => f(a, b))`\n\n  ```rescript\n  Belt.Array.zipBy([1, 2, 3], [4, 5], (a, b) => 2 * a + b) == [6, 9]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.unzip",
      "kind": "value",
      "name": "unzip",
      "signature": "let unzip: array<('a, 'b)> => (t<'a>, array<'b>)",
      "docstrings": ["`unzip(a)` takes an array of pairs and creates a pair of arrays. The first array contains all the first items of the pairs; the second array contains all the second items.\n\n  ```rescript\n  Belt.Array.unzip([(1, 2), (3, 4)]) == ([1, 3], [2, 4])\n\n  Belt.Array.unzip([(1, 2), (3, 4), (5, 6), (7, 8)]) == ([1, 3, 5, 7], [2, 4, 6, 8])\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.concat",
      "kind": "value",
      "name": "concat",
      "signature": "let concat: (t<'a>, t<'a>) => t<'a>",
      "docstrings": ["`concat(xs, ys)`\n\n  Returns a fresh array containing the concatenation of the arrays `v1` and `v2`;so even if `v1` or `v2` is empty; it can not be shared\n\n  ```rescript\n  Belt.Array.concat([1, 2, 3], [4, 5]) == [1, 2, 3, 4, 5]\n\n  Belt.Array.concat([], [\"a\", \"b\", \"c\"]) == [\"a\", \"b\", \"c\"]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.concatMany",
      "kind": "value",
      "name": "concatMany",
      "signature": "let concatMany: array<t<'a>> => t<'a>",
      "docstrings": ["`concatMany(xss)`\n\n  Returns a fresh array as the concatenation of `xss` (an array of arrays)\n\n  ```rescript\n  Belt.Array.concatMany([[1, 2, 3], [4, 5, 6], [7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.slice",
      "kind": "value",
      "name": "slice",
      "signature": "let slice: (t<'a>, ~offset: int, ~len: int) => t<'a>",
      "docstrings": ["`slice(xs, offset, len)` creates a new array with the len elements of `xs`\n  starting at `offset` for `offset` can be negative;and is evaluated as\n  `length(xs) - offset(slice, xs) - 1(1)` means get the last element as a\n  singleton array `slice(xs, ~-len, len)` will return a copy of the array if the\n  array does not have enough data; `slice` extracts through the end of sequence.\n\n  if `len` is negative; returns the empty array.\n\n  ```rescript\n  Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=2, ~len=3) == [12, 13, 14]\n\n  Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=-4, ~len=3) == [13, 14, 15]\n\n  Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=4, ~len=9) == [14, 15, 16]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.sliceToEnd",
      "kind": "value",
      "name": "sliceToEnd",
      "signature": "let sliceToEnd: (t<'a>, int) => t<'a>",
      "docstrings": ["`sliceToEnd(xs, offset)` creates a new array with the elements of `xs` starting at `offset`\n\n  `offset` can be negative; and is evaluated as `length(xs) - offset(sliceToEnd, xs) - 1` means get the last element as a singleton array\n\n  `sliceToEnd(xs, 0)` will return a copy of the array\n\n  ```rescript\n  Belt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], 2) == [12, 13, 14, 15, 16]\n\n  Belt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], -4) == [13, 14, 15, 16]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'a> => t<'a>",
      "docstrings": ["`copy(a)`\n\n  Returns a copy of a; that is; a fresh array containing the same elements as a."]
    }, 
    {
      "id": "Belt.Belt_Array.fill",
      "kind": "value",
      "name": "fill",
      "signature": "let fill: (t<'a>, ~offset: int, ~len: int, 'a) => unit",
      "docstrings": ["`fill(arr, ~offset, ~len, x)`\n\n  Modifies `arr` in place, storing `x` in elements number `offset` to `offset + len - 1`.\n  `offset` can be negative; and is evaluated as `length(arr - offset)`\n\n  `fill(arr, ~offset=-1, ~len=1)` means fill the last element, if the array does not have enough data; `fill` will ignore it\n\n  ```rescript\n  let arr = Belt.Array.makeBy(5, (i) => i)\n\n  Belt.Array.fill(arr, ~offset=2, ~len=2, 9)\n\n  arr == [0, 1, 9, 9, 4]\n\n  Belt.Array.fill(arr, ~offset=7, ~len=2, 8)\n\n  arr == [0, 1, 9, 9, 4]"]
    }, 
    {
      "id": "Belt.Belt_Array.blit",
      "kind": "value",
      "name": "blit",
      "signature": "let blit: (~src: t<'a>, ~srcOffset: int, ~dst: t<'a>, ~dstOffset: int, ~len: int) => unit",
      "docstrings": ["`blit(~src=v1, ~srcOffset=o1, ~dst=v2, ~dstOffset=o2, ~len)`\n\n  copies `len` elements from array `v1`;starting at element number `o1`;to array `v2`, starting at element number `o2`.\n\n  It works correctly even if `v1` and `v2` are the same array;and the source and destination chunks overlap.\n\n  `offset` can be negative; `-1` means `len - 1`; if `len + offset` is still negative;it will be set as 0\n\n  For each of the examples;presume that `v1 == [10, 11, 12, 13, 14, 15, 16, 17]` and `v2 == [20, 21, 22, 23, 24, 25, 26, 27]`. The result shown is the content of the destination array.\n\n  ```rescript\n  let v1 = [10, 11, 12, 13, 14, 15, 16, 17]\n  let v2 = [20, 21, 22, 23, 24, 25, 26, 27]\n\n  Belt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v2, ~dstOffset=2, ~len=3)\n  v2 == [20, 21, 14, 15, 16, 25, 26, 27]\n\n  Belt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v1, ~dstOffset=2, ~len=3)\n  v1 == [10, 11, 14, 15, 16, 15, 16, 17]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.blitUnsafe",
      "kind": "value",
      "name": "blitUnsafe",
      "signature": "let blitUnsafe: (~src: t<'a>, ~srcOffset: int, ~dst: t<'a>, ~dstOffset: int, ~len: int) => unit",
      "docstrings": ["Unsafe blit without bounds checking."]
    }, 
    {
      "id": "Belt.Belt_Array.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'a>, (. 'a) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a>, 'a => unit) => unit",
      "docstrings": ["`forEach(xs, f)`\n\n  Call `f` on each element of `xs` from the beginning to end. `f` returns `unit`;so no new array is created. Use `forEach` when you are primarily concerned with repetitively creating side effects.\n\n  ```rescript\n  Belt.Array.forEach([\"a\", \"b\", \"c\"], x => Js.log(\"Item: \" ++ x))\n\n  /*\n    prints:\n    Item: a\n    Item: b\n    Item: c\n  */\n  let total = ref(0)\n\n  Belt.Array.forEach([1, 2, 3, 4], x => total := total.contents + x)\n\n  total.contents == 1 + 2 + 3 + 4\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (t<'a>, (. 'a) => 'b) => array<'b>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a>, 'a => 'b) => array<'b>",
      "docstrings": ["`map(xs, f)`\n\n  Returns a new array by calling `f` for each element of `xs` from the beginning to end.\n\n  ```rescript\n  Belt.Array.map([1, 2], (x) => x + 1) == [3, 4]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.flatMapU",
      "kind": "value",
      "name": "flatMapU",
      "signature": "let flatMapU: (t<'a>, (. 'a) => array<'b>) => array<'b>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.flatMap",
      "kind": "value",
      "name": "flatMap",
      "signature": "let flatMap: (t<'a>, 'a => array<'b>) => array<'b>",
      "docstrings": ["`flatMap(xs, f)`\n\n  **Returns** a new array by calling `f` for each element of `xs` from\n  the beginning to end, concatenating the results.\n\n  ```rescript\n  flatMap([1, 2], x => [x + 10, x + 20]) == [11, 21, 12, 22]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.getByU",
      "kind": "value",
      "name": "getByU",
      "signature": "let getByU: (t<'a>, (. 'a) => bool) => option<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.getBy",
      "kind": "value",
      "name": "getBy",
      "signature": "let getBy: (t<'a>, 'a => bool) => option<'a>",
      "docstrings": ["`getBy(xs, p)`\n\n  Returns `Some(value)` for the first value in `xs` that satisifies the predicate function `p`; returns `None` if no element satisifies the function.\n\n  ```rescript\n  Belt.Array.getBy([1, 4, 3, 2], (x) => mod(x, 2) == 0) == Some(4)\n  Belt.Array.getBy([15, 13, 11], (x) => mod(x, 2) == 0) == None\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.getIndexByU",
      "kind": "value",
      "name": "getIndexByU",
      "signature": "let getIndexByU: (t<'a>, (. 'a) => bool) => option<int>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.getIndexBy",
      "kind": "value",
      "name": "getIndexBy",
      "signature": "let getIndexBy: (t<'a>, 'a => bool) => option<int>",
      "docstrings": ["`getIndexBy(xs, p)` returns `Some(index)` for the first value in `xs` that satisifies the predicate function `p`;\n  returns `None` if no element satisifies the function.\n\n  ```rescript\n  Belt.Array.getIndexBy([1, 4, 3, 2], (x) => mod(x, 2) == 0) == Some(1)\n  Belt.Array.getIndexBy([15, 13, 11], (x) => mod(x, 2) == 0) == None\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (t<'a>, (. 'a) => bool) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (t<'a>, 'a => bool) => t<'a>",
      "docstrings": ["`keep(xs, p)` returns a new array that keep all elements satisfy `p`."]
    }, 
    {
      "id": "Belt.Belt_Array.keepWithIndexU",
      "kind": "value",
      "name": "keepWithIndexU",
      "signature": "let keepWithIndexU: (t<'a>, (. 'a, int) => bool) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.keepWithIndex",
      "kind": "value",
      "name": "keepWithIndex",
      "signature": "let keepWithIndex: (t<'a>, ('a, int) => bool) => t<'a>",
      "docstrings": ["`keepWithIndex(xs, p)`\n\n  Returns a new array that keep all elements satisfy `p`.\n\n  ```rescript\n  Belt.Array.keepWithIndex([1, 2, 3], (_x, i) => i == 1) == [2]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.keepMapU",
      "kind": "value",
      "name": "keepMapU",
      "signature": "let keepMapU: (t<'a>, (. 'a) => option<'b>) => array<'b>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.keepMap",
      "kind": "value",
      "name": "keepMap",
      "signature": "let keepMap: (t<'a>, 'a => option<'b>) => array<'b>",
      "docstrings": ["`keepMap(xs, p)`\n\n  Returns a new array that keep all elements that return a non-None applied `p`.\n\n  ```rescript\n  Belt.Array.keepMap([1, 2, 3], x =>\n    if mod(x, 2) == 0 {\n      Some(x)\n    } else {\n      None\n    }\n  )\n  == [2]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.forEachWithIndexU",
      "kind": "value",
      "name": "forEachWithIndexU",
      "signature": "let forEachWithIndexU: (t<'a>, (. int, 'a) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.forEachWithIndex",
      "kind": "value",
      "name": "forEachWithIndex",
      "signature": "let forEachWithIndex: (t<'a>, (int, 'a) => unit) => unit",
      "docstrings": ["`forEachWithIndex(xs, f)`\n\n  The same as `Belt.Array.forEach`;\n  except that `f` is supplied two arguments: the index starting from 0 and the element from `xs`.\n\n  ```rescript\n  Belt.Array.forEachWithIndex([\"a\", \"b\", \"c\"], (i, x) => Js.log(\"Item \" ++ Belt.Int.toString(i) ++ \" is \" ++ x))\n\n  /*\n    prints:\n    Item 0 is a\n    Item 1 is b\n    Item 2 is cc\n  */\n  let total = ref(0)\n\n  Belt.Array.forEachWithIndex([10, 11, 12, 13], (i, x) => total := total.contents + x + i)\n\n  total.contents == 0 + 10 + 1 + 11 + 2 + 12 + 3 + 13\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.mapWithIndexU",
      "kind": "value",
      "name": "mapWithIndexU",
      "signature": "let mapWithIndexU: (t<'a>, (. int, 'a) => 'b) => array<'b>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.mapWithIndex",
      "kind": "value",
      "name": "mapWithIndex",
      "signature": "let mapWithIndex: (t<'a>, (int, 'a) => 'b) => array<'b>",
      "docstrings": ["`mapWithIndex(xs, f)`\n\n  `mapWithIndex(xs, f)` applies `f` to each element of `xs`. Function `f` takes two arguments: the index starting from 0 and the element from `xs`.\n\n  ```rescript\n  Belt.Array.mapWithIndex([1, 2, 3], (i, x) => i + x) == [0 + 1, 1 + 2, 2 + 3]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.partitionU",
      "kind": "value",
      "name": "partitionU",
      "signature": "let partitionU: (t<'a>, (. 'a) => bool) => (t<'a>, t<'a>)",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t<'a>, 'a => bool) => (t<'a>, t<'a>)",
      "docstrings": ["`partition(f, a)` split array into tuple of two arrays based on predicate `f`; first of tuple where predicate cause true, second where predicate cause false\n\n  ```rescript\n  Belt.Array.partition([1, 2, 3, 4, 5], (x) => mod(x, 2) == 0) == ([2, 4], [1, 3, 5])\n\n  Belt.Array.partition([1, 2, 3, 4, 5], (x) => mod(x, 2) != 0) == ([1, 3, 5], [2, 4])\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (array<'b>, 'a, (. 'a, 'b) => 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (array<'b>, 'a, ('a, 'b) => 'a) => 'a",
      "docstrings": ["`reduce(xs, init, f)`\n\n  Applies `f` to each element of `xs` from beginning to end. Function `f` has two parameters: the item from the list and an “accumulator”; which starts with a value of `init`. `reduce` returns the final value of the accumulator.\n\n  ```rescript\n  Belt.Array.reduce([2, 3, 4], 1, (a, b) => a + b) == 10\n\n  Belt.Array.reduce([\"a\", \"b\", \"c\", \"d\"], \"\", (a, b) => a ++ b) == \"abcd\"\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.reduceReverseU",
      "kind": "value",
      "name": "reduceReverseU",
      "signature": "let reduceReverseU: (array<'b>, 'a, (. 'a, 'b) => 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.reduceReverse",
      "kind": "value",
      "name": "reduceReverse",
      "signature": "let reduceReverse: (array<'b>, 'a, ('a, 'b) => 'a) => 'a",
      "docstrings": ["`reduceReverse(xs, init, f)`\n\n  Works like `Belt_Array.reduce`; except that function `f` is applied to each item of `xs` from the last back to the first.\n\n  ```rescript\n  Belt.Array.reduceReverse([\"a\", \"b\", \"c\", \"d\"], \"\", (a, b) => a ++ b) == \"dcba\"\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.reduceReverse2U",
      "kind": "value",
      "name": "reduceReverse2U",
      "signature": "let reduceReverse2U: (t<'a>, array<'b>, 'c, (. 'c, 'a, 'b) => 'c) => 'c",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.reduceReverse2",
      "kind": "value",
      "name": "reduceReverse2",
      "signature": "let reduceReverse2: (t<'a>, array<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c",
      "docstrings": ["`reduceReverse2(xs, ys, init, f)`\n\n  Reduces two arrays xs and ys;taking items starting at `min(length(xs), length(ys))` down to and including zero.\n\n  ```rescript\n  Belt.Array.reduceReverse2([1, 2, 3], [1, 2], 0, (acc, x, y) => acc + x + y) == 6\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.reduceWithIndexU",
      "kind": "value",
      "name": "reduceWithIndexU",
      "signature": "let reduceWithIndexU: (t<'a>, 'b, (. 'b, 'a, int) => 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.reduceWithIndex",
      "kind": "value",
      "name": "reduceWithIndex",
      "signature": "let reduceWithIndex: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b",
      "docstrings": ["Applies `f` to each element of `xs` from beginning to end. Function `f` has three parameters: the item from the array and an “accumulator”, which starts with a value of `init` and the index of each element. `reduceWithIndex` returns the final value of the accumulator.\n\n  ```rescript\n  Belt.Array.reduceWithIndex([1, 2, 3, 4], 0, (acc, x, i) => acc + x + i) == 16\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.joinWithU",
      "kind": "value",
      "name": "joinWithU",
      "signature": "let joinWithU: (t<'a>, string, (. 'a) => string) => string",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.joinWith",
      "kind": "value",
      "name": "joinWith",
      "signature": "let joinWith: (t<'a>, string, 'a => string) => string",
      "docstrings": ["`joinWith(xs, sep, toString)`\n\n  Concatenates all the elements of `xs` converted to string with `toString`, each separated by `sep`, the string\n  given as the second argument, into a single string.\n  If the array has only one element, then that element will be returned\n  without using the separator.\n  If the array is empty, the empty string will be returned.\n\n  ```rescript\n  joinWith([0, 1], \", \", string_of_int) == \"0, 1\"\n  joinWith([], \" \", string_of_int) == \"\"\n  joinWith([1], \" \", string_of_int) == \"1\"\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t<'a>, (. 'a) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'a>, 'a => bool) => bool",
      "docstrings": ["`some(xs, p)`\n\n  Returns true if at least one of the elements in `xs` satifies `p`; where `p` is a predicate: a function taking an element and returning a `bool`.\n\n  ```rescript\n  Belt.Array.some([2, 3, 4], (x) => mod(x, 2) == 1) == true\n\n  Belt.Array.some([(-1), (-3), (-5)], (x) => x > 0) == false\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t<'a>, (. 'a) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'a>, 'a => bool) => bool",
      "docstrings": ["`every(xs, p)`\n\n  Returns `true` if all elements satisfy `p`; where `p` is a predicate: a function taking an element and returning a `bool`.\n\n  ```rescript\n  Belt.Array.every([1, 3, 5], (x) => mod(x, 2) == 1) == true\n\n  Belt.Array.every([1, (-3), 5], (x) => x > 0) == false\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.every2U",
      "kind": "value",
      "name": "every2U",
      "signature": "let every2U: (t<'a>, array<'b>, (. 'a, 'b) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.every2",
      "kind": "value",
      "name": "every2",
      "signature": "let every2: (t<'a>, array<'b>, ('a, 'b) => bool) => bool",
      "docstrings": ["`every2(xs, ys, p)`\n\n  returns true if `p(xi, yi)` is true for all pairs of elements up to the shorter length (i.e. `min(length(xs), length(ys))`)\n\n  ```rescript\n  Belt.Array.every2([1, 2, 3], [0, 1], (a, b) => a > b) == true\n\n  Belt.Array.every2([], [1], (x, y) => x > y) == true\n\n  Belt.Array.every2([2, 3], [1], (x, y) => x > y) == true\n\n  Belt.Array.every2([0, 1], [5, 0], (x, y) => x > y) == false\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.some2U",
      "kind": "value",
      "name": "some2U",
      "signature": "let some2U: (t<'a>, array<'b>, (. 'a, 'b) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.some2",
      "kind": "value",
      "name": "some2",
      "signature": "let some2: (t<'a>, array<'b>, ('a, 'b) => bool) => bool",
      "docstrings": ["`some2(xs, ys, p)`\n\n  returns true if `p(xi, yi)` is true for any pair of elements up to the shorter length (i.e. `min(length(xs), length(ys))`)\n\n  ```rescript\n  Belt.Array.some2([0, 2], [1, 0, 3], (a, b) => a > b) == true\n\n  Belt.Array.some2([], [1], (x, y) => x > y) == false\n\n  Belt.Array.some2([2, 3], [1, 4], (x, y) => x > y) == true\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.cmpU",
      "kind": "value",
      "name": "cmpU",
      "signature": "let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int",
      "docstrings": ["`cmp(xs, ys, f)`\n\n  Compared by length if `length(xs) != length(ys)`; returning -1 if `length(xs) < length(ys)` or 1 if `length(xs) > length(ys)`\n  Otherwise compare one by one `f(x, y)`. `f` returns\n  a negative number if `x` is “less than” `y`\n  zero if `x` is “equal to” `y`\n  a positive number if `x` is “greater than” `y`\n  The comparison returns the first non-zero result of `f`;or zero if `f` returns zero for all `x` and `y`.\n\n  ```rescript\n  Belt.Array.cmp([1, 3, 5], [1, 4, 2], (a, b) => compare(a, b)) == -1\n\n  Belt.Array.cmp([1, 3, 5], [1, 2, 3], (a, b) => compare(a, b)) == 1\n\n  Belt.Array.cmp([1, 3, 5], [1, 3, 5], (a, b) => compare(a, b)) == 0\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.eqU",
      "kind": "value",
      "name": "eqU",
      "signature": "let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool",
      "docstrings": ["`eq(xs, ys)`\n\n  return false if length is not the same\n  otherwise compare items one by one using `f(xi, yi)`; and return true if all results are truefalse otherwise\n\n  ```rescript\n  Belt.Array.eq([1, 2, 3], [(-1), (-2), (-3)], (a, b) => abs(a) == abs(b)) == true\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.truncateToLengthUnsafe",
      "kind": "value",
      "name": "truncateToLengthUnsafe",
      "signature": "let truncateToLengthUnsafe: (t<'a>, int) => unit",
      "docstrings": ["Unsafe `truncateToLengthUnsafe(xs, n)` sets length of array `xs` to `n`.\n\n  If `n` is greater than the length of `xs`; the extra elements are set to `Js.Null_undefined.null`.\n\n  If `n` is less than zero; raises a `RangeError`.\n\n  ```rescript\n  let arr = [\"ant\", \"bee\", \"cat\", \"dog\", \"elk\"]\n\n  Belt.Array.truncateToLengthUnsafe(arr, 3)\n\n  arr == [\"ant\", \"bee\", \"cat\"]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Array.initU",
      "kind": "value",
      "name": "initU",
      "signature": "let initU: (int, (. int) => 'a) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.init",
      "kind": "value",
      "name": "init",
      "signature": "let init: (int, int => 'a) => t<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Array.push",
      "kind": "value",
      "name": "push",
      "signature": "let push: (t<'a>, 'a) => unit",
      "docstrings": ["`arr->push(item)` pushes an element `item` into an array `arr`."]
    }]
  }, 
  {
    "id": "Belt.Belt_SortArray",
    "kind": "moduleAlias",
    "name": "SortArray",
    "docstrings": ["[`Belt.SortArray`]()\n\n  The top level provides some generic sort related utilities.\n\n  It also has two specialized inner modules\n  [`Belt.SortArray.Int`]() and [`Belt.SortArray.String`]()"],
    "items": [
    {
      "id": "Belt.Belt_SortArray.Belt_SortArrayInt",
      "kind": "moduleAlias",
      "name": "Int",
      "docstrings": ["Specalized when key type is `int`, more efficient\n    than the generic type"],
      "items": [
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.element",
        "kind": "type",
        "name": "element",
        "signature": "type element = int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.strictlySortedLength",
        "kind": "value",
        "name": "strictlySortedLength",
        "signature": "let strictlySortedLength: array<element> => int",
        "docstrings": ["The same as [`Belt_SortArray.strictlySortedLength`]() except the comparator is fixed\n\n  **return** `+n` means increasing order  `-n` means negative order"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.isSorted",
        "kind": "value",
        "name": "isSorted",
        "signature": "let isSorted: array<element> => bool",
        "docstrings": ["`sorted xs` return true if `xs` is in non strict increasing order"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.stableSortInPlace",
        "kind": "value",
        "name": "stableSortInPlace",
        "signature": "let stableSortInPlace: array<element> => unit",
        "docstrings": ["The same as [`Belt_SortArray.stableSortInPlaceBy`]() except the comparator is fixed"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.stableSort",
        "kind": "value",
        "name": "stableSort",
        "signature": "let stableSort: array<element> => array<element>",
        "docstrings": ["The same as [`Belt_SortArray.stableSortBy`]() except the comparator is fixed"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.binarySearch",
        "kind": "value",
        "name": "binarySearch",
        "signature": "let binarySearch: (array<element>, element) => int",
        "docstrings": ["If value is not found and value is less than one or more elements in array,\n  the negative number returned is the bitwise complement of the index of the first element\n  that is larger than value.\n\n  If value is not found and value is greater than all elements in array,\n  the negative number returned is the bitwise complement of\n  (the index of the last element plus 1)\n\n  for example, if `key` is smaller than all elements return `-1` since `lnot (-1) = 0`\n  if `key` is larger than all elements return `- (len + 1)` since `lnot (-(len+1)) = len`"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.union",
        "kind": "value",
        "name": "union",
        "signature": "let union: (array<element>, int, int, array<element>, int, int, array<element>, int) => int",
        "docstrings": ["`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n  assume `src` and `src2` is strictly sorted.\n  for equivalent elements, it is picked from `src`\n  also assume that `dst` is large enough to store all elements"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.intersect",
        "kind": "value",
        "name": "intersect",
        "signature": "let intersect: (array<element>, int, int, array<element>, int, int, array<element>, int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayInt.diff",
        "kind": "value",
        "name": "diff",
        "signature": "let diff: (array<element>, int, int, array<element>, int, int, array<element>, int) => int",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_SortArray.Belt_SortArrayString",
      "kind": "moduleAlias",
      "name": "String",
      "docstrings": ["Specalized when key type is `string`, more efficient\n    than the generic type"],
      "items": [
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.element",
        "kind": "type",
        "name": "element",
        "signature": "type element = string",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.strictlySortedLength",
        "kind": "value",
        "name": "strictlySortedLength",
        "signature": "let strictlySortedLength: array<element> => int",
        "docstrings": ["The same as [`Belt_SortArray.strictlySortedLength`]() except the comparator is fixed\n\n  **return** `+n` means increasing order  `-n` means negative order"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.isSorted",
        "kind": "value",
        "name": "isSorted",
        "signature": "let isSorted: array<element> => bool",
        "docstrings": ["`sorted xs` return true if `xs` is in non strict increasing order"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.stableSortInPlace",
        "kind": "value",
        "name": "stableSortInPlace",
        "signature": "let stableSortInPlace: array<element> => unit",
        "docstrings": ["The same as [`Belt_SortArray.stableSortInPlaceBy`]() except the comparator is fixed"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.stableSort",
        "kind": "value",
        "name": "stableSort",
        "signature": "let stableSort: array<element> => array<element>",
        "docstrings": ["The same as [`Belt_SortArray.stableSortBy`]() except the comparator is fixed"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.binarySearch",
        "kind": "value",
        "name": "binarySearch",
        "signature": "let binarySearch: (array<element>, element) => int",
        "docstrings": ["If value is not found and value is less than one or more elements in array,\n  the negative number returned is the bitwise complement of the index of the first element\n  that is larger than value.\n\n  If value is not found and value is greater than all elements in array,\n  the negative number returned is the bitwise complement of\n  (the index of the last element plus 1)\n\n  for example, if `key` is smaller than all elements return `-1` since `lnot (-1) = 0`\n  if `key` is larger than all elements return `- (len + 1)` since `lnot (-(len+1)) = len`"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.union",
        "kind": "value",
        "name": "union",
        "signature": "let union: (array<element>, int, int, array<element>, int, int, array<element>, int) => int",
        "docstrings": ["`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n  assume `src` and `src2` is strictly sorted.\n  for equivalent elements, it is picked from `src`\n  also assume that `dst` is large enough to store all elements"]
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.intersect",
        "kind": "value",
        "name": "intersect",
        "signature": "let intersect: (array<element>, int, int, array<element>, int, int, array<element>, int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_SortArray.Belt_SortArrayString.diff",
        "kind": "value",
        "name": "diff",
        "signature": "let diff: (array<element>, int, int, array<element>, int, int, array<element>, int) => int",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_SortArray.strictlySortedLengthU",
      "kind": "value",
      "name": "strictlySortedLengthU",
      "signature": "let strictlySortedLengthU: (array<'a>, (. 'a, 'a) => bool) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.strictlySortedLength",
      "kind": "value",
      "name": "strictlySortedLength",
      "signature": "let strictlySortedLength: (array<'a>, ('a, 'a) => bool) => int",
      "docstrings": ["`strictlySortedLenght(xs, cmp);` return `+n` means increasing order `-n` means negative order\n\n  ```rescript\n  Belt.SortArray.strictlySortedLength([1, 2, 3, 4, 3], (x, y) => x < y) == 4\n\n  Belt.SortArray.strictlySortedLength([], (x, y) => x < y) == 0\n\n  Belt.SortArray.strictlySortedLength([1], (x, y) => x < y) == 1\n\n  Belt.SortArray.strictlySortedLength([4, 3, 2, 1], (x, y) => x < y) == -4\n  ```"]
    }, 
    {
      "id": "Belt.Belt_SortArray.isSortedU",
      "kind": "value",
      "name": "isSortedU",
      "signature": "let isSortedU: (array<'a>, (. 'a, 'a) => int) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.isSorted",
      "kind": "value",
      "name": "isSorted",
      "signature": "let isSorted: (array<'a>, ('a, 'a) => int) => bool",
      "docstrings": ["`isSorted(arr, cmp)`: Returns true if array is increasingly sorted (equal is okay)"]
    }, 
    {
      "id": "Belt.Belt_SortArray.stableSortInPlaceByU",
      "kind": "value",
      "name": "stableSortInPlaceByU",
      "signature": "let stableSortInPlaceByU: (array<'a>, (. 'a, 'a) => int) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.stableSortInPlaceBy",
      "kind": "value",
      "name": "stableSortInPlaceBy",
      "signature": "let stableSortInPlaceBy: (array<'a>, ('a, 'a) => int) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.stableSortByU",
      "kind": "value",
      "name": "stableSortByU",
      "signature": "let stableSortByU: (array<'a>, (. 'a, 'a) => int) => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.stableSortBy",
      "kind": "value",
      "name": "stableSortBy",
      "signature": "let stableSortBy: (array<'a>, ('a, 'a) => int) => array<'a>",
      "docstrings": ["`stableSortBy(xs, cmp)`: Returns a fresh array Sort `xs` in place using\n  comparator `cmp`, the stable means if the elements are equal, their order will\n  be preserved"]
    }, 
    {
      "id": "Belt.Belt_SortArray.binarySearchByU",
      "kind": "value",
      "name": "binarySearchByU",
      "signature": "let binarySearchByU: (array<'a>, 'a, (. 'a, 'a) => int) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.binarySearchBy",
      "kind": "value",
      "name": "binarySearchBy",
      "signature": "let binarySearchBy: (array<'a>, 'a, ('a, 'a) => int) => int",
      "docstrings": ["If value is not found and value is less than one or more elements in array, the\n  negative number returned is the bitwise complement of the index of the first\n  element that is larger than value.\n\n  If value is not found and value is greater\n  than all elements in array, the negative number returned is the bitwise\n  complement of (the index of the last element plus 1)for example, if `key` is\n  smaller than all elements return `-1` since `lnot(-1) == 0` if `key` is larger\n  than all elements return `lnot(-1) == 0` since `lnot(- (len + 1)) == len`\n\n  ```rescript\n  Belt.SortArray.binarySearchBy([1, 2, 3, 4, 33, 35, 36], 33, Pervasives.compare) == 4\n\n  lnot(Belt.SortArray.binarySearchBy([1, 3, 5, 7], 4, Pervasives.compare)) == 2\n  ```"]
    }, 
    {
      "id": "Belt.Belt_SortArray.unionU",
      "kind": "value",
      "name": "unionU",
      "signature": "let unionU: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, (. 'a, 'a) => int) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.union",
      "kind": "value",
      "name": "union",
      "signature": "let union: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, ('a, 'a) => int) => int",
      "docstrings": ["`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n  assume `src` and `src2` is strictly sorted.\n  for equivalent elements, it is picked from `src`\n  also assume that `dst` is large enough to store all elements"]
    }, 
    {
      "id": "Belt.Belt_SortArray.intersectU",
      "kind": "value",
      "name": "intersectU",
      "signature": "let intersectU: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, (. 'a, 'a) => int) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.intersect",
      "kind": "value",
      "name": "intersect",
      "signature": "let intersect: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, ('a, 'a) => int) => int",
      "docstrings": ["`union src src1ofs src1len src2 src2ofs src2len dst dstofs cmp`\n\n  **return** the `offset` in the output array"]
    }, 
    {
      "id": "Belt.Belt_SortArray.diffU",
      "kind": "value",
      "name": "diffU",
      "signature": "let diffU: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, (. 'a, 'a) => int) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_SortArray.diff",
      "kind": "value",
      "name": "diff",
      "signature": "let diff: (array<'a>, int, int, array<'a>, int, int, array<'a>, int, ('a, 'a) => int) => int",
      "docstrings": []
    }]
  }, 
  {
    "id": "Belt.Belt_MutableQueue",
    "kind": "moduleAlias",
    "name": "MutableQueue",
    "docstrings": ["[`Belt.MutableQueue`]()\n\n  An FIFO(first in first out) queue data structure"],
    "items": [
    {
      "id": "Belt.Belt_MutableQueue.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a>",
      "docstrings": ["The type of queues containing elements of `type('a)`."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t<'a>",
      "docstrings": ["Returns a new queue, initially empty."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'a> => unit",
      "docstrings": ["Discard all elements from the queue."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a> => bool",
      "docstrings": ["Returns `true` if the given queue is empty, `false` otherwise."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<'a> => t<'a>",
      "docstrings": ["`fromArray` a is equivalent to `Array.forEach(a, add(q, a));`"]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'a>, 'a) => unit",
      "docstrings": ["`add(q, x)` adds the element `x` at the end of the queue `q`."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.peek",
      "kind": "value",
      "name": "peek",
      "signature": "let peek: t<'a> => option<'a>",
      "docstrings": ["`peekOpt(q)` returns the first element in queue `q`, without removing it from the queue."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.peekUndefined",
      "kind": "value",
      "name": "peekUndefined",
      "signature": "let peekUndefined: t<'a> => Js.undefined<'a>",
      "docstrings": ["`peekUndefined(q)` returns `undefined` if not found."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.peekExn",
      "kind": "value",
      "name": "peekExn",
      "signature": "let peekExn: t<'a> => 'a",
      "docstrings": ["raise an exception if `q` is empty"]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.pop",
      "kind": "value",
      "name": "pop",
      "signature": "let pop: t<'a> => option<'a>",
      "docstrings": ["`pop(q)` removes and returns the first element in queue `q`."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.popUndefined",
      "kind": "value",
      "name": "popUndefined",
      "signature": "let popUndefined: t<'a> => Js.undefined<'a>",
      "docstrings": ["`popUndefined(q)` removes and returns the first element in queue `q`. it will return `undefined` if it is already empty."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.popExn",
      "kind": "value",
      "name": "popExn",
      "signature": "let popExn: t<'a> => 'a",
      "docstrings": ["`popExn(q)` raise an exception if q is empty."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'a> => t<'a>",
      "docstrings": ["`copy(q)` returns a fresh queue."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'a> => int",
      "docstrings": ["Returns the number of elements in a queue."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (t<'a>, (. 'a) => 'b) => t<'b>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableQueue.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableQueue.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'a>, (. 'a) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableQueue.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a>, 'a => unit) => unit",
      "docstrings": ["`forEach(q, f) applies`f`in turn to all elements of`q`, from the least\n  recently entered to the most recently entered. The queue itself is unchanged."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'a>, 'b, (. 'b, 'a) => 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableQueue.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b",
      "docstrings": ["`reduce(q, accu, f)` is equivalent to `List.reduce(l, accu, f)`, where `l` is the list of `q`'s elements. The queue remains unchanged."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.transfer",
      "kind": "value",
      "name": "transfer",
      "signature": "let transfer: (t<'a>, t<'a>) => unit",
      "docstrings": ["`transfer(q1, q2)` adds all of `q1`'s elements at the end of the queue `q2`, then clears `q1`. It is equivalent to the sequence `forEach((x) => add(x, q2), q1);`; clear `q1`, but runs in constant time."]
    }, 
    {
      "id": "Belt.Belt_MutableQueue.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'a> => array<'a>",
      "docstrings": ["First added will be in the beginning of the array."]
    }]
  }, 
  {
    "id": "Belt.Belt_MutableStack",
    "kind": "moduleAlias",
    "name": "MutableStack",
    "docstrings": ["[`Belt.MutableStack`]()\n\n  An FILO(first in last out) stack data structure"],
    "items": [
    {
      "id": "Belt.Belt_MutableStack.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: unit => t<'a>",
      "docstrings": ["Returns a new stack, initially empty."]
    }, 
    {
      "id": "Belt.Belt_MutableStack.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'a> => unit",
      "docstrings": ["Discard all elements from the stack."]
    }, 
    {
      "id": "Belt.Belt_MutableStack.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'a> => t<'a>",
      "docstrings": ["`copy(x)` O(1) operation, return a new stack."]
    }, 
    {
      "id": "Belt.Belt_MutableStack.push",
      "kind": "value",
      "name": "push",
      "signature": "let push: (t<'a>, 'a) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.popUndefined",
      "kind": "value",
      "name": "popUndefined",
      "signature": "let popUndefined: t<'a> => Js.undefined<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.pop",
      "kind": "value",
      "name": "pop",
      "signature": "let pop: t<'a> => option<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.topUndefined",
      "kind": "value",
      "name": "topUndefined",
      "signature": "let topUndefined: t<'a> => Js.undefined<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.top",
      "kind": "value",
      "name": "top",
      "signature": "let top: t<'a> => option<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a> => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'a> => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'a>, (. 'a) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a>, 'a => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.dynamicPopIterU",
      "kind": "value",
      "name": "dynamicPopIterU",
      "signature": "let dynamicPopIterU: (t<'a>, (. 'a) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableStack.dynamicPopIter",
      "kind": "value",
      "name": "dynamicPopIter",
      "signature": "let dynamicPopIter: (t<'a>, 'a => unit) => unit",
      "docstrings": ["`dynamicPopIter(s, f)` apply `f` to each element of `s`. The item is poped\n  before applying `f`, `s` will be empty after this opeartion. This function is\n  useful for worklist algorithm."]
    }]
  }, 
  {
    "id": "Belt.Belt_List",
    "kind": "moduleAlias",
    "name": "List",
    "docstrings": ["[`Belt.List`]()\n\n  Utilities for List data type"],
    "items": [
    {
      "id": "Belt.Belt_List.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a> = list<'a>",
      "docstrings": ["`'a t` is compatible with built-in `list` type"]
    }, 
    {
      "id": "Belt.Belt_List.length",
      "kind": "value",
      "name": "length",
      "signature": "let length: t<'a> => int",
      "docstrings": ["Returns the length of a list.\n\n  ```rescript\n  Belt.List.length(list{1, 2, 3}) // 3\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'a> => int",
      "docstrings": ["**See** [`length`](##length)"]
    }, 
    {
      "id": "Belt.Belt_List.head",
      "kind": "value",
      "name": "head",
      "signature": "let head: t<'a> => option<'a>",
      "docstrings": ["Returns `Some(value)` where `value` is the first element in the list, or\n  `None` if `someList` is an empty list.\n\n  ```rescript\n  Belt.List.head(list{}) // None\n  Belt.List.head(list{1, 2, 3}) // Some(1)\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.headExn",
      "kind": "value",
      "name": "headExn",
      "signature": "let headExn: t<'a> => 'a",
      "docstrings": ["Same as [head](#head), but raises an exception if `someList` is empty. Use\n  with care.\n\n  ```rescript\n  Belt.List.headExn(list{1, 2, 3}) // 1\n\n  Belt.List.headExn(list{}) // Raises an Error\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.tail",
      "kind": "value",
      "name": "tail",
      "signature": "let tail: t<'a> => option<t<'a>>",
      "docstrings": ["Returns `None` if `someList` is empty, otherwise it returns `Some(tail)`\n  where `tail` is everything except the first element of `someList`.\n\n  ```rescript\n  Belt.List.tail(list{1, 2, 3}) // Some(list{2, 3})\n\n  Belt.List.tail(list{}) // None\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.tailExn",
      "kind": "value",
      "name": "tailExn",
      "signature": "let tailExn: t<'a> => t<'a>",
      "docstrings": ["Same as [tail](#tail), but raises an exception if `someList` is empty. Use\n  with care.\n\n  ```rescript\n  Belt.List.tailExn(list{1, 2, 3}) // list{2, 3}\n\n  Belt.List.tailExn(list{}) // Raises an Error\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'a>, 'a) => t<'a>",
      "docstrings": ["Adds `value` to the beginning of `someList`.\n\n  ```rescript\n  Belt.List.add(list{2, 3}, 1) // list{1, 2, 3}\n\n  Belt.List.add(list{\"World\", \"!\"}, \"Hello\") // list{\"Hello\", \"World\", \"!\"}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'a>, int) => option<'a>",
      "docstrings": ["Return the nth element in `someList`, or `None` if `index` is larger than the\n  length.\n\n  ```rescript\n  let abc = list{\"A\", \"B\", \"C\"}\n\n  abc->Belt.List.get(1) // Some(\"B\")\n\n  abc->Belt.List.get(4) // None\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'a>, int) => 'a",
      "docstrings": ["Same as [get](#get), but raises an exception if `index` is larger than the\n  length. Use with care.\n\n  ```rescript\n  let abc = list{\"A\", \"B\", \"C\"}\n\n  abc->Belt.List.getExn(1) // \"B\"\n\n  abc->Belt.List.getExn(4) // Raises an Error\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (int, 'a) => t<'a>",
      "docstrings": ["Returns a list of length `numItems` with each element filled with value `v`. Returns an empty list if `numItems` is negative.\n\n  ```rescript\n  Belt.List.make(3, 1) // list{1, 1, 1}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.makeByU",
      "kind": "value",
      "name": "makeByU",
      "signature": "let makeByU: (int, (. int) => 'a) => t<'a>",
      "docstrings": ["Uncurried version of [makeBy](#makeBy)"]
    }, 
    {
      "id": "Belt.Belt_List.makeBy",
      "kind": "value",
      "name": "makeBy",
      "signature": "let makeBy: (int, int => 'a) => t<'a>",
      "docstrings": ["Return a list of length `numItems` with element `i` initialized with `f(i)`.\nReturns an empty list if `numItems` is negative.\n\n```rescript\nBelt.List.makeBy(5, i => i) // list{0, 1, 2, 3, 4}\n\nBelt.List.makeBy(5, i => i * i) // list{0, 1, 4, 9, 16}\n```"]
    }, 
    {
      "id": "Belt.Belt_List.shuffle",
      "kind": "value",
      "name": "shuffle",
      "signature": "let shuffle: t<'a> => t<'a>",
      "docstrings": ["Returns a new list in random order.\n\n  ```rescript\n  Belt.List.shuffle(list{1, 2, 3}) // list{2, 1, 3}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.drop",
      "kind": "value",
      "name": "drop",
      "signature": "let drop: (t<'a>, int) => option<t<'a>>",
      "docstrings": ["Return a new list, dropping the first `n` elements. Returns `None` if `someList` has fewer than `n` elements.\n\n  ```rescript\n  list{1, 2, 3}->Belt.List.drop(2) // Some(list{3})\n\n  list{1, 2, 3}->Belt.List.drop(3) // Some(list{})\n\n  list{1, 2, 3}->Belt.List.drop(4) // None\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.take",
      "kind": "value",
      "name": "take",
      "signature": "let take: (t<'a>, int) => option<t<'a>>",
      "docstrings": ["Returns a list with the first `n` elements from `someList`, or `None` if `someList` has fewer than `n` elements.\n\n```rescript\nlist{1, 2, 3}->Belt.List.take(1) // Some(list{1})\n\nlist{1, 2, 3}->Belt.List.take(2) // Some(list{1, 2})\n\nlist{1, 2, 3}->Belt.List.take(4) // None\n```"]
    }, 
    {
      "id": "Belt.Belt_List.splitAt",
      "kind": "value",
      "name": "splitAt",
      "signature": "let splitAt: (t<'a>, int) => option<(list<'a>, list<'a>)>",
      "docstrings": ["Split the list `someList` at `index`. Returns `None` when the length of `someList` is less than `index`.\n\n  ```rescript\n  list{\"Hello\", \"World\"}->Belt.List.splitAt(1) // Some((list{\"Hello\"}, list{\"World\"}))\n\n  list{0, 1, 2, 3, 4}->Belt.List.splitAt(2) // Some((list{0, 1}, list{2, 3, 4}))\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.concat",
      "kind": "value",
      "name": "concat",
      "signature": "let concat: (t<'a>, t<'a>) => t<'a>",
      "docstrings": ["Returns the list obtained by adding `secondList` after `firstList`.\n\n  ```rescript\n  Belt.List.concat(list{1, 2, 3}, list{4, 5}) // list{1, 2, 3, 4, 5}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.concatMany",
      "kind": "value",
      "name": "concatMany",
      "signature": "let concatMany: array<t<'a>> => t<'a>",
      "docstrings": ["Returns the list obtained by concatenating all the lists in array `a`, in\n  order.\n\n  ```rescript\n  Belt.List.concatMany([list{1, 2, 3}, list{}, list{3}]) // list{1, 2, 3, 3}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.reverseConcat",
      "kind": "value",
      "name": "reverseConcat",
      "signature": "let reverseConcat: (t<'a>, t<'a>) => t<'a>",
      "docstrings": ["Equivalent to writing: `concat(reverse(firstList, secondList)`\n\n  ```rescript\n  Belt.List.reverseConcat(list{1, 2}, list{3, 4}) // list{2, 1, 3, 4}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.flatten",
      "kind": "value",
      "name": "flatten",
      "signature": "let flatten: t<t<'a>> => t<'a>",
      "docstrings": ["Return the list obtained by concatenating all the lists in list `ls`, in order.\n\n  ```rescript\n  Belt.List.flatten(list{list{1, 2, 3}, list{}, list{3}}) // list{1, 2, 3, 3}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (t<'a>, (. 'a) => 'b) => t<'b>",
      "docstrings": ["Uncurried version of [map](#map)."]
    }, 
    {
      "id": "Belt.Belt_List.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": ["Returns a new list with `f` applied to each element of `someList`.\n\n  ```rescript\n  list{1, 2}->Belt.List.map(x => x + 1) // list{3, 4}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.zip",
      "kind": "value",
      "name": "zip",
      "signature": "let zip: (t<'a>, t<'b>) => t<('a, 'b)>",
      "docstrings": ["Returns a list of pairs from the two lists with the length of the shorter list.\n\n  ```rescript\n  Belt.List.zip(list{1, 2}, list{3, 4, 5}) // list{(1, 3), (2, 4)}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.zipByU",
      "kind": "value",
      "name": "zipByU",
      "signature": "let zipByU: (t<'a>, t<'b>, (. 'a, 'b) => 'c) => t<'c>",
      "docstrings": ["Uncurried version of [zipBy](#zipBy)."]
    }, 
    {
      "id": "Belt.Belt_List.zipBy",
      "kind": "value",
      "name": "zipBy",
      "signature": "let zipBy: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>",
      "docstrings": ["**See:** [zip](#zip)\n\n  ```rescript\n  Belt.List.zipBy(list{1, 2, 3}, list{4, 5}, (a, b) => 2 * a + b) // list{6, 9}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.mapWithIndexU",
      "kind": "value",
      "name": "mapWithIndexU",
      "signature": "let mapWithIndexU: (t<'a>, (. int, 'a) => 'b) => t<'b>",
      "docstrings": ["Uncurried version of [mapWithIndex](#mapWithIndex)."]
    }, 
    {
      "id": "Belt.Belt_List.mapWithIndex",
      "kind": "value",
      "name": "mapWithIndex",
      "signature": "let mapWithIndex: (t<'a>, (int, 'a) => 'b) => t<'b>",
      "docstrings": ["Applies `f` to each element of `someList`.\n  Function `f` takes two arguments: the index starting from 0 and the element from `someList`, in that order.\n\n  ```rescript\n  list{1, 2, 3}->Belt.List.mapWithIndex((index, x) => index + x) // list{1, 3, 5}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: array<'a> => t<'a>",
      "docstrings": ["Converts the given array to a list.\n\n  ```rescript\n  Belt.List.fromArray([1, 2, 3]) // list{1, 2, 3}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'a> => array<'a>",
      "docstrings": ["Converts the given list to an array.\n\n  ```rescript\n  Belt.List.toArray(list{1, 2, 3}) // [1, 2, 3]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.reverse",
      "kind": "value",
      "name": "reverse",
      "signature": "let reverse: t<'a> => t<'a>",
      "docstrings": ["Returns a new list whose elements are those of `someList` in reversed order.\n\n  ```rescript\n  Belt.List.reverse(list{1, 2, 3}) /* list{3, 2, 1} */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.mapReverseU",
      "kind": "value",
      "name": "mapReverseU",
      "signature": "let mapReverseU: (t<'a>, (. 'a) => 'b) => t<'b>",
      "docstrings": ["Uncurried version of [mapReverse](#mapReverse)."]
    }, 
    {
      "id": "Belt.Belt_List.mapReverse",
      "kind": "value",
      "name": "mapReverse",
      "signature": "let mapReverse: (t<'a>, 'a => 'b) => t<'b>",
      "docstrings": ["Equivalent to:\n\n  ```res\n  map(someList, f)->reverse\n  ```\n\n  ```rescript\n  list{3, 4, 5}->Belt.List.mapReverse(x => x * x) /* list{25, 16, 9} */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'a>, (. 'a) => 'b) => unit",
      "docstrings": ["Uncurried version of [forEach](#forEach)."]
    }, 
    {
      "id": "Belt.Belt_List.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a>, 'a => 'b) => unit",
      "docstrings": ["Call `f` on each element of `someList` from the beginning to end.\n  `f` returns `unit`, so no new array is created. Use `forEach` when you are primarily concerned with repetitively creating side effects.\n\n  ```rescript\n  Belt.List.forEach(list{\"a\", \"b\", \"c\"}, x => Js.log(\"Item: \" ++ x))\n  /*\n    prints:\n    Item: a\n    Item: b\n    Item: c\n  */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.forEachWithIndexU",
      "kind": "value",
      "name": "forEachWithIndexU",
      "signature": "let forEachWithIndexU: (t<'a>, (. int, 'a) => 'b) => unit",
      "docstrings": ["Uncurried version of [forEachWithIndex](#forEachWithIndex)."]
    }, 
    {
      "id": "Belt.Belt_List.forEachWithIndex",
      "kind": "value",
      "name": "forEachWithIndex",
      "signature": "let forEachWithIndex: (t<'a>, (int, 'a) => 'b) => unit",
      "docstrings": ["Call `f` on each element of `someList` from beginning to end.\n  Function `f` takes two arguments: the index starting from 0 and the element from `someList`. `f` returns `unit`.\n\n  ```rescript\n  Belt.List.forEachWithIndex(list{\"a\", \"b\", \"c\"}, (index, x) => {\n    Js.log(\"Item \" ++ Belt.Int.toString(index) ++ \" is \" ++ x)\n  })\n  /*\n    prints:\n    Item 0 is a\n    Item 1 is b\n    Item 2 is cc\n  */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'a>, 'b, (. 'b, 'a) => 'b) => 'b",
      "docstrings": ["Uncurried version of [reduce](#reduce)."]
    }, 
    {
      "id": "Belt.Belt_List.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b",
      "docstrings": ["Applies `f` to each element of `someList` from beginning to end. Function `f` has two parameters: the item from the list and an “accumulator”, which starts with a value of `initialValue`. reduce returns the final value of the accumulator.\n\n  ```rescript\n  list{1, 2, 3, 4}->Belt.List.reduce(0, (a, b) => a + b) /* 10 */\n\n  /* same as */\n\n  list{1, 2, 3, 4}->Belt.List.reduce(0, (acc, item) => acc + item) /* 10 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.reduceWithIndexU",
      "kind": "value",
      "name": "reduceWithIndexU",
      "signature": "let reduceWithIndexU: (t<'a>, 'b, (. 'b, 'a, int) => 'b) => 'b",
      "docstrings": ["Uncurried version of [reduceWithIndex](#reduceWithIndex)."]
    }, 
    {
      "id": "Belt.Belt_List.reduceWithIndex",
      "kind": "value",
      "name": "reduceWithIndex",
      "signature": "let reduceWithIndex: (t<'a>, 'b, ('b, 'a, int) => 'b) => 'b",
      "docstrings": ["Applies `f` to each element of `someList` from beginning to end. Function `f` has three parameters: the item from the list and an “accumulator”, which starts with a value of `initialValue` and the index of each element. `reduceWithIndex` returns the final value of the accumulator.\n\n  ```rescript\n  list{1, 2, 3, 4}->Belt.List.reduceWithIndex(0, (acc, item, index) => acc + item + index) /* 16 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.reduceReverseU",
      "kind": "value",
      "name": "reduceReverseU",
      "signature": "let reduceReverseU: (t<'a>, 'b, (. 'b, 'a) => 'b) => 'b",
      "docstrings": ["Uncurried version of [reduceReverse](#reduceReverse)."]
    }, 
    {
      "id": "Belt.Belt_List.reduceReverse",
      "kind": "value",
      "name": "reduceReverse",
      "signature": "let reduceReverse: (t<'a>, 'b, ('b, 'a) => 'b) => 'b",
      "docstrings": ["Works like [reduce](#reduce), except that function `f` is applied to each\n  item of `someList` from the last back to the first.\n\n  ```rescript\n  list{1, 2, 3, 4}->Belt.List.reduceReverse(0, (a, b) => a + b) /* 10 */\n\n  list{1, 2, 3, 4}->Belt.List.reduceReverse(10, (a, b) => a - b) /* 0 */\n\n  list{1, 2, 3, 4}->Belt.List.reduceReverse(list{}, Belt.List.add) // list{1, 2, 3, 4}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.mapReverse2U",
      "kind": "value",
      "name": "mapReverse2U",
      "signature": "let mapReverse2U: (t<'a>, t<'b>, (. 'a, 'b) => 'c) => t<'c>",
      "docstrings": ["Uncurried version of [mapReverse2](#mapReverse2)."]
    }, 
    {
      "id": "Belt.Belt_List.mapReverse2",
      "kind": "value",
      "name": "mapReverse2",
      "signature": "let mapReverse2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>",
      "docstrings": ["Equivalent to: `zipBy(xs, ys, f)->reverse`\n\n  ```rescript\n\n  Belt.List.mapReverse2(list{1, 2, 3}, list{1, 2}, (a, b) => a + b) // list{4, 2}\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.forEach2U",
      "kind": "value",
      "name": "forEach2U",
      "signature": "let forEach2U: (t<'a>, t<'b>, (. 'a, 'b) => 'c) => unit",
      "docstrings": ["Uncurried version of [forEach2](#forEach2)."]
    }, 
    {
      "id": "Belt.Belt_List.forEach2",
      "kind": "value",
      "name": "forEach2",
      "signature": "let forEach2: (t<'a>, t<'b>, ('a, 'b) => 'c) => unit",
      "docstrings": ["Stops at the length of the shorter list.\n\n  ```rescript\n  Belt.List.forEach2(list{\"Z\", \"Y\"}, list{\"A\", \"B\", \"C\"}, (x, y) => Js.log2(x, y))\n\n  /*\n    prints:\n    \"Z\" \"A\"\n    \"Y\" \"B\"\n  */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.reduce2U",
      "kind": "value",
      "name": "reduce2U",
      "signature": "let reduce2U: (t<'b>, t<'c>, 'a, (. 'a, 'b, 'c) => 'a) => 'a",
      "docstrings": ["Uncurried version of [reduce2](#reduce2)."]
    }, 
    {
      "id": "Belt.Belt_List.reduce2",
      "kind": "value",
      "name": "reduce2",
      "signature": "let reduce2: (t<'b>, t<'c>, 'a, ('a, 'b, 'c) => 'a) => 'a",
      "docstrings": ["Applies `f` to each element of `firstList` and `secondList` from beginning to end. Stops with the shorter list. Function `f` has three parameters: an “accumulator” which starts with a value of `initialValue`, an item from `firstList`, and an item from `secondList`. `reduce2` returns the final value of the accumulator.\n\n  ```rescript\n  Belt.List.reduce2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) /* 0 + (1 * 1 + 4) + (2 * 2 + 5) */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.reduceReverse2U",
      "kind": "value",
      "name": "reduceReverse2U",
      "signature": "let reduceReverse2U: (t<'a>, t<'b>, 'c, (. 'c, 'a, 'b) => 'c) => 'c",
      "docstrings": ["Uncurried version of [reduceReverse2](#reduceReverse2)."]
    }, 
    {
      "id": "Belt.Belt_List.reduceReverse2",
      "kind": "value",
      "name": "reduceReverse2",
      "signature": "let reduceReverse2: (t<'a>, t<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c",
      "docstrings": ["Applies `f` to each element of `firstList` and `secondList` from end to\n  beginning. Stops with the shorter list. Function `f` has three parameters: an\n  “accumulator” which starts with a value of init, an item from `firstList`,\n  and an item from `secondList`. `reduce2` returns the final value of the\n  accumulator.\n\n  ```rescript\n  Belt.List.reduceReverse2(list{1, 2, 3}, list{4, 5}, 0, (acc, x, y) => acc + x * x + y) /*  + (1 * 1 + 4) + (2 * 2 + 5) */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t<'a>, (. 'a) => bool) => bool",
      "docstrings": ["Uncurried version of [every](#every)."]
    }, 
    {
      "id": "Belt.Belt_List.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'a>, 'a => bool) => bool",
      "docstrings": ["Returns `true` if all elements satisfy `pred`, where `pred` is a predicate: a function taking an element and returning a bool.\n\n  ```rescript\n  let isBelow10 = value => value < 10\n\n  list{1, 9, 8, 2}->Belt.List.every(isBelow10) /* true */\n\n  list{1, 99, 8, 2}->Belt.List.every(isBelow10) /* false */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t<'a>, (. 'a) => bool) => bool",
      "docstrings": ["Uncurried version of [some](#some)."]
    }, 
    {
      "id": "Belt.Belt_List.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'a>, 'a => bool) => bool",
      "docstrings": ["Returns `true` if at least _one_ of the elements in `someList` satisfies\n  `pred`, where `pred` is a predicate: a function taking an element and\n  returning a bool.\n\n  ```rescript\n  let isAbove100 = value => value > 100\n\n  list{101, 1, 2, 3}->Belt.List.some(isAbove100) /* true */\n\n  list{1, 2, 3, 4}->Belt.List.some(isAbove100) /* false */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.every2U",
      "kind": "value",
      "name": "every2U",
      "signature": "let every2U: (t<'a>, t<'b>, (. 'a, 'b) => bool) => bool",
      "docstrings": ["Uncurried version of [every2](#every2)."]
    }, 
    {
      "id": "Belt.Belt_List.every2",
      "kind": "value",
      "name": "every2",
      "signature": "let every2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool",
      "docstrings": ["Returns `true` if predicate `pred(a, b)` is `true` for all pairs of elements\n  up to the shorter length (i.e. `min(length(firstList), length(secondList))`)\n\n  ```rescript\n  Belt.List.every2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) /* true */\n\n  Belt.List.every2(list{}, list{1}, (a, b) => a > b) /* true */\n\n  Belt.List.every2(list{2, 3}, list{1}, (a, b) => a > b) /* true */\n\n  Belt.List.every2(list{0, 1}, list{5, 0}, (a, b) => a > b) /* false */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.some2U",
      "kind": "value",
      "name": "some2U",
      "signature": "let some2U: (t<'a>, t<'b>, (. 'a, 'b) => bool) => bool",
      "docstrings": ["Uncurried version of [some2](#some2)."]
    }, 
    {
      "id": "Belt.Belt_List.some2",
      "kind": "value",
      "name": "some2",
      "signature": "let some2: (t<'a>, t<'b>, ('a, 'b) => bool) => bool",
      "docstrings": ["Returns `true` if predicate `pred(a, b)` is true for any pair of elements up\n  to the shorter length (i.e. `min(length(firstList), length(secondList))`)\n\n  ```rescript\n  Belt.List.some2(list{1, 2, 3}, list{0, 1}, (a, b) => a > b) /* true */\n\n  Belt.List.some2(list{}, list{1}, (a, b) => a > b) /* false */\n\n  Belt.List.some2(list{2, 3}, list{1}, (a, b) => a > b) /* true */\n\n  Belt.List.some2(list{0, 1}, list{5, 0}, (a, b) => a > b) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.cmpByLength",
      "kind": "value",
      "name": "cmpByLength",
      "signature": "let cmpByLength: (t<'a>, t<'a>) => int",
      "docstrings": ["Compare two lists solely by length. Returns `-1` if `length(firstList)` is\n  less than `length(secondList)`, `0` if `length(firstList)` equals\n  `length(secondList)`, and `1` if `length(firstList)` is greater than\n  `length(secondList)`.\n\n  ```rescript\n  Belt.List.cmpByLength(list{1, 2}, list{3, 4, 5, 6}) /* -1 */\n\n  Belt.List.cmpByLength(list{1, 2, 3}, list{4, 5, 6}) /* = 0 */\n\n  Belt.List.cmpByLength(list{1, 2, 3, 4}, list{5, 6}) /* = 1 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.cmpU",
      "kind": "value",
      "name": "cmpU",
      "signature": "let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int",
      "docstrings": ["Uncurried version of [cmp](#cmp)."]
    }, 
    {
      "id": "Belt.Belt_List.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int",
      "docstrings": ["Compare elements one by one `compareFn(a, b)`. `compareFn` returns a negative number if `a` is \"less than\" `b`, zero if `a` is \"equal to\" `b`, a positive number if `a` is \"greater than\" `b`.\n\n  The comparison returns the first non-zero result of `compareFn`, or zero if `compareFn` returns zero for all `a` and `b`.\n\n  If all items have compared equal, but `firstList` is exhausted first, return `-1`. (`firstList` is shorter).\n  If all items have compared equal, but `secondList` is exhausted first, return `1` (`firstList` is longer).\n\n  ```rescript\n  Belt.List.cmp(list{3}, list{3, 7}, (a, b) => compare(a, b)) /* (-1) */\n\n  Belt.List.cmp(list{5, 3}, list{5}, (a, b) => compare(a, b)) /* 1 */\n\n  Belt.List.cmp(list{1, 3, 5}, list{1, 4, 2}, (a, b) => compare(a, b)) /* (-1) */\n\n  Belt.List.cmp(list{1, 3, 5}, list{1, 2, 3}, (a, b) => compare(a, b)) /* 1 */\n\n  Belt.List.cmp(list{1, 3, 5}, list{1, 3, 5}, (a, b) => compare(a, b)) /* 0 */\n  ```\n\n  **Please note:** The total ordering of List is different from Array,\n  for Array, we compare the length first and, only if the lengths are equal, elements one by one.\n  For lists, we just compare elements one by one."]
    }, 
    {
      "id": "Belt.Belt_List.eqU",
      "kind": "value",
      "name": "eqU",
      "signature": "let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool",
      "docstrings": ["Uncurried version of [eq](#eq)."]
    }, 
    {
      "id": "Belt.Belt_List.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool",
      "docstrings": ["Check equality of `firstList` and `secondList` using `eqElem` for equality on\n  elements, where `eqElem` is a function that returns `true` if items `x` and\n  `y` meet some criterion for equality, `false` otherwise. eq `false` if length\n  of `firstList` and `secondList` are not the same.\n\n  ```rescript\n  Belt.List.eq(list{1, 2, 3}, list{1, 2}, (a, b) => a == b) /* false */\n\n  Belt.List.eq(list{1, 2}, list{1, 2}, (a, b) => a == b) /* true */\n\n  Belt.List.eq(list{1, 2, 3}, list{(-1), (-2), (-3)}, (a, b) => abs(a) == abs(b)) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.hasU",
      "kind": "value",
      "name": "hasU",
      "signature": "let hasU: (t<'a>, 'b, (. 'a, 'b) => bool) => bool",
      "docstrings": ["Uncurried version of [has](#has)."]
    }, 
    {
      "id": "Belt.Belt_List.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'a>, 'b, ('a, 'b) => bool) => bool",
      "docstrings": ["Returns `true` if the list contains at least one element for which\n  `eqFunction(x)` returns true.\n\n  ```rescript\n  list{1, 2, 3}->Belt.List.has(2, (a, b) => a == b) /* true */\n\n  list{1, 2, 3}->Belt.List.has(4, (a, b) => a == b) /* false */\n\n  list{(-1), (-2), (-3)}->Belt.List.has(2, (a, b) => abs(a) == abs(b)) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.getByU",
      "kind": "value",
      "name": "getByU",
      "signature": "let getByU: (t<'a>, (. 'a) => bool) => option<'a>",
      "docstrings": ["Uncurried version of [getBy](#getBy)."]
    }, 
    {
      "id": "Belt.Belt_List.getBy",
      "kind": "value",
      "name": "getBy",
      "signature": "let getBy: (t<'a>, 'a => bool) => option<'a>",
      "docstrings": ["Returns `Some(value)` for the first value in `someList` that satisfies the\n  predicate function `pred`. Returns `None` if no element satisfies the function.\n\n  ```rescript\n  Belt.List.getBy(list{1, 4, 3, 2}, x => x > 3) /* Some(4) */\n\n  Belt.List.getBy(list{1, 4, 3, 2}, x => x > 4) /* None */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (t<'a>, (. 'a) => bool) => t<'a>",
      "docstrings": ["Uncurried version of [keep](#keep)."]
    }, 
    {
      "id": "Belt.Belt_List.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (t<'a>, 'a => bool) => t<'a>",
      "docstrings": ["Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  Belt.List.keep(list{1, 2, 3, 4}, isEven) /* list{2, 4} */\n\n  Belt.List.keep(list{None, Some(2), Some(3), None}, Belt.Option.isSome) /* list{Some(2), Some(3)} */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.filter",
      "kind": "value",
      "name": "filter",
      "deprecated": "This function will soon be deprecated. Please, use `List.keep` instead.",
      "signature": "let filter: (t<'a>, 'a => bool) => t<'a>",
      "docstrings": ["Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  Belt.List.filter(list{1, 2, 3, 4}, isEven) /* list{2, 4} */\n\n  Belt.List.filter(list{None, Some(2), Some(3), None}, Belt.Option.isSome) /* list{Some(2), Some(3)} */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.keepWithIndexU",
      "kind": "value",
      "name": "keepWithIndexU",
      "signature": "let keepWithIndexU: (t<'a>, (. 'a, int) => bool) => t<'a>",
      "docstrings": ["Uncurried version of [keepWithIndex](#keepWithIndex)."]
    }, 
    {
      "id": "Belt.Belt_List.keepWithIndex",
      "kind": "value",
      "name": "keepWithIndex",
      "signature": "let keepWithIndex: (t<'a>, ('a, int) => bool) => t<'a>",
      "docstrings": ["Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  Belt.List.keepWithIndex(list{1, 2, 3, 4}, (_x, index) => isEven(index)) /* list{1, 3} */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.filterWithIndex",
      "kind": "value",
      "name": "filterWithIndex",
      "deprecated": "This function will soon be deprecated. Please, use `List.keepWithIndex` \\\n     instead.",
      "signature": "let filterWithIndex: (t<'a>, ('a, int) => bool) => t<'a>",
      "docstrings": ["Returns a list of all elements in `someList` which satisfy the predicate function `pred`.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  Belt.List.filterWithIndex(list{1, 2, 3, 4}, (_x, index) => isEven(index)) /* list{1, 3} */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.keepMapU",
      "kind": "value",
      "name": "keepMapU",
      "signature": "let keepMapU: (t<'a>, (. 'a) => option<'b>) => t<'b>",
      "docstrings": ["Uncurried version of [keepMap](#keepMap)."]
    }, 
    {
      "id": "Belt.Belt_List.keepMap",
      "kind": "value",
      "name": "keepMap",
      "signature": "let keepMap: (t<'a>, 'a => option<'b>) => t<'b>",
      "docstrings": ["Applies `f` to each element of `someList`. If `f(x)` returns `Some(value)`, then `value` is _kept_ in the resulting list.\n  If `f(x)` returns `None`, the element is _not_ retained in the result.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  list{1, 2, 3, 4}\n  ->Belt.List.keepMap(x =>\n      if (isEven(x)) {\n        Some(x)\n      } else {\n        None\n      }\n    ) /* list{2, 4} */\n\n  list{Some(1), Some(2), None}->Belt.List.keepMap(x => x) /* list{1, 2} */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.partitionU",
      "kind": "value",
      "name": "partitionU",
      "signature": "let partitionU: (t<'a>, (. 'a) => bool) => (t<'a>, t<'a>)",
      "docstrings": ["Uncurried version of [partition](#partition)."]
    }, 
    {
      "id": "Belt.Belt_List.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t<'a>, 'a => bool) => (t<'a>, t<'a>)",
      "docstrings": ["Creates a pair of lists; the first list consists of all elements of `someList` that satisfy the predicate function `pred`; the second list consists of all elements of `someList` that _do not_ satisfy `pred.\n\n  In other words:\n\n  ```res\n  (elementsThatSatisfies, elementsThatDoesNotSatisfy)\n  ```\n\n  ```rescript\n  Belt.List.partition(list{1, 2, 3, 4}, x => x > 2) /* (list{3, 4}, list{1, 2}) */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.unzip",
      "kind": "value",
      "name": "unzip",
      "signature": "let unzip: t<('a, 'b)> => (t<'a>, t<'b>)",
      "docstrings": ["Takes a list of pairs and creates a pair of lists. The first list contains all the first items of the pairs; the second list contains all the second items.\n\n  ```rescript\n  Belt.List.unzip(list{(1, 2), (3, 4)}) /* (list{1, 3}, list{2, 4}) */\n\n  Belt.List.unzip(list{(\"H\", \"W\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"l\", \"l\"), (\"o\", \"d\"), (\" \", \"!\")})\n  /* (list{\"H\", \"e\", \"l\", \"l\", \"o\", \" \"}, list{\"W\", \"o\", \"r\", \"l\", \"d\", \"!\"}) */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.getAssocU",
      "kind": "value",
      "name": "getAssocU",
      "signature": "let getAssocU: (t<('a, 'c)>, 'b, (. 'a, 'b) => bool) => option<'c>",
      "docstrings": ["Uncurried version of [getAssoc](#getAssoc)."]
    }, 
    {
      "id": "Belt.Belt_List.getAssoc",
      "kind": "value",
      "name": "getAssoc",
      "signature": "let getAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => option<'c>",
      "docstrings": ["Return the second element of a pair in `someList` where the first element equals `k` as per the predicate function `eqFunction`, or `None` if not found.\n\n  ```rescript\n  list{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.getAssoc(3, (a, b) => a == b) /* Some(\"c\") */\n\n  list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n  ->Belt.List.getAssoc(15, (k, item) => k /* 15 */ == item /* 9, 5, 22 */)\n  /* Some(\"afternoon\") */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.hasAssocU",
      "kind": "value",
      "name": "hasAssocU",
      "signature": "let hasAssocU: (t<('a, 'c)>, 'b, (. 'a, 'b) => bool) => bool",
      "docstrings": ["Uncurried version of [hasAssoc](#hasAssoc)."]
    }, 
    {
      "id": "Belt.Belt_List.hasAssoc",
      "kind": "value",
      "name": "hasAssoc",
      "signature": "let hasAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => bool",
      "docstrings": ["Returns `true` if there is a pair in `someList` where the first element equals `k` as per the predicate function `eqFunction`.\n\n  ```rescript\n  list{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.hasAssoc(1, (a, b) => a == b) /* true */\n\n  list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n  ->Belt.List.hasAssoc(25, (k, item) => k /* 25 */ == item /* 9, 5, 22 */) /* false */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.removeAssocU",
      "kind": "value",
      "name": "removeAssocU",
      "signature": "let removeAssocU: (t<('a, 'c)>, 'b, (. 'a, 'b) => bool) => t<('a, 'c)>",
      "docstrings": ["Uncurried version of [removeAssoc](#removeAssoc)."]
    }, 
    {
      "id": "Belt.Belt_List.removeAssoc",
      "kind": "value",
      "name": "removeAssoc",
      "signature": "let removeAssoc: (t<('a, 'c)>, 'b, ('a, 'b) => bool) => t<('a, 'c)>",
      "docstrings": ["Return a list after removing the first pair whose first value is `k` per the equality predicate `eqFunction`; if not found, return a new list identical to `someList`.\n\n  ```rescript\n  list{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.removeAssoc(1, (a, b) => a == b) /* list{(2, \"b\"), (3, \"c\")} */\n\n  list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")}\n  ->Belt.List.removeAssoc(9, (k, item) => k /* 9 */ == item /* 9, 5, 22 */)\n  /* list{(15, \"afternoon\"), (22, \"night\")} */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_List.setAssocU",
      "kind": "value",
      "name": "setAssocU",
      "signature": "let setAssocU: (t<('a, 'c)>, 'a, 'c, (. 'a, 'a) => bool) => t<('a, 'c)>",
      "docstrings": ["Uncurried version of [setAssoc](#setAssoc)."]
    }, 
    {
      "id": "Belt.Belt_List.setAssoc",
      "kind": "value",
      "name": "setAssoc",
      "signature": "let setAssoc: (t<('a, 'c)>, 'a, 'c, ('a, 'a) => bool) => t<('a, 'c)>",
      "docstrings": ["If `k` exists in `someList` by satisfying the `eqFunction` predicate, return a new list with the key and value replaced by the new `k` and `v`; otherwise, return a new list with the pair `k`, `v` added to the head of `someList`.\n\n  ```rescript\n  list{(1, \"a\"), (2, \"b\"), (3, \"c\")}->Belt.List.setAssoc(2, \"x\", (a, b) => a == b) /* list{(1, \"a\"), (2, \"x\"), (3, \"c\")} */\n\n  list{(1, \"a\"), (3, \"c\")}->Belt.List.setAssoc(2, \"b\", (a, b) => a == b) /* list{(2, \"b\"), (1, \"a\"), (3, \"c\")} */\n\n  list{(9, \"morning\"), (3, \"morning?!\"), (22, \"night\")}\n  ->Belt.List.setAssoc(15, \"afternoon\", (a, b) => mod(a, 12) == mod(b, 12))\n  /* list{(9, \"morning\"), (15, \"afternoon\"), (22, \"night\")} */\n  ```\n\n  **Please note**\n\n  In the last example, since: `15 mod 12` equals `3 mod 12`\n\n  Both the key _and_ the value are replaced in the list."]
    }, 
    {
      "id": "Belt.Belt_List.sortU",
      "kind": "value",
      "name": "sortU",
      "signature": "let sortU: (t<'a>, (. 'a, 'a) => int) => t<'a>",
      "docstrings": ["Uncurried version of [sort](#sort)."]
    }, 
    {
      "id": "Belt.Belt_List.sort",
      "kind": "value",
      "name": "sort",
      "signature": "let sort: (t<'a>, ('a, 'a) => int) => t<'a>",
      "docstrings": ["Returns a sorted list.\n\n  ```rescript\n  Belt.List.sort(list{5, 4, 9, 3, 7}, (a, b) => a - b) // list{3, 4, 5, 7, 9}\n  ```"]
    }]
  }, 
  {
    "id": "Belt.Belt_Range",
    "kind": "moduleAlias",
    "name": "Range",
    "docstrings": ["[`Belt.Range`]()\n\n  Utilities for a closed range `(from, start)`"],
    "items": [
    {
      "id": "Belt.Belt_Range.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (int, int, (. int) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Range.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (int, int, int => unit) => unit",
      "docstrings": ["`forEach(start, finish, action)`\n\n  equivalent to `Belt.Array.(forEach(range(start, finish), action))`\n\n  ```rescript\n  Belt.Range.forEach(0, 4, (i) => Js.log(i))\n\n  /**\n   * prints:\n   *   0\n   *   1\n   *   2\n   *   3\n   *   4\n   */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Range.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (int, int, (. int) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Range.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (int, int, int => bool) => bool",
      "docstrings": ["`every(start, finish, p)`\n\n  equivalent to `Belt.Array.(every(range(start, finish), p))`\n\n  ```rescript\n  Belt.Range.every(0, 4, (i) => i < 5) /* true */\n\n  Belt.Range.every(0, 4, (i) => i < 4) /* false */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Range.everyByU",
      "kind": "value",
      "name": "everyByU",
      "signature": "let everyByU: (int, int, ~step: int, (. int) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Range.everyBy",
      "kind": "value",
      "name": "everyBy",
      "signature": "let everyBy: (int, int, ~step: int, int => bool) => bool",
      "docstrings": ["`everyBy(start, finish, ~step, p)`\n\n  See `Belt_Array.rangeBy`\n\n  equivalent to `Belt.Array.(every(rangeBy(start, finish, ~step), p))`\n\n  ```rescript\n  Belt.Range.everyBy(0, 4, ~step=1, (i) => mod(i, 2) === 0) /* false */\n\n  Belt.Range.everyBy(0, 4, ~step=2, (i) => mod(i, 2) === 0) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Range.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (int, int, (. int) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Range.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (int, int, int => bool) => bool",
      "docstrings": ["`some(start, finish, p)`\n\n  equivalent to `Belt.Array.(some(range(start, finish), p))`\n\n  ```rescript\n  Belt.Range.some(0, 4, (i) => i > 5) /* false */\n\n  Belt.Range.some(0, 4, (i) => i > 2) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Range.someByU",
      "kind": "value",
      "name": "someByU",
      "signature": "let someByU: (int, int, ~step: int, (. int) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Range.someBy",
      "kind": "value",
      "name": "someBy",
      "signature": "let someBy: (int, int, ~step: int, int => bool) => bool",
      "docstrings": ["`someBy(start, finish, ~step, p)`\n\n  See `Belt_Array.rangeBy`\n\n  equivalent to `Belt.Array.(some(rangeBy(start, finish, ~step), p))`\n\n  ```rescript\n  Belt.Range.someBy(1, 5, ~step=2, (i) => mod(i, 2) === 0) /* false */\n  Belt.Range.someBy(0, 4, ~step=2, (i) => mod(i, 2) === 0) /* true */\n  ```"]
    }]
  }, 
  {
    "id": "Belt.Belt_Set",
    "kind": "moduleAlias",
    "name": "Set",
    "docstrings": ["[`Belt.Set`]()\n\n  The top level provides generic **immutable** set operations.\n\n  It also has three specialized inner modules\n  [`Belt.Set.Int`](), [`Belt.Set.String`]() and\n\n  [`Belt.Set.Dict`](): This module separates data from function\n  which is more verbose but slightly more efficient"],
    "items": [
    {
      "id": "Belt.Belt_Set.Belt_SetInt",
      "kind": "moduleAlias",
      "name": "Int",
      "docstrings": ["Specialized when value type is `int`, more efficient\n  than the generic type, its compare behavior is fixed using the built-in comparison"],
      "items": [
      {
        "id": "Belt.Belt_Set.Belt_SetInt.value",
        "kind": "type",
        "name": "value",
        "signature": "type value = int",
        "docstrings": ["The type of the set elements."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": ["The type of sets."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.empty",
        "kind": "value",
        "name": "empty",
        "signature": "let empty: t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<value> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "signature": "let fromSortedArrayUnsafe: array<value> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t, value) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.add",
        "kind": "value",
        "name": "add",
        "signature": "let add: (t, value) => t",
        "docstrings": ["`add s x` If `x` was already in `s`, `s` is returned unchanged."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t, array<value>) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t, value) => t",
        "docstrings": ["`remove m x` If `x` was not in `m`, `m` is returned reference unchanged."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t, array<value>) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.union",
        "kind": "value",
        "name": "union",
        "signature": "let union: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.intersect",
        "kind": "value",
        "name": "intersect",
        "signature": "let intersect: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.diff",
        "kind": "value",
        "name": "diff",
        "signature": "let diff: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.subset",
        "kind": "value",
        "name": "subset",
        "signature": "let subset: (t, t) => bool",
        "docstrings": ["`subset s1 s2` tests whether the set `s1` is a subset of\n    the set `s2`."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t, t) => int",
        "docstrings": ["Total ordering between sets. Can be used as the ordering function\n    for doing sets of sets."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t, t) => bool",
        "docstrings": ["`eq s1 s2` tests whether the sets `s1` and `s2` are\n    equal, that is, contain equal elements."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t, (. value) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t, value => unit) => unit",
        "docstrings": ["`forEach s f` applies `f` in turn to all elements of `s`.\n    In increasing order"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a",
        "docstrings": ["Iterate in increasing order."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t, (. value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t, value => bool) => bool",
        "docstrings": ["`every p s` checks if all elements of the set\n    satisfy the predicate `p`. Order unspecified."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t, (. value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t, value => bool) => bool",
        "docstrings": ["`some p s` checks if at least one element of\n    the set satisfies the predicate `p`. Oder unspecified."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.keepU",
        "kind": "value",
        "name": "keepU",
        "signature": "let keepU: (t, (. value) => bool) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.keep",
        "kind": "value",
        "name": "keep",
        "signature": "let keep: (t, value => bool) => t",
        "docstrings": ["`keep p s` returns the set of all elements in `s`\n    that satisfy predicate `p`."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.partitionU",
        "kind": "value",
        "name": "partitionU",
        "signature": "let partitionU: (t, (. value) => bool) => (t, t)",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.partition",
        "kind": "value",
        "name": "partition",
        "signature": "let partition: (t, value => bool) => (t, t)",
        "docstrings": ["`partition p s` returns a pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t => list<value>",
        "docstrings": ["In increasing order"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t => array<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t, value) => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t, value) => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t, value) => value",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.split",
        "kind": "value",
        "name": "split",
        "signature": "let split: (t, value) => ((t, t), bool)",
        "docstrings": ["`split x s` returns a triple `(l, present, r)`, where\n  `l` is the set of elements of `s` that are\n  strictly less than `x`;\n  `r` is the set of elements of `s` that are\n  strictly greater than `x`;\n  `present` is `false` if `s` contains no element equal to `x`,\n  or `true` if `s` contains an element equal to `x`."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetInt.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }]
    }, 
    {
      "id": "Belt.Belt_Set.Belt_SetString",
      "kind": "moduleAlias",
      "name": "String",
      "docstrings": ["Specialized when value type is `string`, more efficient\n  than the generic type, its compare behavior is fixed using the built-in comparison"],
      "items": [
      {
        "id": "Belt.Belt_Set.Belt_SetString.value",
        "kind": "type",
        "name": "value",
        "signature": "type value = string",
        "docstrings": ["The type of the set elements."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": ["The type of sets."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.empty",
        "kind": "value",
        "name": "empty",
        "signature": "let empty: t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<value> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "signature": "let fromSortedArrayUnsafe: array<value> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t, value) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.add",
        "kind": "value",
        "name": "add",
        "signature": "let add: (t, value) => t",
        "docstrings": ["`add s x` If `x` was already in `s`, `s` is returned unchanged."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t, array<value>) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t, value) => t",
        "docstrings": ["`remove m x` If `x` was not in `m`, `m` is returned reference unchanged."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t, array<value>) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.union",
        "kind": "value",
        "name": "union",
        "signature": "let union: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.intersect",
        "kind": "value",
        "name": "intersect",
        "signature": "let intersect: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.diff",
        "kind": "value",
        "name": "diff",
        "signature": "let diff: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.subset",
        "kind": "value",
        "name": "subset",
        "signature": "let subset: (t, t) => bool",
        "docstrings": ["`subset s1 s2` tests whether the set `s1` is a subset of\n    the set `s2`."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t, t) => int",
        "docstrings": ["Total ordering between sets. Can be used as the ordering function\n    for doing sets of sets."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t, t) => bool",
        "docstrings": ["`eq s1 s2` tests whether the sets `s1` and `s2` are\n    equal, that is, contain equal elements."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t, (. value) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t, value => unit) => unit",
        "docstrings": ["`forEach s f` applies `f` in turn to all elements of `s`.\n    In increasing order"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a",
        "docstrings": ["Iterate in increasing order."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t, (. value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t, value => bool) => bool",
        "docstrings": ["`every p s` checks if all elements of the set\n    satisfy the predicate `p`. Order unspecified."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t, (. value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t, value => bool) => bool",
        "docstrings": ["`some p s` checks if at least one element of\n    the set satisfies the predicate `p`. Oder unspecified."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.keepU",
        "kind": "value",
        "name": "keepU",
        "signature": "let keepU: (t, (. value) => bool) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.keep",
        "kind": "value",
        "name": "keep",
        "signature": "let keep: (t, value => bool) => t",
        "docstrings": ["`keep p s` returns the set of all elements in `s`\n    that satisfy predicate `p`."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.partitionU",
        "kind": "value",
        "name": "partitionU",
        "signature": "let partitionU: (t, (. value) => bool) => (t, t)",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.partition",
        "kind": "value",
        "name": "partition",
        "signature": "let partition: (t, value => bool) => (t, t)",
        "docstrings": ["`partition p s` returns a pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t => list<value>",
        "docstrings": ["In increasing order"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t => array<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t, value) => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t, value) => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t, value) => value",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.split",
        "kind": "value",
        "name": "split",
        "signature": "let split: (t, value) => ((t, t), bool)",
        "docstrings": ["`split x s` returns a triple `(l, present, r)`, where\n  `l` is the set of elements of `s` that are\n  strictly less than `x`;\n  `r` is the set of elements of `s` that are\n  strictly greater than `x`;\n  `present` is `false` if `s` contains no element equal to `x`,\n  or `true` if `s` contains an element equal to `x`."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetString.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }]
    }, 
    {
      "id": "Belt.Belt_Set.Belt_SetDict",
      "kind": "moduleAlias",
      "name": "Dict",
      "docstrings": ["This module separates identity from data, it is a bit more verbose but slightly\n  more efficient due to the fact that there is no need to pack identity and data back\n  after each operation"],
      "items": [
      {
        "id": "Belt.Belt_Set.Belt_SetDict.t",
        "kind": "type",
        "name": "t",
        "signature": "type t<'value, 'identity>",
        "docstrings": ["`'value` is the element type\n\n  `'identity` the identity of the collection"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.cmp",
        "kind": "type",
        "name": "cmp",
        "signature": "type cmp<'value, 'id> = Belt_Id.cmp<'value, 'id>",
        "docstrings": ["Type of compare function."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.empty",
        "kind": "value",
        "name": "empty",
        "signature": "let empty: t<'value, 'id>",
        "docstrings": ["```rescript\n  let s0 = Belt.Set.Dict.empty\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: (array<'value>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>",
        "docstrings": ["Creates new set from array of elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([1, 3, 2, 4], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.toArray /* [1, 2, 3, 4] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "signature": "let fromSortedArrayUnsafe: array<'value> => t<'value, 'id>",
        "docstrings": ["The same as [fromArray][#fromarray] except it is after assuming the input array is already sorted."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t<'a, 'b> => bool",
        "docstrings": ["Checks if set is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let empty = Belt.Set.Dict.fromArray([], ~cmp=IntCmp.cmp)\n  let notEmpty = Belt.Set.Dict.fromArray([1], ~cmp=IntCmp.cmp)\n\n  Belt.Set.Dict.isEmpty(empty) /* true */\n  Belt.Set.Dict.isEmpty(notEmpty) /* false */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => bool",
        "docstrings": ["Checks if an element exists in the set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.Set.Dict.fromArray([1, 4, 2, 5], ~cmp=IntCmp.cmp)\n\n  set->Belt.Set.Dict.has(3, ~cmp=IntCmp.cmp) /* false */\n  set->Belt.Set.Dict.has(1, ~cmp=IntCmp.cmp) /* true */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.add",
        "kind": "value",
        "name": "add",
        "signature": "let add: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => t<'value, 'id>",
        "docstrings": ["Adds element to set. If element existed in set, value is unchanged.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = s0->Belt.Set.Dict.add(1, ~cmp=IntCmp.cmp)\n  let s2 = s1->Belt.Set.Dict.add(2, ~cmp=IntCmp.cmp)\n  let s3 = s2->Belt.Set.Dict.add(2, ~cmp=IntCmp.cmp)\n  s0->Belt.Set.Dict.toArray /* [] */\n  s1->Belt.Set.Dict.toArray /* [1] */\n  s2->Belt.Set.Dict.toArray /* [1, 2] */\n  s3->Belt.Set.Dict.toArray /* [1,2 ] */\n  s2 == s3 /* true */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t<'value, 'id>, array<'value>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>",
        "docstrings": ["Adds each element of array to set. Unlike [add](#add), the reference of return value might be changed even if all values in array already exist in set\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.Set.Dict.empty\n\n  let newSet = set->Belt.Set.Dict.mergeMany([5, 4, 3, 2, 1], ~cmp=IntCmp.cmp)\n  newSet->Belt.Set.Dict.toArray /* [1, 2, 3, 4, 5] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => t<'value, 'id>",
        "docstrings": ["Removes element from set. If element did not exist in set, value is unchanged.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([2, 3, 1, 4, 5], ~cmp=IntCmp.cmp)\n  let s1 = s0->Belt.Set.Dict.remove(1, ~cmp=IntCmp.cmp)\n  let s2 = s1->Belt.Set.Dict.remove(3, ~cmp=IntCmp.cmp)\n  let s3 = s2->Belt.Set.Dict.remove(3, ~cmp=IntCmp.cmp)\n\n  s1->Belt.Set.Dict.toArray /* [2,3,4,5] */\n  s2->Belt.Set.Dict.toArray /* [2,4,5] */\n  s2 == s3 /* true */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t<'value, 'id>, array<'value>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>",
        "docstrings": ["Removes each element of array from set. Unlike [remove](#remove), the reference of return value might be changed even if any values in array not existed in set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.Set.Dict.fromArray([1, 2, 3, 4], ~cmp=IntCmp.cmp)\n\n  let newSet = set->Belt.Set.Dict.removeMany([5, 4, 3, 2, 1], ~cmp=IntCmp.cmp)\n  newSet->Belt.Set.Dict.toArray /* [] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.union",
        "kind": "value",
        "name": "union",
        "signature": "let union: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>",
        "docstrings": ["Returns union of two sets.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n  let union = Belt.Set.Dict.union(s0, s1, ~cmp=IntCmp.cmp)\n  union->Belt.Set.Dict.toArray /* [1,2,3,4,5,6] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.intersect",
        "kind": "value",
        "name": "intersect",
        "signature": "let intersect: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>",
        "docstrings": ["Returns intersection of two sets.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n  let intersect = Belt.Set.Dict.intersect(s0, s1, ~cmp=IntCmp.cmp)\n  intersect->Belt.Set.Dict.toArray /* [2,3,5] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.diff",
        "kind": "value",
        "name": "diff",
        "signature": "let diff: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => t<'value, 'id>",
        "docstrings": ["Returns elements from first set, not existing in second set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n\n  let diff1 = Belt.Set.Dict.diff(s0, s1, ~cmp=IntCmp.cmp)\n  let diff2 = Belt.Set.Dict.diff(s1, s0, ~cmp=IntCmp.cmp)\n\n  diff1->Belt.Set.Dict.toArray /* [6] */\n  diff2->Belt.Set.Dict.toArray /* [1,4] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.subset",
        "kind": "value",
        "name": "subset",
        "signature": "let subset: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => bool",
        "docstrings": ["Checks if second set is subset of first set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([5, 2, 3, 1, 5, 4], ~cmp=IntCmp.cmp)\n  let s2 = Belt.Set.Dict.intersect(s0, s1, ~cmp=IntCmp.cmp)\n  Belt.Set.Dict.subset(s2, s0, ~cmp=IntCmp.cmp) /* true */\n  Belt.Set.Dict.subset(s2, s1, ~cmp=IntCmp.cmp) /* true */\n  Belt.Set.Dict.subset(s1, s0, ~cmp=IntCmp.cmp) /* false */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => int",
        "docstrings": ["Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compares size first and then iterates over each element following the order of elements."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t<'value, 'id>, t<'value, 'id>, ~cmp: cmp<'value, 'id>) => bool",
        "docstrings": ["Checks if two sets are equal.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3], ~cmp=IntCmp.cmp)\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 5], ~cmp=IntCmp.cmp)\n\n  Belt.Set.Dict.eq(s0, s1, ~cmp=IntCmp.cmp) /* true */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t<'value, 'id>, (. 'value) => unit) => unit",
        "docstrings": ["Same as [forEach](##forEach) but takes uncurried functon."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit",
        "docstrings": ["Applies function `f` in turn to all elements of set in increasing order.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  let acc = ref(list{})\n  s0->Belt.Set.Dict.forEach(x => acc := Belt.List.add(acc.contents, x))\n  acc /* [6,5,3,2] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t<'value, 'id>, 'a, (. 'a, 'value) => 'a) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a",
        "docstrings": ["Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an “accumulator”, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([5, 2, 3, 5, 6], ~cmp=IntCmp.cmp)\n  s0->Belt.Set.Dict.reduce(list{}, (acc, element) => acc->Belt.List.add(element)) /* [6,5,3,2] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t<'value, 'id>, (. 'value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t<'value, 'id>, 'value => bool) => bool",
        "docstrings": ["Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.Set.Dict.fromArray([2, 4, 6, 8], ~cmp=IntCmp.cmp)\n  s0->Belt.Set.Dict.every(isEven) /* true */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t<'value, 'id>, (. 'value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t<'value, 'id>, 'value => bool) => bool",
        "docstrings": ["Checks if at least one element of the set satisfies the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 4, 6, 8], ~cmp=IntCmp.cmp)\n  s0->Belt.Set.Dict.some(isOdd) /* true */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.keepU",
        "kind": "value",
        "name": "keepU",
        "signature": "let keepU: (t<'value, 'id>, (. 'value) => bool) => t<'value, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.keep",
        "kind": "value",
        "name": "keep",
        "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>",
        "docstrings": ["Returns the set of all elements that satisfy the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n  let s1 = s0->Belt.Set.Dict.keep(isEven)\n\n  s1->Belt.Set.Dict.toArray /* [2,4] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.partitionU",
        "kind": "value",
        "name": "partitionU",
        "signature": "let partitionU: (t<'value, 'id>, (. 'value) => bool) => (t<'value, 'id>, t<'value, 'id>)",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.partition",
        "kind": "value",
        "name": "partition",
        "signature": "let partition: (t<'value, 'id>, 'value => bool) => (t<'value, 'id>, t<'value, 'id>)",
        "docstrings": ["Returns a pair of sets, where first is the set of all the elements of set that satisfy the predicate, and second is the set of all the elements of set that do not satisfy the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n  let (s1, s2) = s0->Belt.Set.Dict.partition(isOdd)\n\n  s1->Belt.Set.Dict.toArray /* [1,3,5] */\n  s2->Belt.Set.Dict.toArray /* [2,4] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t<'value, 'id> => int",
        "docstrings": ["Returns size of the set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.size /* 4 */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t<'value, 'id> => list<'value>",
        "docstrings": ["Returns list of ordered set elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.toList /* [1,2,3,5] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t<'value, 'id> => array<'value>",
        "docstrings": ["Returns array of ordered set elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.toArray /* [1,2,3,5] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t<'value, 'id> => option<'value>",
        "docstrings": ["Returns minimum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.minimum /* None */\n  s1->Belt.Set.Dict.minimum /* Some(1) */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>",
        "docstrings": ["Returns minimum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.minUndefined /* undefined */\n  s1->Belt.Set.Dict.minUndefined /* 1 */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t<'value, 'id> => option<'value>",
        "docstrings": ["Returns maximum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.maximum /* None */\n  s1->Belt.Set.Dict.maximum /* Some(5) */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>",
        "docstrings": ["Returns maximum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.empty\n  let s1 = Belt.Set.Dict.fromArray([3, 2, 1, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.maxUndefined /* undefined */\n  s1->Belt.Set.Dict.maxUndefined /* 5 */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => option<'value>",
        "docstrings": ["Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n\n  s0->Belt.Set.Dict.get(3, ~cmp=IntCmp.cmp) /* Some(3) */\n  s0->Belt.Set.Dict.get(20, ~cmp=IntCmp.cmp) /* None */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => Js.undefined<'value>",
        "docstrings": ["Same as [get](#get) but returns `undefined` when element does not exist."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t<'value, 'id>, 'value, ~cmp: cmp<'value, 'id>) => 'value",
        "docstrings": ["Same as [get](#get) but raise when element does not exist."]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.split",
        "kind": "value",
        "name": "split",
        "signature": "let split: (\\n  t<'value, 'id>,\\n  'value,\\n  ~cmp: cmp<'value, 'id>,\\n) => ((t<'value, 'id>, t<'value, 'id>), bool)",
        "docstrings": ["Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.Set.Dict.fromArray([1, 2, 3, 4, 5], ~cmp=IntCmp.cmp)\n\n  let ((smaller, larger), present) = s0->Belt.Set.Dict.split(3, ~cmp=IntCmp.cmp)\n\n  present /* true */\n  smaller->Belt.Set.Dict.toArray /* [1,2] */\n  larger->Belt.Set.Dict.toArray /* [4,5] */\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Set.Belt_SetDict.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t<'a, 'b> => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }]
    }, 
    {
      "id": "Belt.Belt_Set.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'value, 'identity>",
      "docstrings": ["`'value` is the element type\n\n  `'identity` the identity of the collection"]
    }, 
    {
      "id": "Belt.Belt_Set.id",
      "kind": "type",
      "name": "id",
      "signature": "type id<'value, 'id> = Belt_Id.comparable<'value, 'id>",
      "docstrings": ["The identity needed for making a set from scratch"]
    }, 
    {
      "id": "Belt.Belt_Set.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (~id: id<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Creates a new set by taking in the comparator\n\n  ```rescript\n  let set = Belt.Set.make(~id=module(IntCmp))\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Creates new set from array of elements.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\n  s0->Belt.Set.toArray /* [1, 2, 3, 4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.fromSortedArrayUnsafe",
      "kind": "value",
      "name": "fromSortedArrayUnsafe",
      "signature": "let fromSortedArrayUnsafe: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["The same as [fromArray][#fromarray] except it is after assuming the input array is already sorted."]
    }, 
    {
      "id": "Belt.Belt_Set.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a, 'b> => bool",
      "docstrings": ["Checks if set is empty.\n\n   ```rescript\n   let empty = Belt.Set.fromArray([], ~id=module(IntCmp))\n   let notEmpty = Belt.Set.fromArray([1],~id=module(IntCmp))\n\n   Belt.Set.isEmpty(empty) /* true */\n   Belt.Set.isEmpty(notEmpty) /* false */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Set.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'value, 'id>, 'value) => bool",
      "docstrings": ["Checks if element exists in set.\n\n   ```rescript\n   let set = Belt.Set.fromArray([1, 4, 2, 5], ~id=module(IntCmp))\n\n   set->Belt.Set.has(3) /* false */\n   set->Belt.Set.has(1) /* true */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Set.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'value, 'id>, 'value) => t<'value, 'id>",
      "docstrings": ["Adds element to set. If element existed in set, value is unchanged.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = s0->Belt.Set.add(1)\n  let s2 = s1->Belt.Set.add(2)\n  let s3 = s2->Belt.Set.add(2)\n  s0->Belt.Set.toArray /* [] */\n  s1->Belt.Set.toArray /* [1] */\n  s2->Belt.Set.toArray /* [1, 2] */\n  s3->Belt.Set.toArray /* [1,2 ] */\n  s2 == s3 /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t<'value, 'id>, array<'value>) => t<'value, 'id>",
      "docstrings": ["Adds each element of array to set. Unlike [add](#add), the reference of return value might be changed even if all values in array already exist in set\n\n  ```rescript\n  let set = Belt.Set.make(~id=module(IntCmp))\n\n  let newSet = set->Belt.Set.mergeMany([5, 4, 3, 2, 1])\n  newSet->Belt.Set.toArray /* [1, 2, 3, 4, 5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'value, 'id>, 'value) => t<'value, 'id>",
      "docstrings": ["Removes element from set. If element did not exist in set, value is unchanged.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([2,3,1,4,5], ~id=module(IntCmp))\n  let s1 = s0->Belt.Set.remove(1)\n  let s2 = s1->Belt.Set.remove(3)\n  let s3 = s2->Belt.Set.remove(3)\n\n  s1->Belt.Set.toArray /* [2,3,4,5] */\n  s2->Belt.Set.toArray /* [2,4,5] */\n  s2 == s3 /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.removeMany",
      "kind": "value",
      "name": "removeMany",
      "signature": "let removeMany: (t<'value, 'id>, array<'value>) => t<'value, 'id>",
      "docstrings": ["Removes each element of array from set. Unlike [remove](#remove), the reference of return value might be changed even if none of values in array existed in set.\n\n  ```rescript\n  let set = Belt.Set.fromArray([1, 2, 3, 4],~id=module(IntCmp))\n\n  let newSet = set->Belt.Set.removeMany([5, 4, 3, 2, 1])\n  newSet->Belt.Set.toArray /* [] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.union",
      "kind": "value",
      "name": "union",
      "signature": "let union: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Returns union of two sets.\n\n   ```rescript\n   let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n   let s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\n   let union = Belt.Set.union(s0, s1)\n   union->Belt.Set.toArray /* [1,2,3,4,5,6] */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Set.intersect",
      "kind": "value",
      "name": "intersect",
      "signature": "let intersect: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Returns intersection of two sets.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\n  let intersect = Belt.Set.intersect(s0, s1)\n  intersect->Belt.Set.toArray /* [2,3,5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.diff",
      "kind": "value",
      "name": "diff",
      "signature": "let diff: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Returns elements from first set, not existing in second set.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\n  Belt.Set.toArray(Belt.Set.diff(s0, s1)) /* [6] */\n  Belt.Set.toArray(Belt.Set.diff(s1,s0)) /* [1,4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.subset",
      "kind": "value",
      "name": "subset",
      "signature": "let subset: (t<'value, 'id>, t<'value, 'id>) => bool",
      "docstrings": ["Checks if second set is subset of first set.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([5,2,3,1,5,4], ~id=module(IntCmp))\n  let s2 = Belt.Set.intersect(s0, s1)\n  Belt.Set.subset(s2, s0) /* true */\n  Belt.Set.subset(s2, s1) /* true */\n  Belt.Set.subset(s1, s0) /* false */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'value, 'id>, t<'value, 'id>) => int",
      "docstrings": ["Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compares size first and then iterates over each element following the order of elements."]
    }, 
    {
      "id": "Belt.Belt_Set.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'value, 'id>, t<'value, 'id>) => bool",
      "docstrings": ["Checks if two sets are equal.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3], ~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,5], ~id=module(IntCmp))\n\n  Belt.Set.eq(s0, s1) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'value, 'id>, (. 'value) => unit) => unit",
      "docstrings": ["Same as [forEach](##forEach) but takes uncurried functon."]
    }, 
    {
      "id": "Belt.Belt_Set.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit",
      "docstrings": ["Applies function `f` in turn to all elements of set in increasing order.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  let acc = ref(list{})\n  s0->Belt.Set.forEach(x => {\n    acc := Belt.List.add(acc.contents, x)\n  })\n  acc /* [6,5,3,2] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'value, 'id>, 'a, (. 'a, 'value) => 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Set.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a",
      "docstrings": ["Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an “accumulator”, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([5,2,3,5,6], ~id=module(IntCmp))\n  s0->Belt.Set.reduce(list{}, (acc, element) =>\n    acc->Belt.List.add(element)\n  ) /* [6,5,3,2] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t<'value, 'id>, (. 'value) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Set.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'value, 'id>, 'value => bool) => bool",
      "docstrings": ["Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.Set.fromArray([2,4,6,8], ~id=module(IntCmp))\n  s0->Belt.Set.every(isEven) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t<'value, 'id>, (. 'value) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Set.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'value, 'id>, 'value => bool) => bool",
      "docstrings": ["Checks if at least one element of the set satisfies the predicate.\n\n  ```rescript\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.Set.fromArray([1,2,4,6,8], ~id=module(IntCmp))\n  s0->Belt.Set.some(isOdd) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (t<'value, 'id>, (. 'value) => bool) => t<'value, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Set.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>",
      "docstrings": ["Returns the set of all elements that satisfy the predicate.\n\n  ```rescript\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n  let s1 = s0->Belt.Set.keep(isEven)\n\n  s1->Belt.Set.toArray /* [2,4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.partitionU",
      "kind": "value",
      "name": "partitionU",
      "signature": "let partitionU: (t<'value, 'id>, (. 'value) => bool) => (t<'value, 'id>, t<'value, 'id>)",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Set.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t<'value, 'id>, 'value => bool) => (t<'value, 'id>, t<'value, 'id>)",
      "docstrings": ["Returns a pair of sets, where first is the set of all the elements of set that satisfy the predicate, and second is the set of all the elements of set that do not satisfy the predicate.\n\n  ```rescript\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n  let (s1, s2) = s0->Belt.Set.partition(isOdd)\n\n  s1->Belt.Set.toArray /* [1,3,5] */\n  s2->Belt.Set.toArray /* [2,4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'value, 'id> => int",
      "docstrings": ["Returns size of the set.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([1,2,3,4], ~id=module(IntCmp))\n\n  s0->Belt.Set.size /* 4 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'value, 'id> => array<'value>",
      "docstrings": ["Returns array of ordered set elements.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.toArray /* [1,2,3,5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.toList",
      "kind": "value",
      "name": "toList",
      "signature": "let toList: t<'value, 'id> => list<'value>",
      "docstrings": ["Returns list of ordered set elements.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.toList /* [1,2,3,5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.minimum",
      "kind": "value",
      "name": "minimum",
      "signature": "let minimum: t<'value, 'id> => option<'value>",
      "docstrings": ["Returns minimum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.minimum /* None */\n  s1->Belt.Set.minimum /* Some(1) */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.minUndefined",
      "kind": "value",
      "name": "minUndefined",
      "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>",
      "docstrings": ["Returns minimum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.minUndefined /* undefined */\n  s1->Belt.Set.minUndefined /* 1 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.maximum",
      "kind": "value",
      "name": "maximum",
      "signature": "let maximum: t<'value, 'id> => option<'value>",
      "docstrings": ["Returns maximum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.maximum /* None */\n  s1->Belt.Set.maximum /* Some(5) */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.maxUndefined",
      "kind": "value",
      "name": "maxUndefined",
      "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>",
      "docstrings": ["Returns maximum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  let s0 = Belt.Set.make(~id=module(IntCmp))\n  let s1 = Belt.Set.fromArray([3,2,1,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.maxUndefined /* undefined */\n  s1->Belt.Set.maxUndefined /* 5 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'value, 'id>, 'value) => option<'value>",
      "docstrings": ["Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n\n  s0->Belt.Set.get(3) /* Some(3) */\n  s0->Belt.Set.get(20) /* None */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.getUndefined",
      "kind": "value",
      "name": "getUndefined",
      "signature": "let getUndefined: (t<'value, 'id>, 'value) => Js.undefined<'value>",
      "docstrings": ["Same as [get](#get) but returns `undefined` when element does not exist."]
    }, 
    {
      "id": "Belt.Belt_Set.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'value, 'id>, 'value) => 'value",
      "docstrings": ["Same as [get](#get) but raise when element does not exist."]
    }, 
    {
      "id": "Belt.Belt_Set.split",
      "kind": "value",
      "name": "split",
      "signature": "let split: (t<'value, 'id>, 'value) => ((t<'value, 'id>, t<'value, 'id>), bool)",
      "docstrings": ["Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n  ```rescript\n  let s0 = Belt.Set.fromArray([1,2,3,4,5], ~id=module(IntCmp))\n\n  let ((smaller, larger), present) = s0->Belt.Set.split(3)\n\n  present /* true */\n  smaller->Belt.Set.toArray /* [1,2] */\n  larger->Belt.Set.toArray /* [4,5] */\n\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Set.checkInvariantInternal",
      "kind": "value",
      "name": "checkInvariantInternal",
      "signature": "let checkInvariantInternal: t<'a, 'b> => unit",
      "docstrings": ["**raise** when invariant is not held"]
    }, 
    {
      "id": "Belt.Belt_Set.getData",
      "kind": "value",
      "name": "getData",
      "signature": "let getData: t<'value, 'id> => Belt_SetDict.t<'value, 'id>",
      "docstrings": ["**Advanced usage only**\n\n  Returns the raw data (detached from comparator), but its type is still manifested, so that user can pass identity directly without boxing."]
    }, 
    {
      "id": "Belt.Belt_Set.getId",
      "kind": "value",
      "name": "getId",
      "signature": "let getId: t<'value, 'id> => id<'value, 'id>",
      "docstrings": ["**Advanced usage only**\n\n  Returns the identity of set."]
    }, 
    {
      "id": "Belt.Belt_Set.packIdData",
      "kind": "value",
      "name": "packIdData",
      "signature": "let packIdData: (~id: id<'value, 'id>, ~data: Belt_SetDict.t<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["**Advanced usage only**\n\n  Returns the packed collection."]
    }]
  }, 
  {
    "id": "Belt.Belt_Map",
    "kind": "moduleAlias",
    "name": "Map",
    "docstrings": ["[`Belt.Map`](),\n\n  The top level provides generic **immutable** map operations.\n\n  It also has three specialized inner modules\n  [`Belt.Map.Int`](), [`Belt.Map.String`]() and\n\n  [`Belt.Map.Dict`](): This module separates data from function\n  which  is more verbose but slightly more efficient"],
    "items": [
    {
      "id": "Belt.Belt_Map.Belt_MapInt",
      "kind": "moduleAlias",
      "name": "Int",
      "docstrings": ["```rescript\ntype t<'key, 'value, 'identity>\ntype id<'key, 'id> = Belt_Id.comparable<'key, 'id>\n```"],
      "items": [
      {
        "id": "Belt.Belt_Map.Belt_MapInt.key",
        "kind": "type",
        "name": "key",
        "signature": "type key = int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.t",
        "kind": "type",
        "name": "t",
        "signature": "type t<'value>",
        "docstrings": ["The type of maps from type `key` to type `'value`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.empty",
        "kind": "value",
        "name": "empty",
        "signature": "let empty: t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t<'v> => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t<'v>, key) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.cmpU",
        "kind": "value",
        "name": "cmpU",
        "signature": "let cmpU: (t<'v>, t<'v>, (. 'v, 'v) => int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t<'v>, t<'v>, ('v, 'v) => int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.eqU",
        "kind": "value",
        "name": "eqU",
        "signature": "let eqU: (t<'v>, t<'v>, (. 'v, 'v) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t<'v>, t<'v>, ('v, 'v) => bool) => bool",
        "docstrings": ["`eq m1 m2` tests whether the maps `m1` and `m2` are\n  equal, that is, contain equal keys and associate them with\n  equal data."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "signature": "let findFirstByU: (t<'v>, (. key, 'v) => bool) => option<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "signature": "let findFirstBy: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>",
        "docstrings": ["`findFirstBy m p` uses funcion `f` to find the first key value pair\n  to match predicate `p`.\n\n  ```\n  let s0 = fromArray ~id:(module IntCmp) [|4,\"4\";1,\"1\";2,\"2,\"3\"\"|];;\n  findFirstBy s0 (fun k v -> k = 4 ) = option (4, \"4\");;\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t<'v>, (. key, 'v) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t<'v>, (key, 'v) => unit) => unit",
        "docstrings": ["`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument. The bindings are passed to `f` in increasing\n  order with respect to the ordering over the type of the keys."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t<'v>, 'v2, (. 'v2, key, 'v) => 'v2) => 'v2",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2",
        "docstrings": ["`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t<'v>, (. key, 'v) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t<'v>, (key, 'v) => bool) => bool",
        "docstrings": ["`every m p` checks if all the bindings of the map\n    satisfy the predicate `p`. Order unspecified"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t<'v>, (. key, 'v) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t<'v>, (key, 'v) => bool) => bool",
        "docstrings": ["`some m p` checks if at least one binding of the map\n    satisfy the predicate `p`. Order unspecified"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t<'v> => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t<'v> => list<(key, 'v)>",
        "docstrings": ["In increasing order."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t<'v> => array<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<(key, 'v)> => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "signature": "let keysToArray: t<'v> => array<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "signature": "let valuesToArray: t<'v> => array<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.minKey",
        "kind": "value",
        "name": "minKey",
        "signature": "let minKey: t<'a> => option<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.maxKey",
        "kind": "value",
        "name": "maxKey",
        "signature": "let maxKey: t<'a> => option<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t<'v> => option<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t<'v> => Js.undefined<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t<'v> => option<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t<'v> => Js.undefined<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t<'v>, key) => option<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t<'v>, key) => Js.undefined<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "signature": "let getWithDefault: (t<'v>, key, 'v) => 'v",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t<'v>, key) => 'v",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t<'a> => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t<'v>, key) => t<'v>",
        "docstrings": ["`remove m x` returns a map containing the same bindings as\n    `m`, except for `x` which is unbound in the returned map."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t<'v>, array<key>) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.set",
        "kind": "value",
        "name": "set",
        "signature": "let set: (t<'v>, key, 'v) => t<'v>",
        "docstrings": ["`set m x y` returns a map containing the same bindings as\n  `m`, plus a binding of `x` to `y`. If `x` was already bound\n  in `m`, its previous binding disappears."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.updateU",
        "kind": "value",
        "name": "updateU",
        "signature": "let updateU: (t<'v>, key, (. option<'v>) => option<'v>) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.update",
        "kind": "value",
        "name": "update",
        "signature": "let update: (t<'v>, key, option<'v> => option<'v>) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.mergeU",
        "kind": "value",
        "name": "mergeU",
        "signature": "let mergeU: (t<'v>, t<'v2>, (. key, option<'v>, option<'v2>) => option<'c>) => t<'c>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.merge",
        "kind": "value",
        "name": "merge",
        "signature": "let merge: (t<'v>, t<'v2>, (key, option<'v>, option<'v2>) => option<'c>) => t<'c>",
        "docstrings": ["`merge m1 m2 f` computes a map whose keys is a subset of keys of `m1`\n  and of `m2`. The presence of each such binding, and the corresponding\n  value, is determined with the function `f`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t<'v>, array<(key, 'v)>) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.keepU",
        "kind": "value",
        "name": "keepU",
        "signature": "let keepU: (t<'v>, (. key, 'v) => bool) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.keep",
        "kind": "value",
        "name": "keep",
        "signature": "let keep: (t<'v>, (key, 'v) => bool) => t<'v>",
        "docstrings": ["`keep m p` returns the map with all the bindings in `m`\n    that satisfy predicate `p`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.partitionU",
        "kind": "value",
        "name": "partitionU",
        "signature": "let partitionU: (t<'v>, (. key, 'v) => bool) => (t<'v>, t<'v>)",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.partition",
        "kind": "value",
        "name": "partition",
        "signature": "let partition: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)",
        "docstrings": ["`partition m p` returns a pair of maps `(m1, m2)`, where\n  `m1` contains all the bindings of `s` that satisfy the\n  predicate `p`, and `m2` is the map with all the bindings of\n  `s` that do not satisfy `p`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.split",
        "kind": "value",
        "name": "split",
        "signature": "let split: (key, t<'v>) => (t<'v>, option<'v>, t<'v>)",
        "docstrings": ["`split x m` returns a triple `(l, data, r)`, where\n  `l` is the map with all the bindings of `m` whose key\n  is strictly less than `x`;\n  `r` is the map with all the bindings of `m` whose key\n  is strictly greater than `x`;\n  `data` is `None` if `m` contains no binding for `x`,\n  or `Some v` if `m` binds `v` to `x`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.mapU",
        "kind": "value",
        "name": "mapU",
        "signature": "let mapU: (t<'v>, (. 'v) => 'v2) => t<'v2>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.map",
        "kind": "value",
        "name": "map",
        "signature": "let map: (t<'v>, 'v => 'v2) => t<'v2>",
        "docstrings": ["`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "signature": "let mapWithKeyU: (t<'v>, (. key, 'v) => 'v2) => t<'v2>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapInt.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "signature": "let mapWithKey: (t<'v>, (key, 'v) => 'v2) => t<'v2>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_Map.Belt_MapString",
      "kind": "moduleAlias",
      "name": "String",
      "docstrings": [],
      "items": [
      {
        "id": "Belt.Belt_Map.Belt_MapString.key",
        "kind": "type",
        "name": "key",
        "signature": "type key = string",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.t",
        "kind": "type",
        "name": "t",
        "signature": "type t<'value>",
        "docstrings": ["The type of maps from type `key` to type `'value`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.empty",
        "kind": "value",
        "name": "empty",
        "signature": "let empty: t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t<'v> => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t<'v>, key) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.cmpU",
        "kind": "value",
        "name": "cmpU",
        "signature": "let cmpU: (t<'v>, t<'v>, (. 'v, 'v) => int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t<'v>, t<'v>, ('v, 'v) => int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.eqU",
        "kind": "value",
        "name": "eqU",
        "signature": "let eqU: (t<'v>, t<'v>, (. 'v, 'v) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t<'v>, t<'v>, ('v, 'v) => bool) => bool",
        "docstrings": ["`eq m1 m2` tests whether the maps `m1` and `m2` are\n  equal, that is, contain equal keys and associate them with\n  equal data."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "signature": "let findFirstByU: (t<'v>, (. key, 'v) => bool) => option<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "signature": "let findFirstBy: (t<'v>, (key, 'v) => bool) => option<(key, 'v)>",
        "docstrings": ["`findFirstBy m p` uses funcion `f` to find the first key value pair\n  to match predicate `p`.\n\n  ```\n  let s0 = fromArray ~id:(module IntCmp) [|4,\"4\";1,\"1\";2,\"2,\"3\"\"|];;\n  findFirstBy s0 (fun k v -> k = 4 ) = option (4, \"4\");;\n  ```"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t<'v>, (. key, 'v) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t<'v>, (key, 'v) => unit) => unit",
        "docstrings": ["`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument. The bindings are passed to `f` in increasing\n  order with respect to the ordering over the type of the keys."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t<'v>, 'v2, (. 'v2, key, 'v) => 'v2) => 'v2",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t<'v>, 'v2, ('v2, key, 'v) => 'v2) => 'v2",
        "docstrings": ["`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t<'v>, (. key, 'v) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t<'v>, (key, 'v) => bool) => bool",
        "docstrings": ["`every m p` checks if all the bindings of the map\n    satisfy the predicate `p`. Order unspecified"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t<'v>, (. key, 'v) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t<'v>, (key, 'v) => bool) => bool",
        "docstrings": ["`some m p` checks if at least one binding of the map\n    satisfy the predicate `p`. Order unspecified"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t<'v> => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t<'v> => list<(key, 'v)>",
        "docstrings": ["In increasing order."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t<'v> => array<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<(key, 'v)> => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "signature": "let keysToArray: t<'v> => array<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "signature": "let valuesToArray: t<'v> => array<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.minKey",
        "kind": "value",
        "name": "minKey",
        "signature": "let minKey: t<'a> => option<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.maxKey",
        "kind": "value",
        "name": "maxKey",
        "signature": "let maxKey: t<'a> => option<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t<'v> => option<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t<'v> => Js.undefined<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t<'v> => option<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t<'v> => Js.undefined<(key, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t<'v>, key) => option<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t<'v>, key) => Js.undefined<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "signature": "let getWithDefault: (t<'v>, key, 'v) => 'v",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t<'v>, key) => 'v",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t<'a> => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t<'v>, key) => t<'v>",
        "docstrings": ["`remove m x` returns a map containing the same bindings as\n    `m`, except for `x` which is unbound in the returned map."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t<'v>, array<key>) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.set",
        "kind": "value",
        "name": "set",
        "signature": "let set: (t<'v>, key, 'v) => t<'v>",
        "docstrings": ["`set m x y` returns a map containing the same bindings as\n  `m`, plus a binding of `x` to `y`. If `x` was already bound\n  in `m`, its previous binding disappears."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.updateU",
        "kind": "value",
        "name": "updateU",
        "signature": "let updateU: (t<'v>, key, (. option<'v>) => option<'v>) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.update",
        "kind": "value",
        "name": "update",
        "signature": "let update: (t<'v>, key, option<'v> => option<'v>) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.mergeU",
        "kind": "value",
        "name": "mergeU",
        "signature": "let mergeU: (t<'v>, t<'v2>, (. key, option<'v>, option<'v2>) => option<'c>) => t<'c>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.merge",
        "kind": "value",
        "name": "merge",
        "signature": "let merge: (t<'v>, t<'v2>, (key, option<'v>, option<'v2>) => option<'c>) => t<'c>",
        "docstrings": ["`merge m1 m2 f` computes a map whose keys is a subset of keys of `m1`\n  and of `m2`. The presence of each such binding, and the corresponding\n  value, is determined with the function `f`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t<'v>, array<(key, 'v)>) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.keepU",
        "kind": "value",
        "name": "keepU",
        "signature": "let keepU: (t<'v>, (. key, 'v) => bool) => t<'v>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.keep",
        "kind": "value",
        "name": "keep",
        "signature": "let keep: (t<'v>, (key, 'v) => bool) => t<'v>",
        "docstrings": ["`keep m p` returns the map with all the bindings in `m`\n    that satisfy predicate `p`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.partitionU",
        "kind": "value",
        "name": "partitionU",
        "signature": "let partitionU: (t<'v>, (. key, 'v) => bool) => (t<'v>, t<'v>)",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.partition",
        "kind": "value",
        "name": "partition",
        "signature": "let partition: (t<'v>, (key, 'v) => bool) => (t<'v>, t<'v>)",
        "docstrings": ["`partition m p` returns a pair of maps `(m1, m2)`, where\n  `m1` contains all the bindings of `s` that satisfy the\n  predicate `p`, and `m2` is the map with all the bindings of\n  `s` that do not satisfy `p`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.split",
        "kind": "value",
        "name": "split",
        "signature": "let split: (key, t<'v>) => (t<'v>, option<'v>, t<'v>)",
        "docstrings": ["`split x m` returns a triple `(l, data, r)`, where\n  `l` is the map with all the bindings of `m` whose key\n  is strictly less than `x`;\n  `r` is the map with all the bindings of `m` whose key\n  is strictly greater than `x`;\n  `data` is `None` if `m` contains no binding for `x`,\n  or `Some v` if `m` binds `v` to `x`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.mapU",
        "kind": "value",
        "name": "mapU",
        "signature": "let mapU: (t<'v>, (. 'v) => 'v2) => t<'v2>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.map",
        "kind": "value",
        "name": "map",
        "signature": "let map: (t<'v>, 'v => 'v2) => t<'v2>",
        "docstrings": ["`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "signature": "let mapWithKeyU: (t<'v>, (. key, 'v) => 'v2) => t<'v2>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapString.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "signature": "let mapWithKey: (t<'v>, (key, 'v) => 'v2) => t<'v2>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_Map.Belt_MapDict",
      "kind": "moduleAlias",
      "name": "Dict",
      "docstrings": [],
      "items": [
      {
        "id": "Belt.Belt_Map.Belt_MapDict.t",
        "kind": "type",
        "name": "t",
        "signature": "type t<'key, 'value, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.cmp",
        "kind": "type",
        "name": "cmp",
        "signature": "type cmp<'key, 'id> = Belt_Id.cmp<'key, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.empty",
        "kind": "value",
        "name": "empty",
        "signature": "let empty: t<'k, 'v, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t<'k, 'v, 'id> => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.cmpU",
        "kind": "value",
        "name": "cmpU",
        "signature": "let cmpU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ~kcmp: cmp<'k, 'id>, ~vcmp: (. 'v, 'v) => int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ~kcmp: cmp<'k, 'id>, ~vcmp: ('v, 'v) => int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.eqU",
        "kind": "value",
        "name": "eqU",
        "signature": "let eqU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ~kcmp: cmp<'k, 'id>, ~veq: (. 'a, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ~kcmp: cmp<'k, 'id>, ~veq: ('a, 'a) => bool) => bool",
        "docstrings": ["`eq(m1, m2, cmp)` tests whether the maps `m1` and `m2` are equal, that is,\n    contain equal keys and associate them with equal data. `cmp` is the\n    equality predicate used to compare the data associated with the keys."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.findFirstByU",
        "kind": "value",
        "name": "findFirstByU",
        "signature": "let findFirstByU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => option<('k, 'v)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.findFirstBy",
        "kind": "value",
        "name": "findFirstBy",
        "signature": "let findFirstBy: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>",
        "docstrings": ["`findFirstBy(m, p)` uses function `f` to find the first key value pair to\n    match predicate `p`.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = Pervasives.compare\n    })\n\n    let s0 = Belt.Map.Dict.fromArray([(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"3\")], ~cmp=IntCmp.cmp)\n\n    Belt.Map.Dict.findFirstBy(s0, (k, _) => k == 4) == Some((4, \"4\"))\n    ```"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t<'k, 'a, 'id>, (. 'k, 'a) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit",
        "docstrings": ["`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the\n    key as first argument, and the associated value as second argument. The\n    bindings are passed to `f` in increasing order with respect to the ordering\n    over the type of the keys."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t<'k, 'a, 'id>, 'b, (. 'b, 'k, 'a) => 'b) => 'b",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b",
        "docstrings": ["`reduce(m, a, f)` computes `f(kN, dN ... f(k1, d1, a)...)`, where `k1 ...\n    kN` are the keys of all bindings in `m` (in increasing order), and `d1 ...\n    dN` are the associated data."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool",
        "docstrings": ["`every(m, p)` checks if all the bindings of the map satisfy the predicate\n    `p`. Order unspecified"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool",
        "docstrings": ["`some(m, p)` checks if at least one binding of the map satisfy the\n    predicate `p`. Order unspecified"]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t<'k, 'a, 'id> => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t<'k, 'a, 'id> => list<('k, 'a)>",
        "docstrings": ["In increasing order."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t<'k, 'a, 'id> => array<('k, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: (array<('k, 'a)>, ~cmp: cmp<'k, 'id>) => t<'k, 'a, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "signature": "let keysToArray: t<'k, 'a, 'id> => array<'k>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "signature": "let valuesToArray: t<'k, 'a, 'id> => array<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.minKey",
        "kind": "value",
        "name": "minKey",
        "signature": "let minKey: t<'k, 'a, 'b> => option<'k>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.maxKey",
        "kind": "value",
        "name": "maxKey",
        "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t<'k, 'a, 'b> => option<('k, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t<'k, 'a, 'b> => option<('k, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => option<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => Js.undefined<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "signature": "let getWithDefault: (t<'k, 'a, 'id>, 'k, 'a, ~cmp: cmp<'k, 'id>) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t<'k, 'a, 'id>, 'k, ~cmp: cmp<'k, 'id>) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t<'a, 'b, 'id>, 'a, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>",
        "docstrings": ["`remove(m, x)` returns a map containing the same bindings as `m`, except\n    for `x` which is unbound in the returned map."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t<'a, 'b, 'id>, array<'a>, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.set",
        "kind": "value",
        "name": "set",
        "signature": "let set: (t<'a, 'b, 'id>, 'a, 'b, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>",
        "docstrings": ["`set(m, x, y)` returns a map containing the same bindings as `m`, plus a\n    binding of `x` to `y`. If `x` was already bound in `m`, its previous\n    binding disappears."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.updateU",
        "kind": "value",
        "name": "updateU",
        "signature": "let updateU: (\\n  t<'a, 'b, 'id>,\\n  'a,\\n  (. option<'b>) => option<'b>,\\n  ~cmp: cmp<'a, 'id>,\\n) => t<'a, 'b, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.update",
        "kind": "value",
        "name": "update",
        "signature": "let update: (t<'a, 'b, 'id>, 'a, option<'b> => option<'b>, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.mergeU",
        "kind": "value",
        "name": "mergeU",
        "signature": "let mergeU: (\\n  t<'a, 'b, 'id>,\\n  t<'a, 'c, 'id>,\\n  (. 'a, option<'b>, option<'c>) => option<'d>,\\n  ~cmp: cmp<'a, 'id>,\\n) => t<'a, 'd, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.merge",
        "kind": "value",
        "name": "merge",
        "signature": "let merge: (\\n  t<'a, 'b, 'id>,\\n  t<'a, 'c, 'id>,\\n  ('a, option<'b>, option<'c>) => option<'d>,\\n  ~cmp: cmp<'a, 'id>,\\n) => t<'a, 'd, 'id>",
        "docstrings": ["`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\n    and of `m2`. The presence of each such binding, and the corresponding\n    value, is determined with the function `f`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t<'a, 'b, 'id>, array<('a, 'b)>, ~cmp: cmp<'a, 'id>) => t<'a, 'b, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.keepU",
        "kind": "value",
        "name": "keepU",
        "signature": "let keepU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => t<'k, 'a, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.keep",
        "kind": "value",
        "name": "keep",
        "signature": "let keep: (t<'k, 'a, 'id>, ('k, 'a) => bool) => t<'k, 'a, 'id>",
        "docstrings": ["`keep(m, p)` returns the map with all the bindings in `m` that satisfy\n    predicate `p`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.partitionU",
        "kind": "value",
        "name": "partitionU",
        "signature": "let partitionU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => (t<'k, 'a, 'id>, t<'k, 'a, 'id>)",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.partition",
        "kind": "value",
        "name": "partition",
        "signature": "let partition: (t<'k, 'a, 'id>, ('k, 'a) => bool) => (t<'k, 'a, 'id>, t<'k, 'a, 'id>)",
        "docstrings": ["`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains\n    all the bindings of `s` that satisfy the predicate `p`, and `m2` is the map\n    with all the bindings of `s` that do not satisfy `p`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.split",
        "kind": "value",
        "name": "split",
        "signature": "let split: (\\n  t<'a, 'b, 'id>,\\n  'a,\\n  ~cmp: cmp<'a, 'id>,\\n) => ((t<'a, 'b, 'id>, t<'a, 'b, 'id>), option<'b>)",
        "docstrings": ["`split(x, m)` returns a triple `(l, data, r)`, where `l` is the map with\n    all the bindings of `m` whose key is strictly less than `x`; `r` is the map\n    with all the bindings of `m` whose key is strictly greater than `x`; `data`\n    is `None` if `m` contains no binding for `x`, or `Some(v)` if `m` binds `v`\n    to `x`."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.mapU",
        "kind": "value",
        "name": "mapU",
        "signature": "let mapU: (t<'k, 'a, 'id>, (. 'a) => 'b) => t<'k, 'b, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.map",
        "kind": "value",
        "name": "map",
        "signature": "let map: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>",
        "docstrings": ["`map(m, f)` returns a map with same domain as `m`, where the associated\n    value `a` of all bindings of `m` has been replaced by the result of the\n    application of `f` to `a`. The bindings are passed to `f` in increasing\n    order with respect to the ordering over the type of the keys."]
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "signature": "let mapWithKeyU: (t<'k, 'a, 'id>, (. 'k, 'a) => 'b) => t<'k, 'b, 'id>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_Map.Belt_MapDict.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "signature": "let mapWithKey: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_Map.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'key, 'value, 'identity>",
      "docstrings": ["`'key` is the field type\n\n`'value` is the element type\n\n`'identity` the identity of the collection"]
    }, 
    {
      "id": "Belt.Belt_Map.id",
      "kind": "type",
      "name": "id",
      "signature": "type id<'key, 'id> = Belt_Id.comparable<'key, 'id>",
      "docstrings": ["The identity needed for making an empty map."]
    }, 
    {
      "id": "Belt.Belt_Map.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (~id: id<'k, 'id>) => t<'k, 'v, 'id>",
      "docstrings": ["`make(~id)` creates a new map by taking in the comparator.\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nlet m = Belt.Map.make(~id=module(IntCmp))\n\nBelt.Map.set(m, 0, \"a\")\n```"]
    }, 
    {
      "id": "Belt.Belt_Map.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a, 'b, 'c> => bool",
      "docstrings": ["`isEmpty(m)` checks whether a map m is empty.\n\n```rescript\nmodule IntCmp = Belt.Id.MakeComparable({\n  type t = int\n  let cmp = (a, b) => Pervasives.compare(a, b)\n})\n\nBelt.Map.isEmpty(Belt.Map.fromArray([(1, \"1\")], ~id=module(IntCmp))) == false\n```"]
    }, 
    {
      "id": "Belt.Belt_Map.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'k, 'v, 'id>, 'k) => bool",
      "docstrings": ["`has(m, k)` checks whether `m` has the key `k`.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.has(Belt.Map.fromArray([(1, \"1\")], ~id=module(IntCmp)), 1) == true\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.cmpU",
      "kind": "value",
      "name": "cmpU",
      "signature": "let cmpU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, (. 'v, 'v) => int) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => int) => int",
      "docstrings": ["`cmp(m0, m1, vcmp);`\n\n    Total ordering of map given total ordering of value function.\n\n    It will compare size first and each element following the order one by one."]
    }, 
    {
      "id": "Belt.Belt_Map.eqU",
      "kind": "value",
      "name": "eqU",
      "signature": "let eqU: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, (. 'v, 'v) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'k, 'v, 'id>, t<'k, 'v, 'id>, ('v, 'v) => bool) => bool",
      "docstrings": ["`eq(m1, m2, veq)` tests whether the maps `m1` and `m2` are equal, that is,\n    contain equal keys and associate them with equal data. `veq` is the\n    equality predicate used to compare the data associated with the keys."]
    }, 
    {
      "id": "Belt.Belt_Map.findFirstByU",
      "kind": "value",
      "name": "findFirstByU",
      "signature": "let findFirstByU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => option<('k, 'v)>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.findFirstBy",
      "kind": "value",
      "name": "findFirstBy",
      "signature": "let findFirstBy: (t<'k, 'v, 'id>, ('k, 'v) => bool) => option<('k, 'v)>",
      "docstrings": ["`findFirstBy(m, p)` uses function `f` to find the first key value pair to\n    match predicate `p`.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"\")])\n\n    Belt.Map.findFirstBy(s0, (k, v) => k == 4) /* (4, \"4\") */\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'k, 'v, 'id>, (. 'k, 'v) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'k, 'v, 'id>, ('k, 'v) => unit) => unit",
      "docstrings": ["`forEach(m, f)` applies `f` to all bindings in map `m`. `f` receives the\n    `'k` as first argument, and the associated value as second argument. The\n    bindings are passed to `f` in increasing order with respect to the ordering\n    over the type of the keys.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"\")])\n\n    let acc = ref(list{})\n\n    Belt.Map.forEach(s0, (k, v) => acc := list{(k, v), ...acc.contents})\n\n    acc.contents == list{(4, \"4\"), (3, \"3\"), (2, \"2\"), (1, \"1\")}\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'k, 'v, 'id>, 'acc, (. 'acc, 'k, 'v) => 'acc) => 'acc",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'k, 'v, 'id>, 'acc, ('acc, 'k, 'v) => 'acc) => 'acc",
      "docstrings": ["`reduce(m, a, f)` computes `(f(kN, dN) ... (f(k1, d1, a))...)`, where `k1\n    ... kN` are the keys of all bindings in m (in increasing order), and `d1\n    ... dN` are the associated data.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray(~id=module(IntCmp), [(4, \"4\"), (1, \"1\"), (2, \"2\"), (3, \"3\")])\n\n    Belt.Map.reduce(s0, list{}, (acc, k, v) => list{\n      (k, v),\n      ...acc,\n    }) /* [(4, \"4\"), (3, \"3\"), (2, \"2\"), (1, \"1\"), 0] */\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool",
      "docstrings": ["`every(m, p)` checks if all the bindings of the map satisfy the predicate\n    `p`. Order unspecified"]
    }, 
    {
      "id": "Belt.Belt_Map.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'k, 'v, 'id>, ('k, 'v) => bool) => bool",
      "docstrings": ["`some(m, p)` checks if at least one binding of the map satisfy the\n    predicate `p`. Order unspecified"]
    }, 
    {
      "id": "Belt.Belt_Map.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'k, 'v, 'id> => int",
      "docstrings": ["`size(s)`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.size(Belt.Map.fromArray([(2, \"2\"), (2, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == 2\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'k, 'v, 'id> => array<('k, 'v)>",
      "docstrings": ["`toArray(s)`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.toArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        (1, \"1\"),\n        (2, \"2\"),\n        (3, \"3\"),\n      ]\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.toList",
      "kind": "value",
      "name": "toList",
      "signature": "let toList: t<'k, 'v, 'id> => list<('k, 'v)>",
      "docstrings": ["In increasing order.\n\n    See `Belt.Map.toArray`"]
    }, 
    {
      "id": "Belt.Belt_Map.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: (array<('k, 'v)>, ~id: id<'k, 'id>) => t<'k, 'v, 'id>",
      "docstrings": ["`fromArray(kvs, ~id);`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.toArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        (1, \"1\"),\n        (2, \"2\"),\n        (3, \"3\"),\n      ]\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.keysToArray",
      "kind": "value",
      "name": "keysToArray",
      "signature": "let keysToArray: t<'k, 'v, 'id> => array<'k>",
      "docstrings": ["`keysToArray(s);`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.keysToArray(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))) == [\n        1,\n        2,\n        3,\n      ]\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.valuesToArray",
      "kind": "value",
      "name": "valuesToArray",
      "signature": "let valuesToArray: t<'k, 'v, 'id> => array<'v>",
      "docstrings": ["`valuesToArray(s);`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.valuesToArray(\n      Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)),\n    ) == [\"1\", \"2\", \"3\"]\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.minKey",
      "kind": "value",
      "name": "minKey",
      "signature": "let minKey: t<'k, 'a, 'b> => option<'k>",
      "docstrings": ["`minKey(s)` returns the minimum key, None if not exist."]
    }, 
    {
      "id": "Belt.Belt_Map.minKeyUndefined",
      "kind": "value",
      "name": "minKeyUndefined",
      "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>",
      "docstrings": ["See `Belt.Map.minKey`"]
    }, 
    {
      "id": "Belt.Belt_Map.maxKey",
      "kind": "value",
      "name": "maxKey",
      "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>",
      "docstrings": ["`maxKey(s)` returns the maximum key, None if not exist."]
    }, 
    {
      "id": "Belt.Belt_Map.maxKeyUndefined",
      "kind": "value",
      "name": "maxKeyUndefined",
      "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>",
      "docstrings": ["See `Belt.Map.maxKey`"]
    }, 
    {
      "id": "Belt.Belt_Map.minimum",
      "kind": "value",
      "name": "minimum",
      "signature": "let minimum: t<'k, 'v, 'a> => option<('k, 'v)>",
      "docstrings": ["`minimum(s)` returns the minimum key value pair, None if not exist."]
    }, 
    {
      "id": "Belt.Belt_Map.minUndefined",
      "kind": "value",
      "name": "minUndefined",
      "signature": "let minUndefined: t<'k, 'v, 'a> => Js.undefined<('k, 'v)>",
      "docstrings": ["See `Belt.Map.minimum`"]
    }, 
    {
      "id": "Belt.Belt_Map.maximum",
      "kind": "value",
      "name": "maximum",
      "signature": "let maximum: t<'k, 'v, 'a> => option<('k, 'v)>",
      "docstrings": ["`maximum(s)` returns the maximum key value pair, None if not exist."]
    }, 
    {
      "id": "Belt.Belt_Map.maxUndefined",
      "kind": "value",
      "name": "maxUndefined",
      "signature": "let maxUndefined: t<'k, 'v, 'a> => Js.undefined<('k, 'v)>",
      "docstrings": ["See `Belt.Map.maximum`"]
    }, 
    {
      "id": "Belt.Belt_Map.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'k, 'v, 'id>, 'k) => option<'v>",
      "docstrings": ["`get(s, k)`\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    Belt.Map.get(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)), 2) ==\n      Some(\"2\")\n\n    Belt.Map.get(Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp)), 2) == None\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.getUndefined",
      "kind": "value",
      "name": "getUndefined",
      "signature": "let getUndefined: (t<'k, 'v, 'id>, 'k) => Js.undefined<'v>",
      "docstrings": ["See `Belt.Map.get`\n\n    Returns `undefined` when not found"]
    }, 
    {
      "id": "Belt.Belt_Map.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "signature": "let getWithDefault: (t<'k, 'v, 'id>, 'k, 'v) => 'v",
      "docstrings": ["`getWithDefault(s, k, default)`\n\n    See `Belt.Map.get`\n\n    Returns default when `k` is not found."]
    }, 
    {
      "id": "Belt.Belt_Map.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'k, 'v, 'id>, 'k) => 'v",
      "docstrings": ["`getExn(s, k)`\n\n    See `Belt.Map.getExn`\n\n    raise when `k` not exist"]
    }, 
    {
      "id": "Belt.Belt_Map.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'k, 'v, 'id>, 'k) => t<'k, 'v, 'id>",
      "docstrings": ["`remove(m, x)` when `x` is not in `m`, `m` is returned reference unchanged.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))\n\n    let s1 = Belt.Map.remove(s0, 1)\n\n    let s2 = Belt.Map.remove(s1, 1)\n\n    s1 === s2\n\n    Belt.Map.keysToArray(s1) == [2, 3]\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.removeMany",
      "kind": "value",
      "name": "removeMany",
      "signature": "let removeMany: (t<'k, 'v, 'id>, array<'k>) => t<'k, 'v, 'id>",
      "docstrings": ["`removeMany(s, xs)`\n\n    Removing each of `xs` to `s`, note unlike `Belt.Map.remove`, the reference\n    of return value might be changed even if none in `xs` exists `s`."]
    }, 
    {
      "id": "Belt.Belt_Map.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'k, 'v, 'id>, 'k, 'v) => t<'k, 'v, 'id>",
      "docstrings": ["`set(m, x, y)` returns a map containing the same bindings as `m`, with a\n    new binding of `x` to `y`. If `x` was already bound in `m`, its previous\n    binding disappears.\n\n    ```rescript\n    module IntCmp = Belt.Id.MakeComparable({\n      type t = int\n      let cmp = (a, b) => Pervasives.compare(a, b)\n    })\n\n    let s0 = Belt.Map.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntCmp))\n\n    let s1 = Belt.Map.set(s0, 2, \"3\")\n\n    Belt.Map.valuesToArray(s1) == [\"1\", \"3\", \"3\"]\n    ```"]
    }, 
    {
      "id": "Belt.Belt_Map.updateU",
      "kind": "value",
      "name": "updateU",
      "signature": "let updateU: (t<'k, 'v, 'id>, 'k, (. option<'v>) => option<'v>) => t<'k, 'v, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.update",
      "kind": "value",
      "name": "update",
      "signature": "let update: (t<'k, 'v, 'id>, 'k, option<'v> => option<'v>) => t<'k, 'v, 'id>",
      "docstrings": ["`update(m, x, f)` returns a map containing the same bindings as `m`, except\n    for the binding of `x`. Depending on the value of `y` where `y` is\n    `f(get(m, x))`, the binding of `x` is added, removed or updated. If `y` is\n    `None`, the binding is removed if it exists; otherwise, if `y` is `Some(z)`\n    then `x` is associated to `z` in the resulting map."]
    }, 
    {
      "id": "Belt.Belt_Map.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t<'k, 'v, 'id>, array<('k, 'v)>) => t<'k, 'v, 'id>",
      "docstrings": ["`mergeMany(s, xs)`\n\n    Adding each of `xs` to `s`, note unlike `add`, the reference of return\n    value might be changed even if all values in `xs` exist `s`."]
    }, 
    {
      "id": "Belt.Belt_Map.mergeU",
      "kind": "value",
      "name": "mergeU",
      "signature": "let mergeU: (\\n  t<'k, 'v, 'id>,\\n  t<'k, 'v2, 'id>,\\n  (. 'k, option<'v>, option<'v2>) => option<'v3>,\\n) => t<'k, 'v3, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.merge",
      "kind": "value",
      "name": "merge",
      "signature": "let merge: (\\n  t<'k, 'v, 'id>,\\n  t<'k, 'v2, 'id>,\\n  ('k, option<'v>, option<'v2>) => option<'v3>,\\n) => t<'k, 'v3, 'id>",
      "docstrings": ["`merge(m1, m2, f)` computes a map whose keys is a subset of keys of `m1`\n    and of `m2`. The presence of each such binding, and the corresponding\n    value, is determined with the function `f`."]
    }, 
    {
      "id": "Belt.Belt_Map.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => t<'k, 'v, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (t<'k, 'v, 'id>, ('k, 'v) => bool) => t<'k, 'v, 'id>",
      "docstrings": ["`keep(m, p)` returns the map with all the bindings in m that satisfy\n    predicate `p`."]
    }, 
    {
      "id": "Belt.Belt_Map.partitionU",
      "kind": "value",
      "name": "partitionU",
      "signature": "let partitionU: (t<'k, 'v, 'id>, (. 'k, 'v) => bool) => (t<'k, 'v, 'id>, t<'k, 'v, 'id>)",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t<'k, 'v, 'id>, ('k, 'v) => bool) => (t<'k, 'v, 'id>, t<'k, 'v, 'id>)",
      "docstrings": ["`partition(m, p)` returns a pair of maps `(m1, m2)`, where `m1` contains\n    all the bindings of `s` that satisfy the predicate `p`, and `m2` is the map\n    with all the bindings of `s` that do not satisfy `p`."]
    }, 
    {
      "id": "Belt.Belt_Map.split",
      "kind": "value",
      "name": "split",
      "signature": "let split: (t<'k, 'v, 'id>, 'k) => ((t<'k, 'v, 'id>, t<'k, 'v, 'id>), option<'v>)",
      "docstrings": ["`split(x, m)` returns a tuple `(l, r)`, data, where `l` is the map with all\n    the bindings of `m` whose 'k is strictly less than `x`; `r` is the map with\n    all the bindings of m whose 'k is strictly greater than `x`; `data` is\n    `None` if `m` contains no binding for `x`, or `Some(v)` if `m` binds `v` to\n    `x`."]
    }, 
    {
      "id": "Belt.Belt_Map.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (t<'k, 'v, 'id>, (. 'v) => 'v2) => t<'k, 'v2, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'k, 'v, 'id>, 'v => 'v2) => t<'k, 'v2, 'id>",
      "docstrings": ["`map(m, f) returns a map with same domain as`m`, where the associated\n    value`a`of all bindings of`m`has been replaced by the result of the\n    application of`f`to`a`. The bindings are passed to`f` in increasing order\n    with respect to the ordering over the type of the keys."]
    }, 
    {
      "id": "Belt.Belt_Map.mapWithKeyU",
      "kind": "value",
      "name": "mapWithKeyU",
      "signature": "let mapWithKeyU: (t<'k, 'v, 'id>, (. 'k, 'v) => 'v2) => t<'k, 'v2, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Map.mapWithKey",
      "kind": "value",
      "name": "mapWithKey",
      "signature": "let mapWithKey: (t<'k, 'v, 'id>, ('k, 'v) => 'v2) => t<'k, 'v2, 'id>",
      "docstrings": ["`mapWithKey(m, f)`\n\n    The same as `Belt.Map.map` except that `f` is supplied with one more\n    argument: the key."]
    }, 
    {
      "id": "Belt.Belt_Map.getData",
      "kind": "value",
      "name": "getData",
      "signature": "let getData: t<'k, 'v, 'id> => Belt_MapDict.t<'k, 'v, 'id>",
      "docstrings": ["`getData(s0)`\n\n    Advanced usage only\n\n    Returns the raw data (detached from comparator), but its type is still\n    manifested, so that user can pass identity directly without boxing."]
    }, 
    {
      "id": "Belt.Belt_Map.getId",
      "kind": "value",
      "name": "getId",
      "signature": "let getId: t<'k, 'v, 'id> => id<'k, 'id>",
      "docstrings": ["Advanced usage only\n\n    Returns the identity of s0."]
    }, 
    {
      "id": "Belt.Belt_Map.packIdData",
      "kind": "value",
      "name": "packIdData",
      "signature": "let packIdData: (~id: id<'k, 'id>, ~data: Belt_MapDict.t<'k, 'v, 'id>) => t<'k, 'v, 'id>",
      "docstrings": ["`packIdData(~id, ~data)`\n\n    Advanced usage only\n\n    Returns the packed collection."]
    }, 
    {
      "id": "Belt.Belt_Map.checkInvariantInternal",
      "kind": "value",
      "name": "checkInvariantInternal",
      "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit",
      "docstrings": ["**raise** when invariant is not held"]
    }]
  }, 
  {
    "id": "Belt.Belt_MutableSet",
    "kind": "moduleAlias",
    "name": "MutableSet",
    "docstrings": ["[`Belt.MutableSet`]()\n\n  The top level provides generic **mutable** set operations.\n\n  It also has two specialized inner modules\n  [`Belt.MutableSet.Int`]() and [`Belt.MutableSet.String`]()"],
    "items": [
    {
      "id": "Belt.Belt_MutableSet.Belt_MutableSetInt",
      "kind": "moduleAlias",
      "name": "Int",
      "docstrings": ["Specialized when key type is `int`, more efficient\n    than the generic type"],
      "items": [
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.value",
        "kind": "type",
        "name": "value",
        "signature": "type value = int",
        "docstrings": ["The type of the set elements."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": ["The type of sets."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<value> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "signature": "let fromSortedArrayUnsafe: array<value> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.copy",
        "kind": "value",
        "name": "copy",
        "signature": "let copy: t => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t, value) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.add",
        "kind": "value",
        "name": "add",
        "signature": "let add: (t, value) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.addCheck",
        "kind": "value",
        "name": "addCheck",
        "signature": "let addCheck: (t, value) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t, array<value>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t, value) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.removeCheck",
        "kind": "value",
        "name": "removeCheck",
        "signature": "let removeCheck: (t, value) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t, array<value>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.union",
        "kind": "value",
        "name": "union",
        "signature": "let union: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.intersect",
        "kind": "value",
        "name": "intersect",
        "signature": "let intersect: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.diff",
        "kind": "value",
        "name": "diff",
        "signature": "let diff: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.subset",
        "kind": "value",
        "name": "subset",
        "signature": "let subset: (t, t) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t, t) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t, t) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t, (. value) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t, value => unit) => unit",
        "docstrings": ["In increasing order"]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a",
        "docstrings": ["Iterate in increasing order."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t, (. value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t, value => bool) => bool",
        "docstrings": ["`every p s` checks if all elements of the set\n  satisfy the predicate `p`. Order unspecified."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t, (. value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t, value => bool) => bool",
        "docstrings": ["`some p s` checks if at least one element of\n  the set satisfies the predicate `p`. Oder unspecified."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.keepU",
        "kind": "value",
        "name": "keepU",
        "signature": "let keepU: (t, (. value) => bool) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.keep",
        "kind": "value",
        "name": "keep",
        "signature": "let keep: (t, value => bool) => t",
        "docstrings": ["`keep s p` returns a fresh copy of the set of all elements in `s`\n  that satisfy predicate `p`."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.partitionU",
        "kind": "value",
        "name": "partitionU",
        "signature": "let partitionU: (t, (. value) => bool) => (t, t)",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.partition",
        "kind": "value",
        "name": "partition",
        "signature": "let partition: (t, value => bool) => (t, t)",
        "docstrings": ["`partition s p` returns a fresh copy pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t => list<value>",
        "docstrings": ["In increasing order with respect"]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t => array<value>",
        "docstrings": ["In increasing order with respect"]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t, value) => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t, value) => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t, value) => value",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.split",
        "kind": "value",
        "name": "split",
        "signature": "let split: (t, value) => ((t, t), bool)",
        "docstrings": ["`split s key` return a fresh copy of each"]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetInt.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }]
    }, 
    {
      "id": "Belt.Belt_MutableSet.Belt_MutableSetString",
      "kind": "moduleAlias",
      "name": "String",
      "docstrings": ["Specialized when key type is `string`, more efficient\n    than the generic type"],
      "items": [
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.value",
        "kind": "type",
        "name": "value",
        "signature": "type value = string",
        "docstrings": ["The type of the set elements."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": ["The type of sets."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<value> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.fromSortedArrayUnsafe",
        "kind": "value",
        "name": "fromSortedArrayUnsafe",
        "signature": "let fromSortedArrayUnsafe: array<value> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.copy",
        "kind": "value",
        "name": "copy",
        "signature": "let copy: t => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t, value) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.add",
        "kind": "value",
        "name": "add",
        "signature": "let add: (t, value) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.addCheck",
        "kind": "value",
        "name": "addCheck",
        "signature": "let addCheck: (t, value) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t, array<value>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t, value) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.removeCheck",
        "kind": "value",
        "name": "removeCheck",
        "signature": "let removeCheck: (t, value) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t, array<value>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.union",
        "kind": "value",
        "name": "union",
        "signature": "let union: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.intersect",
        "kind": "value",
        "name": "intersect",
        "signature": "let intersect: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.diff",
        "kind": "value",
        "name": "diff",
        "signature": "let diff: (t, t) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.subset",
        "kind": "value",
        "name": "subset",
        "signature": "let subset: (t, t) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t, t) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t, t) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t, (. value) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t, value => unit) => unit",
        "docstrings": ["In increasing order"]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t, 'a, (. 'a, value) => 'a) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t, 'a, ('a, value) => 'a) => 'a",
        "docstrings": ["Iterate in increasing order."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t, (. value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t, value => bool) => bool",
        "docstrings": ["`every p s` checks if all elements of the set\n  satisfy the predicate `p`. Order unspecified."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t, (. value) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t, value => bool) => bool",
        "docstrings": ["`some p s` checks if at least one element of\n  the set satisfies the predicate `p`. Oder unspecified."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.keepU",
        "kind": "value",
        "name": "keepU",
        "signature": "let keepU: (t, (. value) => bool) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.keep",
        "kind": "value",
        "name": "keep",
        "signature": "let keep: (t, value => bool) => t",
        "docstrings": ["`keep s p` returns a fresh copy of the set of all elements in `s`\n  that satisfy predicate `p`."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.partitionU",
        "kind": "value",
        "name": "partitionU",
        "signature": "let partitionU: (t, (. value) => bool) => (t, t)",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.partition",
        "kind": "value",
        "name": "partition",
        "signature": "let partition: (t, value => bool) => (t, t)",
        "docstrings": ["`partition s p` returns a fresh copy pair of sets `(s1, s2)`, where\n  `s1` is the set of all the elements of `s` that satisfy the\n  predicate `p`, and `s2` is the set of all the elements of\n  `s` that do not satisfy `p`."]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t => list<value>",
        "docstrings": ["In increasing order with respect"]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t => array<value>",
        "docstrings": ["In increasing order with respect"]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t, value) => option<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t, value) => Js.undefined<value>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t, value) => value",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.split",
        "kind": "value",
        "name": "split",
        "signature": "let split: (t, value) => ((t, t), bool)",
        "docstrings": ["`split s key` return a fresh copy of each"]
      }, 
      {
        "id": "Belt.Belt_MutableSet.Belt_MutableSetString.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }]
    }, 
    {
      "id": "Belt.Belt_MutableSet.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'value, 'identity>",
      "docstrings": ["`'value` is the element type\n\n  `'identity` the identity of the collection"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.id",
      "kind": "type",
      "name": "id",
      "signature": "type id<'value, 'id> = Belt_Id.comparable<'value, 'id>",
      "docstrings": ["The identity needed for making a set from scratch"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (~id: id<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Creates a new set by taking in the comparator"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Creates new set from array of elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.toArray /* [1, 2, 3, 4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.fromSortedArrayUnsafe",
      "kind": "value",
      "name": "fromSortedArrayUnsafe",
      "signature": "let fromSortedArrayUnsafe: (array<'value>, ~id: id<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["The same as [fromArray][#fromarray] except it is after assuming the input array is already sorted."]
    }, 
    {
      "id": "Belt.Belt_MutableSet.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'value, 'id> => t<'value, 'id>",
      "docstrings": ["Returns copy of a set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 3, 2, 4], ~id=module(IntCmp))\n\n  let copied = s0->Belt.MutableSet.copy\n  copied->Belt.MutableSet.toArray /* [1, 2, 3, 4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a, 'b> => bool",
      "docstrings": ["Checks if set is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let empty = Belt.MutableSet.fromArray([], ~id=module(IntCmp))\n  let notEmpty = Belt.MutableSet.fromArray([1], ~id=module(IntCmp))\n\n  Belt.MutableSet.isEmpty(empty) /* true */\n  Belt.MutableSet.isEmpty(notEmpty) /* false */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'value, 'id>, 'value) => bool",
      "docstrings": ["Checks if element exists in set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.MutableSet.fromArray([1, 4, 2, 5], ~id=module(IntCmp))\n\n  set->Belt.MutableSet.has(3) /* false */\n  set->Belt.MutableSet.has(1) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'value, 'id>, 'value) => unit",
      "docstrings": ["Adds element to set. If element existed in set, value is unchanged.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  s0->Belt.MutableSet.add(1)\n  s0->Belt.MutableSet.add(2)\n  s0->Belt.MutableSet.add(2)\n\n  s0->Belt.MutableSet.toArray /* [1, 2] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.addCheck",
      "kind": "value",
      "name": "addCheck",
      "signature": "let addCheck: (t<'value, 'id>, 'value) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableSet.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t<'value, 'id>, array<'value>) => unit",
      "docstrings": ["Adds each element of array to set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.MutableSet.make(~id=module(IntCmp))\n\n  set->Belt.MutableSet.mergeMany([5, 4, 3, 2, 1])\n  set->Belt.MutableSet.toArray /* [1, 2, 3, 4, 5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'value, 'id>, 'value) => unit",
      "docstrings": ["Removes element from set. If element did not exist in set, value is unchanged.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([2, 3, 1, 4, 5], ~id=module(IntCmp))\n  s0->Belt.MutableSet.remove(1)\n  s0->Belt.MutableSet.remove(3)\n  s0->Belt.MutableSet.remove(3)\n\n  s0->Belt.MutableSet.toArray /* [2,4,5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.removeCheck",
      "kind": "value",
      "name": "removeCheck",
      "signature": "let removeCheck: (t<'value, 'id>, 'value) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableSet.removeMany",
      "kind": "value",
      "name": "removeMany",
      "signature": "let removeMany: (t<'value, 'id>, array<'value>) => unit",
      "docstrings": ["Removes each element of array from set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let set = Belt.MutableSet.fromArray([1, 2, 3, 4], ~id=module(IntCmp))\n\n  set->Belt.MutableSet.removeMany([5, 4, 3, 2, 1])\n  set->Belt.MutableSet.toArray /* [] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.union",
      "kind": "value",
      "name": "union",
      "signature": "let union: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Returns union of two sets.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\n  let union = Belt.MutableSet.union(s0, s1)\n  union->Belt.MutableSet.toArray /* [1,2,3,4,5,6] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.intersect",
      "kind": "value",
      "name": "intersect",
      "signature": "let intersect: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Returns intersection of two sets.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\n  let intersect = Belt.MutableSet.intersect(s0, s1)\n  intersect->Belt.MutableSet.toArray /* [2,3,5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.diff",
      "kind": "value",
      "name": "diff",
      "signature": "let diff: (t<'value, 'id>, t<'value, 'id>) => t<'value, 'id>",
      "docstrings": ["Returns elements from first set, not existing in second set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\n  Belt.MutableSet.toArray(Belt.MutableSet.diff(s0, s1)) /* [6] */\n  Belt.MutableSet.toArray(Belt.MutableSet.diff(s1, s0)) /* [1,4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.subset",
      "kind": "value",
      "name": "subset",
      "signature": "let subset: (t<'value, 'id>, t<'value, 'id>) => bool",
      "docstrings": ["Checks if second set is subset of first set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([5, 2, 3, 1, 5, 4], ~id=module(IntCmp))\n  let s2 = Belt.MutableSet.intersect(s0, s1)\n  Belt.MutableSet.subset(s2, s0) /* true */\n  Belt.MutableSet.subset(s2, s1) /* true */\n  Belt.MutableSet.subset(s1, s0) /* false */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'value, 'id>, t<'value, 'id>) => int",
      "docstrings": ["Total ordering between sets. Can be used as the ordering function for doing sets of sets. It compares size first and then iterates over each element following the order of elements."]
    }, 
    {
      "id": "Belt.Belt_MutableSet.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'value, 'id>, t<'value, 'id>) => bool",
      "docstrings": ["Checks if two sets are equal.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3], ~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 5], ~id=module(IntCmp))\n\n  Belt.MutableSet.eq(s0, s1) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'value, 'id>, (. 'value) => unit) => unit",
      "docstrings": ["Same as [forEach](##forEach) but takes uncurried functon."]
    }, 
    {
      "id": "Belt.Belt_MutableSet.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'value, 'id>, 'value => unit) => unit",
      "docstrings": ["Applies function `f` in turn to all elements of set in increasing order.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  let acc = ref(list{})\n  s0->Belt.MutableSet.forEach(x => acc := Belt.List.add(acc.contents, x))\n  acc /* [6,5,3,2] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'value, 'id>, 'a, (. 'a, 'value) => 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableSet.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'value, 'id>, 'a, ('a, 'value) => 'a) => 'a",
      "docstrings": ["Applies function `f` to each element of set in increasing order. Function `f` has two parameters: the item from the set and an “accumulator”, which starts with a value of `initialValue`. `reduce` returns the final value of the accumulator.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([5, 2, 3, 5, 6], ~id=module(IntCmp))\n  s0->Belt.MutableSet.reduce(list{}, (acc, element) => acc->Belt.List.add(element)) /* [6,5,3,2] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t<'value, 'id>, (. 'value) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableSet.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'value, 'id>, 'value => bool) => bool",
      "docstrings": ["Checks if all elements of the set satisfy the predicate. Order unspecified.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.MutableSet.fromArray([2, 4, 6, 8], ~id=module(IntCmp))\n  s0->Belt.MutableSet.every(isEven) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t<'value, 'id>, (. 'value) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableSet.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'value, 'id>, 'value => bool) => bool",
      "docstrings": ["Checks if at least one element of the set satisfies the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 4, 6, 8], ~id=module(IntCmp))\n  s0->Belt.MutableSet.some(isOdd) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (t<'value, 'id>, (. 'value) => bool) => t<'value, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableSet.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (t<'value, 'id>, 'value => bool) => t<'value, 'id>",
      "docstrings": ["Returns the set of all elements that satisfy the predicate.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isEven = x => mod(x, 2) == 0\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n  let s1 = s0->Belt.MutableSet.keep(isEven)\n\n  s1->Belt.MutableSet.toArray /* [2, 4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.partitionU",
      "kind": "value",
      "name": "partitionU",
      "signature": "let partitionU: (t<'value, 'id>, (. 'value) => bool) => (t<'value, 'id>, t<'value, 'id>)",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableSet.partition",
      "kind": "value",
      "name": "partition",
      "signature": "let partition: (t<'value, 'id>, 'value => bool) => (t<'value, 'id>, t<'value, 'id>)",
      "docstrings": ["```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let isOdd = x => mod(x, 2) != 0\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n  let (s1, s2) = s0->Belt.MutableSet.partition(isOdd)\n\n  s1->Belt.MutableSet.toArray /* [1,3,5] */\n  s2->Belt.MutableSet.toArray /* [2,4] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'value, 'id> => int",
      "docstrings": ["Returns size of the set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.size /* 4 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.toList",
      "kind": "value",
      "name": "toList",
      "signature": "let toList: t<'value, 'id> => list<'value>",
      "docstrings": ["Returns list of ordered set elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.toList /* [1,2,3,5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'value, 'id> => array<'value>",
      "docstrings": ["Returns array of ordered set elements.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.toArray /* [1,2,3,5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.minimum",
      "kind": "value",
      "name": "minimum",
      "signature": "let minimum: t<'value, 'id> => option<'value>",
      "docstrings": ["Returns minimum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.minimum /* None */\n  s1->Belt.MutableSet.minimum /* Some(1) */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.minUndefined",
      "kind": "value",
      "name": "minUndefined",
      "signature": "let minUndefined: t<'value, 'id> => Js.undefined<'value>",
      "docstrings": ["Returns minimum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.minUndefined /* undefined */\n  s1->Belt.MutableSet.minUndefined /* 1 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.maximum",
      "kind": "value",
      "name": "maximum",
      "signature": "let maximum: t<'value, 'id> => option<'value>",
      "docstrings": ["Returns maximum value of the collection. `None` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.maximum /* None */\n  s1->Belt.MutableSet.maximum /* Some(5) */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.maxUndefined",
      "kind": "value",
      "name": "maxUndefined",
      "signature": "let maxUndefined: t<'value, 'id> => Js.undefined<'value>",
      "docstrings": ["Returns maximum value of the collection. `undefined` if collection is empty.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.make(~id=module(IntCmp))\n  let s1 = Belt.MutableSet.fromArray([3, 2, 1, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.maxUndefined /* undefined */\n  s1->Belt.MutableSet.maxUndefined /* 5 */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'value, 'id>, 'value) => option<'value>",
      "docstrings": ["Returns the reference of the value which is equivalent to value using the comparator specifiecd by this collection. Returns `None` if element does not exist.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n\n  s0->Belt.MutableSet.get(3) /* Some(3) */\n  s0->Belt.MutableSet.get(20) /* None */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.getUndefined",
      "kind": "value",
      "name": "getUndefined",
      "signature": "let getUndefined: (t<'value, 'id>, 'value) => Js.undefined<'value>",
      "docstrings": ["Same as [get](#get) but returns `undefined` when element does not exist."]
    }, 
    {
      "id": "Belt.Belt_MutableSet.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'value, 'id>, 'value) => 'value",
      "docstrings": ["Same as [get](#get) but raise when element does not exist."]
    }, 
    {
      "id": "Belt.Belt_MutableSet.split",
      "kind": "value",
      "name": "split",
      "signature": "let split: (t<'value, 'id>, 'value) => ((t<'value, 'id>, t<'value, 'id>), bool)",
      "docstrings": ["Returns a tuple `((smaller, larger), present)`, `present` is true when element exist in set.\n\n  ```rescript\n  module IntCmp = Belt.Id.MakeComparable({\n    type t = int\n    let cmp = Pervasives.compare\n  })\n\n  let s0 = Belt.MutableSet.fromArray([1, 2, 3, 4, 5], ~id=module(IntCmp))\n\n  let ((smaller, larger), present) = s0->Belt.MutableSet.split(3)\n\n  present /* true */\n  smaller->Belt.MutableSet.toArray /* [1,2] */\n  larger->Belt.MutableSet.toArray /* [4,5] */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_MutableSet.checkInvariantInternal",
      "kind": "value",
      "name": "checkInvariantInternal",
      "signature": "let checkInvariantInternal: t<'a, 'b> => unit",
      "docstrings": ["**raise** when invariant is not held"]
    }]
  }, 
  {
    "id": "Belt.Belt_MutableMap",
    "kind": "moduleAlias",
    "name": "MutableMap",
    "docstrings": ["[`Belt.MutableMap`]()\n\n  The top level provides generic **mutable** map operations.\n\n  It also has two specialized inner modules\n  [`Belt.MutableMap.Int`]() and [`Belt.MutableMap.String`]()"],
    "items": [
    {
      "id": "Belt.Belt_MutableMap.Belt_MutableMapInt",
      "kind": "moduleAlias",
      "name": "Int",
      "docstrings": [],
      "items": [
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.key",
        "kind": "type",
        "name": "key",
        "signature": "type key = int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.t",
        "kind": "type",
        "name": "t",
        "signature": "type t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.clear",
        "kind": "value",
        "name": "clear",
        "signature": "let clear: t<'a> => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t<'a> => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t<'a>, key) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.cmpU",
        "kind": "value",
        "name": "cmpU",
        "signature": "let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int",
        "docstrings": ["`cmp m1 m2 cmp`\n  First compare by size, if size is the same,\n  compare by key, value pair"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.eqU",
        "kind": "value",
        "name": "eqU",
        "signature": "let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool",
        "docstrings": ["`eq m1 m2 cmp`"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t<'a>, (. key, 'a) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t<'a>, (key, 'a) => unit) => unit",
        "docstrings": ["`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument.\n  The application order of `f`  is in increasing order."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t<'a>, 'b, (. 'b, key, 'a) => 'b) => 'b",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b",
        "docstrings": ["`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t<'a>, (. key, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t<'a>, (key, 'a) => bool) => bool",
        "docstrings": ["`every m p` checks if all the bindings of the map\n  satisfy the predicate `p`.\n  The application order of `p` is unspecified."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t<'a>, (. key, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t<'a>, (key, 'a) => bool) => bool",
        "docstrings": ["`some m p` checks if at least one binding of the map\n  satisfy the predicate `p`.\n  The application order of `p` is unspecified."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t<'a> => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t<'a> => list<(key, 'a)>",
        "docstrings": ["In increasing order"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t<'a> => array<(key, 'a)>",
        "docstrings": ["In increasing order"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<(key, 'a)> => t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "signature": "let keysToArray: t<'a> => array<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "signature": "let valuesToArray: t<'a> => array<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.minKey",
        "kind": "value",
        "name": "minKey",
        "signature": "let minKey: t<'a> => option<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.maxKey",
        "kind": "value",
        "name": "maxKey",
        "signature": "let maxKey: t<'a> => option<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t<'a> => option<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t<'a> => Js.undefined<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t<'a> => option<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t<'a> => Js.undefined<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t<'a>, key) => option<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t<'a>, key) => Js.undefined<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "signature": "let getWithDefault: (t<'a>, key, 'a) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t<'a>, key) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t<'a> => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t<'a>, key) => unit",
        "docstrings": ["`remove m x` do the in-place modification"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t<'a>, array<key>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.set",
        "kind": "value",
        "name": "set",
        "signature": "let set: (t<'a>, key, 'a) => unit",
        "docstrings": ["`set m x y` do the in-place modification, return\n  `m` for chaining. If `x` was already bound\n  in `m`, its previous binding disappears."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.updateU",
        "kind": "value",
        "name": "updateU",
        "signature": "let updateU: (t<'a>, key, (. option<'a>) => option<'a>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.update",
        "kind": "value",
        "name": "update",
        "signature": "let update: (t<'a>, key, option<'a> => option<'a>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.mapU",
        "kind": "value",
        "name": "mapU",
        "signature": "let mapU: (t<'a>, (. 'a) => 'b) => t<'b>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.map",
        "kind": "value",
        "name": "map",
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>",
        "docstrings": ["`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "signature": "let mapWithKeyU: (t<'a>, (. key, 'a) => 'b) => t<'b>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapInt.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "signature": "let mapWithKey: (t<'a>, (key, 'a) => 'b) => t<'b>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_MutableMap.Belt_MutableMapString",
      "kind": "moduleAlias",
      "name": "String",
      "docstrings": [],
      "items": [
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.key",
        "kind": "type",
        "name": "key",
        "signature": "type key = string",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.t",
        "kind": "type",
        "name": "t",
        "signature": "type t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: unit => t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.clear",
        "kind": "value",
        "name": "clear",
        "signature": "let clear: t<'a> => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t<'a> => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t<'a>, key) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.cmpU",
        "kind": "value",
        "name": "cmpU",
        "signature": "let cmpU: (t<'a>, t<'a>, (. 'a, 'a) => int) => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.cmp",
        "kind": "value",
        "name": "cmp",
        "signature": "let cmp: (t<'a>, t<'a>, ('a, 'a) => int) => int",
        "docstrings": ["`cmp m1 m2 cmp`\n  First compare by size, if size is the same,\n  compare by key, value pair"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.eqU",
        "kind": "value",
        "name": "eqU",
        "signature": "let eqU: (t<'a>, t<'a>, (. 'a, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.eq",
        "kind": "value",
        "name": "eq",
        "signature": "let eq: (t<'a>, t<'a>, ('a, 'a) => bool) => bool",
        "docstrings": ["`eq m1 m2 cmp`"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t<'a>, (. key, 'a) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t<'a>, (key, 'a) => unit) => unit",
        "docstrings": ["`forEach m f` applies `f` to all bindings in map `m`.\n  `f` receives the key as first argument, and the associated value\n  as second argument.\n  The application order of `f`  is in increasing order."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t<'a>, 'b, (. 'b, key, 'a) => 'b) => 'b",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t<'a>, 'b, ('b, key, 'a) => 'b) => 'b",
        "docstrings": ["`reduce m a f` computes `(f kN dN ... (f k1 d1 a)...)`,\n  where `k1 ... kN` are the keys of all bindings in `m`\n  (in increasing order), and `d1 ... dN` are the associated data."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.everyU",
        "kind": "value",
        "name": "everyU",
        "signature": "let everyU: (t<'a>, (. key, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.every",
        "kind": "value",
        "name": "every",
        "signature": "let every: (t<'a>, (key, 'a) => bool) => bool",
        "docstrings": ["`every m p` checks if all the bindings of the map\n  satisfy the predicate `p`.\n  The application order of `p` is unspecified."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.someU",
        "kind": "value",
        "name": "someU",
        "signature": "let someU: (t<'a>, (. key, 'a) => bool) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.some",
        "kind": "value",
        "name": "some",
        "signature": "let some: (t<'a>, (key, 'a) => bool) => bool",
        "docstrings": ["`some m p` checks if at least one binding of the map\n  satisfy the predicate `p`.\n  The application order of `p` is unspecified."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t<'a> => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.toList",
        "kind": "value",
        "name": "toList",
        "signature": "let toList: t<'a> => list<(key, 'a)>",
        "docstrings": ["In increasing order"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t<'a> => array<(key, 'a)>",
        "docstrings": ["In increasing order"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<(key, 'a)> => t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "signature": "let keysToArray: t<'a> => array<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "signature": "let valuesToArray: t<'a> => array<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.minKey",
        "kind": "value",
        "name": "minKey",
        "signature": "let minKey: t<'a> => option<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.minKeyUndefined",
        "kind": "value",
        "name": "minKeyUndefined",
        "signature": "let minKeyUndefined: t<'a> => Js.undefined<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.maxKey",
        "kind": "value",
        "name": "maxKey",
        "signature": "let maxKey: t<'a> => option<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.maxKeyUndefined",
        "kind": "value",
        "name": "maxKeyUndefined",
        "signature": "let maxKeyUndefined: t<'a> => Js.undefined<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.minimum",
        "kind": "value",
        "name": "minimum",
        "signature": "let minimum: t<'a> => option<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.minUndefined",
        "kind": "value",
        "name": "minUndefined",
        "signature": "let minUndefined: t<'a> => Js.undefined<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.maximum",
        "kind": "value",
        "name": "maximum",
        "signature": "let maximum: t<'a> => option<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.maxUndefined",
        "kind": "value",
        "name": "maxUndefined",
        "signature": "let maxUndefined: t<'a> => Js.undefined<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t<'a>, key) => option<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.getUndefined",
        "kind": "value",
        "name": "getUndefined",
        "signature": "let getUndefined: (t<'a>, key) => Js.undefined<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.getWithDefault",
        "kind": "value",
        "name": "getWithDefault",
        "signature": "let getWithDefault: (t<'a>, key, 'a) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.getExn",
        "kind": "value",
        "name": "getExn",
        "signature": "let getExn: (t<'a>, key) => 'a",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.checkInvariantInternal",
        "kind": "value",
        "name": "checkInvariantInternal",
        "signature": "let checkInvariantInternal: t<'a> => unit",
        "docstrings": ["**raise** when invariant is not held"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t<'a>, key) => unit",
        "docstrings": ["`remove m x` do the in-place modification"]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.removeMany",
        "kind": "value",
        "name": "removeMany",
        "signature": "let removeMany: (t<'a>, array<key>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.set",
        "kind": "value",
        "name": "set",
        "signature": "let set: (t<'a>, key, 'a) => unit",
        "docstrings": ["`set m x y` do the in-place modification, return\n  `m` for chaining. If `x` was already bound\n  in `m`, its previous binding disappears."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.updateU",
        "kind": "value",
        "name": "updateU",
        "signature": "let updateU: (t<'a>, key, (. option<'a>) => option<'a>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.update",
        "kind": "value",
        "name": "update",
        "signature": "let update: (t<'a>, key, option<'a> => option<'a>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.mapU",
        "kind": "value",
        "name": "mapU",
        "signature": "let mapU: (t<'a>, (. 'a) => 'b) => t<'b>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.map",
        "kind": "value",
        "name": "map",
        "signature": "let map: (t<'a>, 'a => 'b) => t<'b>",
        "docstrings": ["`map m f` returns a map with same domain as `m`, where the\n  associated value `a` of all bindings of `m` has been\n  replaced by the result of the application of `f` to `a`.\n  The bindings are passed to `f` in increasing order\n  with respect to the ordering over the type of the keys."]
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.mapWithKeyU",
        "kind": "value",
        "name": "mapWithKeyU",
        "signature": "let mapWithKeyU: (t<'a>, (. key, 'a) => 'b) => t<'b>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_MutableMap.Belt_MutableMapString.mapWithKey",
        "kind": "value",
        "name": "mapWithKey",
        "signature": "let mapWithKey: (t<'a>, (key, 'a) => 'b) => t<'b>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_MutableMap.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'k, 'v, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.id",
      "kind": "type",
      "name": "id",
      "signature": "type id<'key, 'id> = Belt_Id.comparable<'key, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (~id: id<'k, 'id>) => t<'k, 'a, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'a, 'b, 'c> => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a, 'b, 'c> => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'k, 'a, 'b>, 'k) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.cmpU",
      "kind": "value",
      "name": "cmpU",
      "signature": "let cmpU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, (. 'a, 'a) => int) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => int) => int",
      "docstrings": ["`cmp(m1, m2, cmp)` First compare by size, if size is the same, compare by\n    key, value pair."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.eqU",
      "kind": "value",
      "name": "eqU",
      "signature": "let eqU: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, (. 'a, 'a) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'k, 'a, 'id>, t<'k, 'a, 'id>, ('a, 'a) => bool) => bool",
      "docstrings": ["`eq(m1, m2, eqf)` tests whether the maps `m1` and `m2` are equal, that is,\n    contain equal keys and associate them with equal data. `eqf` is the\n    equality predicate used to compare the data associated with the keys."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'k, 'a, 'id>, (. 'k, 'a) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'k, 'a, 'id>, ('k, 'a) => unit) => unit",
      "docstrings": ["`forEach(m, f)` applies f to all bindings in map `m`. `f` receives the `'k`\n    as first argument, and the associated value as second argument. The\n    bindings are passed to `f` in increasing order with respect to the ordering\n    over the type of the keys."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'k, 'a, 'id>, 'b, (. 'b, 'k, 'a) => 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'k, 'a, 'id>, 'b, ('b, 'k, 'a) => 'b) => 'b",
      "docstrings": ["`reduce(m, a, f), computes`(f(kN, dN) ... (f(k1, d1, a))...)`, where`k1 ...\n    kN`are the keys of all bindings in`m`(in increasing order), and`d1 ... dN`\n    are the associated data."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.everyU",
      "kind": "value",
      "name": "everyU",
      "signature": "let everyU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.every",
      "kind": "value",
      "name": "every",
      "signature": "let every: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool",
      "docstrings": ["`every(m, p)` checks if all the bindings of the map satisfy the predicate\n    `p`."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.someU",
      "kind": "value",
      "name": "someU",
      "signature": "let someU: (t<'k, 'a, 'id>, (. 'k, 'a) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.some",
      "kind": "value",
      "name": "some",
      "signature": "let some: (t<'k, 'a, 'id>, ('k, 'a) => bool) => bool",
      "docstrings": ["`some(m, p)` checks if at least one binding of the map satisfy the\n    predicate `p`."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'k, 'a, 'id> => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.toList",
      "kind": "value",
      "name": "toList",
      "signature": "let toList: t<'k, 'a, 'id> => list<('k, 'a)>",
      "docstrings": ["In increasing order."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'k, 'a, 'id> => array<('k, 'a)>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: (array<('k, 'a)>, ~id: id<'k, 'id>) => t<'k, 'a, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.keysToArray",
      "kind": "value",
      "name": "keysToArray",
      "signature": "let keysToArray: t<'k, 'a, 'b> => array<'k>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.valuesToArray",
      "kind": "value",
      "name": "valuesToArray",
      "signature": "let valuesToArray: t<'a, 'a0, 'b> => array<'a0>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.minKey",
      "kind": "value",
      "name": "minKey",
      "signature": "let minKey: t<'k, 'a, 'b> => option<'k>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.minKeyUndefined",
      "kind": "value",
      "name": "minKeyUndefined",
      "signature": "let minKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.maxKey",
      "kind": "value",
      "name": "maxKey",
      "signature": "let maxKey: t<'k, 'a, 'b> => option<'k>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.maxKeyUndefined",
      "kind": "value",
      "name": "maxKeyUndefined",
      "signature": "let maxKeyUndefined: t<'k, 'a, 'b> => Js.undefined<'k>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.minimum",
      "kind": "value",
      "name": "minimum",
      "signature": "let minimum: t<'k, 'a, 'b> => option<('k, 'a)>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.minUndefined",
      "kind": "value",
      "name": "minUndefined",
      "signature": "let minUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.maximum",
      "kind": "value",
      "name": "maximum",
      "signature": "let maximum: t<'k, 'a, 'b> => option<('k, 'a)>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.maxUndefined",
      "kind": "value",
      "name": "maxUndefined",
      "signature": "let maxUndefined: t<'k, 'a, 'b> => Js.undefined<('k, 'a)>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'k, 'a, 'id>, 'k) => option<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.getUndefined",
      "kind": "value",
      "name": "getUndefined",
      "signature": "let getUndefined: (t<'k, 'a, 'id>, 'k) => Js.undefined<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "signature": "let getWithDefault: (t<'k, 'a, 'id>, 'k, 'a) => 'a",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: (t<'k, 'a, 'id>, 'k) => 'a",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.checkInvariantInternal",
      "kind": "value",
      "name": "checkInvariantInternal",
      "signature": "let checkInvariantInternal: t<'a, 'b, 'c> => unit",
      "docstrings": ["Raise when invariant is not held."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'k, 'a, 'id>, 'k) => unit",
      "docstrings": ["`remove(m, x)` do the in-place modification."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.removeMany",
      "kind": "value",
      "name": "removeMany",
      "signature": "let removeMany: (t<'k, 'a, 'id>, array<'k>) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'k, 'a, 'id>, 'k, 'a) => unit",
      "docstrings": ["`set(m, x, y)` do the in-place modification"]
    }, 
    {
      "id": "Belt.Belt_MutableMap.updateU",
      "kind": "value",
      "name": "updateU",
      "signature": "let updateU: (t<'k, 'a, 'id>, 'k, (. option<'a>) => option<'a>) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.update",
      "kind": "value",
      "name": "update",
      "signature": "let update: (t<'k, 'a, 'id>, 'k, option<'a> => option<'a>) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t<'k, 'a, 'id>, array<('k, 'a)>) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (t<'k, 'a, 'id>, (. 'a) => 'b) => t<'k, 'b, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'k, 'a, 'id>, 'a => 'b) => t<'k, 'b, 'id>",
      "docstrings": ["`map(m, f)` returns a map with same domain as `m`, where the associated\n    value a of all bindings of `m` has been replaced by the result of the\n    application of `f` to `a`. The bindings are passed to `f` in increasing\n    order with respect to the ordering over the type of the keys."]
    }, 
    {
      "id": "Belt.Belt_MutableMap.mapWithKeyU",
      "kind": "value",
      "name": "mapWithKeyU",
      "signature": "let mapWithKeyU: (t<'k, 'a, 'id>, (. 'k, 'a) => 'b) => t<'k, 'b, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_MutableMap.mapWithKey",
      "kind": "value",
      "name": "mapWithKey",
      "signature": "let mapWithKey: (t<'k, 'a, 'id>, ('k, 'a) => 'b) => t<'k, 'b, 'id>",
      "docstrings": []
    }]
  }, 
  {
    "id": "Belt.Belt_HashSet",
    "kind": "moduleAlias",
    "name": "HashSet",
    "docstrings": ["[`Belt.HashSet`]()\n\n  The top level provides generic **mutable** hash set operations.\n\n  It also has two specialized inner modules\n  [`Belt.HashSet.Int`]() and [`Belt.HashSet.String`]()"],
    "items": [
    {
      "id": "Belt.Belt_HashSet.Belt_HashSetInt",
      "kind": "moduleAlias",
      "name": "Int",
      "docstrings": ["Specalized when key type is `int`, more efficient\n    than the generic type"],
      "items": [
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.key",
        "kind": "type",
        "name": "key",
        "signature": "type key = int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: (~hintSize: int) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.clear",
        "kind": "value",
        "name": "clear",
        "signature": "let clear: t => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.add",
        "kind": "value",
        "name": "add",
        "signature": "let add: (t, key) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.copy",
        "kind": "value",
        "name": "copy",
        "signature": "let copy: t => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t, key) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t, key) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t, (. key) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t, key => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t, 'c, (. 'c, key) => 'c) => 'c",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t, 'c, ('c, key) => 'c) => 'c",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.logStats",
        "kind": "value",
        "name": "logStats",
        "signature": "let logStats: t => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t => array<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<key> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t, array<key>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetInt.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "signature": "let getBucketHistogram: t => array<int>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_HashSet.Belt_HashSetString",
      "kind": "moduleAlias",
      "name": "String",
      "docstrings": ["Specalized when key type is `string`, more efficient\n    than the generic type"],
      "items": [
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.key",
        "kind": "type",
        "name": "key",
        "signature": "type key = string",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.t",
        "kind": "type",
        "name": "t",
        "signature": "type t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: (~hintSize: int) => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.clear",
        "kind": "value",
        "name": "clear",
        "signature": "let clear: t => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.add",
        "kind": "value",
        "name": "add",
        "signature": "let add: (t, key) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.copy",
        "kind": "value",
        "name": "copy",
        "signature": "let copy: t => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t, key) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t, key) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t, (. key) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t, key => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t, 'c, (. 'c, key) => 'c) => 'c",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t, 'c, ('c, key) => 'c) => 'c",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.logStats",
        "kind": "value",
        "name": "logStats",
        "signature": "let logStats: t => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t => array<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<key> => t",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t, array<key>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashSet.Belt_HashSetString.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "signature": "let getBucketHistogram: t => array<int>",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_HashSet.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.id",
      "kind": "type",
      "name": "id",
      "signature": "type id<'a, 'id> = Belt_Id.hashable<'a, 'id>",
      "docstrings": ["The type of hash tables from type `'a` to type `'b`."]
    }, 
    {
      "id": "Belt.Belt_HashSet.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (~hintSize: int, ~id: id<'a, 'id>) => t<'a, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'a, 'id> => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a, 'b> => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.add",
      "kind": "value",
      "name": "add",
      "signature": "let add: (t<'a, 'id>, 'a) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'a, 'id> => t<'a, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'a, 'id>, 'a) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'a, 'id>, 'a) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'a, 'id>, (. 'a) => unit) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'a, 'id>, 'a => unit) => unit",
      "docstrings": ["Order unspecified."]
    }, 
    {
      "id": "Belt.Belt_HashSet.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'a, 'id>, 'c, (. 'c, 'a) => 'c) => 'c",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'a, 'id>, 'c, ('c, 'a) => 'c) => 'c",
      "docstrings": ["Order unspecified."]
    }, 
    {
      "id": "Belt.Belt_HashSet.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'a, 'id> => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.logStats",
      "kind": "value",
      "name": "logStats",
      "signature": "let logStats: t<'a, 'b> => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'a, 'id> => array<'a>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: (array<'a>, ~id: id<'a, 'id>) => t<'a, 'id>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t<'a, 'id>, array<'a>) => unit",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashSet.getBucketHistogram",
      "kind": "value",
      "name": "getBucketHistogram",
      "signature": "let getBucketHistogram: t<'a, 'b> => array<int>",
      "docstrings": []
    }]
  }, 
  {
    "id": "Belt.Belt_HashMap",
    "kind": "moduleAlias",
    "name": "HashMap",
    "docstrings": ["[`Belt.HashMap`]()\n\n  The top level provides generic **mutable** hash map operations.\n\n  It also has two specialized inner modules\n  [`Belt.HashMap.Int`]() and [`Belt.HashMap.String`]()"],
    "items": [
    {
      "id": "Belt.Belt_HashMap.Belt_HashMapInt",
      "kind": "moduleAlias",
      "name": "Int",
      "docstrings": ["Specalized when key type is `int`, more efficient\n    than the generic type"],
      "items": [
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.key",
        "kind": "type",
        "name": "key",
        "signature": "type key = int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.t",
        "kind": "type",
        "name": "t",
        "signature": "type t<'b>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: (~hintSize: int) => t<'b>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.clear",
        "kind": "value",
        "name": "clear",
        "signature": "let clear: t<'b> => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t<'a> => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.set",
        "kind": "value",
        "name": "set",
        "signature": "let set: (t<'a>, key, 'a) => unit",
        "docstrings": ["`setDone tbl k v` if `k` does not exist,\n  add the binding `k,v`, otherwise, update the old value with the new\n  `v`"]
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.copy",
        "kind": "value",
        "name": "copy",
        "signature": "let copy: t<'a> => t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t<'a>, key) => option<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t<'b>, key) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t<'a>, key) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t<'b>, (. key, 'b) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t<'b>, (key, 'b) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t<'b>, 'c, (. 'c, key, 'b) => 'c) => 'c",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t<'b>, 'c, ('c, key, 'b) => 'c) => 'c",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.keepMapInPlaceU",
        "kind": "value",
        "name": "keepMapInPlaceU",
        "signature": "let keepMapInPlaceU: (t<'a>, (. key, 'a) => option<'a>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.keepMapInPlace",
        "kind": "value",
        "name": "keepMapInPlace",
        "signature": "let keepMapInPlace: (t<'a>, (key, 'a) => option<'a>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t<'a> => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t<'a> => array<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "signature": "let keysToArray: t<'a> => array<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "signature": "let valuesToArray: t<'a> => array<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<(key, 'a)> => t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t<'a>, array<(key, 'a)>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "signature": "let getBucketHistogram: t<'a> => array<int>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapInt.logStats",
        "kind": "value",
        "name": "logStats",
        "signature": "let logStats: t<'a> => unit",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_HashMap.Belt_HashMapString",
      "kind": "moduleAlias",
      "name": "String",
      "docstrings": ["Specalized when key type is `string`, more efficient\n    than the generic type"],
      "items": [
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.key",
        "kind": "type",
        "name": "key",
        "signature": "type key = string",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.t",
        "kind": "type",
        "name": "t",
        "signature": "type t<'b>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.make",
        "kind": "value",
        "name": "make",
        "signature": "let make: (~hintSize: int) => t<'b>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.clear",
        "kind": "value",
        "name": "clear",
        "signature": "let clear: t<'b> => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.isEmpty",
        "kind": "value",
        "name": "isEmpty",
        "signature": "let isEmpty: t<'a> => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.set",
        "kind": "value",
        "name": "set",
        "signature": "let set: (t<'a>, key, 'a) => unit",
        "docstrings": ["`setDone tbl k v` if `k` does not exist,\n  add the binding `k,v`, otherwise, update the old value with the new\n  `v`"]
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.copy",
        "kind": "value",
        "name": "copy",
        "signature": "let copy: t<'a> => t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.get",
        "kind": "value",
        "name": "get",
        "signature": "let get: (t<'a>, key) => option<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.has",
        "kind": "value",
        "name": "has",
        "signature": "let has: (t<'b>, key) => bool",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.remove",
        "kind": "value",
        "name": "remove",
        "signature": "let remove: (t<'a>, key) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.forEachU",
        "kind": "value",
        "name": "forEachU",
        "signature": "let forEachU: (t<'b>, (. key, 'b) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.forEach",
        "kind": "value",
        "name": "forEach",
        "signature": "let forEach: (t<'b>, (key, 'b) => unit) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.reduceU",
        "kind": "value",
        "name": "reduceU",
        "signature": "let reduceU: (t<'b>, 'c, (. 'c, key, 'b) => 'c) => 'c",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.reduce",
        "kind": "value",
        "name": "reduce",
        "signature": "let reduce: (t<'b>, 'c, ('c, key, 'b) => 'c) => 'c",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.keepMapInPlaceU",
        "kind": "value",
        "name": "keepMapInPlaceU",
        "signature": "let keepMapInPlaceU: (t<'a>, (. key, 'a) => option<'a>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.keepMapInPlace",
        "kind": "value",
        "name": "keepMapInPlace",
        "signature": "let keepMapInPlace: (t<'a>, (key, 'a) => option<'a>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.size",
        "kind": "value",
        "name": "size",
        "signature": "let size: t<'a> => int",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.toArray",
        "kind": "value",
        "name": "toArray",
        "signature": "let toArray: t<'a> => array<(key, 'a)>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.keysToArray",
        "kind": "value",
        "name": "keysToArray",
        "signature": "let keysToArray: t<'a> => array<key>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.valuesToArray",
        "kind": "value",
        "name": "valuesToArray",
        "signature": "let valuesToArray: t<'a> => array<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.fromArray",
        "kind": "value",
        "name": "fromArray",
        "signature": "let fromArray: array<(key, 'a)> => t<'a>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.mergeMany",
        "kind": "value",
        "name": "mergeMany",
        "signature": "let mergeMany: (t<'a>, array<(key, 'a)>) => unit",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.getBucketHistogram",
        "kind": "value",
        "name": "getBucketHistogram",
        "signature": "let getBucketHistogram: t<'a> => array<int>",
        "docstrings": []
      }, 
      {
        "id": "Belt.Belt_HashMap.Belt_HashMapString.logStats",
        "kind": "value",
        "name": "logStats",
        "signature": "let logStats: t<'a> => unit",
        "docstrings": []
      }]
    }, 
    {
      "id": "Belt.Belt_HashMap.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'key, 'value, 'id>",
      "docstrings": ["The type of hash tables from type `'key` to type `'value`."]
    }, 
    {
      "id": "Belt.Belt_HashMap.id",
      "kind": "type",
      "name": "id",
      "signature": "type id<'a, 'id> = Belt_Id.hashable<'a, 'id>",
      "docstrings": ["The identity needed for making an empty hash map."]
    }, 
    {
      "id": "Belt.Belt_HashMap.make",
      "kind": "value",
      "name": "make",
      "signature": "let make: (~hintSize: int, ~id: id<'key, 'id>) => t<'key, 'value, 'id>",
      "docstrings": ["`make(~hintSize=10, ~id)` creates a new map by taking in the comparator and `hintSize`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n\n  Belt.HashMap.set(hMap, 0, \"a\")\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.clear",
      "kind": "value",
      "name": "clear",
      "signature": "let clear: t<'key, 'value, 'id> => unit",
      "docstrings": ["Clears a hash table.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let hMap = Belt.HashMap.fromArray([(1, \"1\")], ~id=module(IntHash))\n  Belt.HashMap.clear(hMap)\n  Belt.HashMap.isEmpty(hMap) == true\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.isEmpty",
      "kind": "value",
      "name": "isEmpty",
      "signature": "let isEmpty: t<'a, 'b, 'c> => bool",
      "docstrings": ["`isEmpty(m)` checks whether a hash map is empty.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  Belt.HashMap.isEmpty(Belt.HashMap.fromArray([(1, \"1\")], ~id=module(IntHash))) == false\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.set",
      "kind": "value",
      "name": "set",
      "signature": "let set: (t<'key, 'value, 'id>, 'key, 'value) => unit",
      "docstrings": ["`set(hMap, k, v)` if `k` does not exist, add the binding `k,v`, otherwise, update the old value with the new `v`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntHash))\n\n  Belt.HashMap.set(s0, 2, \"3\")\n\n  Belt.HashMap.valuesToArray(s0) == [\"1\", \"3\", \"3\"]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.copy",
      "kind": "value",
      "name": "copy",
      "signature": "let copy: t<'key, 'value, 'id> => t<'key, 'value, 'id>",
      "docstrings": ["Creates copy of a hash map.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.fromArray([(2, \"2\"), (1, \"1\"), (3, \"3\")], ~id=module(IntHash))\n  let s1 = Belt.HashMap.copy(s0)\n\n  Belt.HashMap.set(s0, 2, \"3\")\n\n  Belt.HashMap.get(s0, 2) != Belt.HashMap.get(s1, 2)\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.get",
      "kind": "value",
      "name": "get",
      "signature": "let get: (t<'key, 'value, 'id>, 'key) => option<'value>",
      "docstrings": ["Returns value bound under specific key. If values not exist returns `None`.\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, \"value1\")\n\nBelt.HashMap.get(s0, 1) == Some(\"value1\")\nBelt.HashMap.get(s0, 2) == None\n```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.has",
      "kind": "value",
      "name": "has",
      "signature": "let has: (t<'key, 'value, 'id>, 'key) => bool",
      "docstrings": ["Checks if `x` is bound in `tbl`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n\n  Belt.HashMap.has(s0, 1) == true\n  Belt.HashMap.has(s0, 2) == false\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.remove",
      "kind": "value",
      "name": "remove",
      "signature": "let remove: (t<'key, 'value, 'id>, 'key) => unit",
      "docstrings": ["If bound exists, removes it from the hash map.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.remove(s0, 1)\n  Belt.HashMap.has(s0, 1) == false\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (t<'key, 'value, 'id>, (. 'key, 'value) => unit) => unit",
      "docstrings": ["Same as [forEach](#forEach) but takes uncurried function."]
    }, 
    {
      "id": "Belt.Belt_HashMap.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (t<'key, 'value, 'id>, ('key, 'value) => unit) => unit",
      "docstrings": ["`forEach(tbl, f)` applies `f` to all bindings in table `tbl`. `f` receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to `f`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.forEach(s0, (key, value) => Js.log2(key, value))\n  // prints (1, \"value1\")\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.reduceU",
      "kind": "value",
      "name": "reduceU",
      "signature": "let reduceU: (t<'key, 'value, 'id>, 'c, (. 'c, 'key, 'value) => 'c) => 'c",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_HashMap.reduce",
      "kind": "value",
      "name": "reduce",
      "signature": "let reduce: (t<'key, 'value, 'id>, 'c, ('c, 'key, 'value) => 'c) => 'c",
      "docstrings": ["`reduce(tbl, init, f)` computes `(f(kN, dN) ... (f(k1, d1, init))...)`, where `k1 ... kN` are the keys of all bindings in `tbl`, and `d1 ... dN` are the associated values. Each binding is presented exactly once to `f`.\n\n  The order in which the bindings are passed to `f` is unspecified. However, if the table contains several bindings for the same key, they are passed to `f` in reverse order of introduction, that is, the most recent binding is passed first.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.reduce(s0, \"\", (acc, key, value) => acc ++ (\", \" ++ value)) == \"value1, value2\"\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.keepMapInPlaceU",
      "kind": "value",
      "name": "keepMapInPlaceU",
      "signature": "let keepMapInPlaceU: (t<'key, 'value, 'id>, (. 'key, 'value) => option<'value>) => unit",
      "docstrings": ["Same as [keepMapInPlace](#keepMapInPlace) but takes uncurried function."]
    }, 
    {
      "id": "Belt.Belt_HashMap.keepMapInPlace",
      "kind": "value",
      "name": "keepMapInPlace",
      "signature": "let keepMapInPlace: (t<'key, 'value, 'id>, ('key, 'value) => option<'value>) => unit",
      "docstrings": ["Filters out values for which function `f` returned `None`.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.keepMapInPlace(s0, (key, value) => key == 1 ? None : Some(value))\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.size",
      "kind": "value",
      "name": "size",
      "signature": "let size: t<'a, 'b, 'c> => int",
      "docstrings": ["`size(tbl)` returns the number of bindings in `tbl`. It takes constant time.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.size(s0) == 2\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.toArray",
      "kind": "value",
      "name": "toArray",
      "signature": "let toArray: t<'key, 'value, 'id> => array<('key, 'value)>",
      "docstrings": ["Returns array of key value pairs.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.toArray(s0) == [(1, \"value1\"), (2, \"value2\")]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.keysToArray",
      "kind": "value",
      "name": "keysToArray",
      "signature": "let keysToArray: t<'key, 'a, 'b> => array<'key>",
      "docstrings": ["Returns array of keys.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.keysToArray(s0) == [1, 2]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.valuesToArray",
      "kind": "value",
      "name": "valuesToArray",
      "signature": "let valuesToArray: t<'a, 'value, 'b> => array<'value>",
      "docstrings": ["Returns array of values.\n\n  ```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n\n  let s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(s0, 1, \"value1\")\n  Belt.HashMap.set(s0, 2, \"value2\")\n\n  Belt.HashMap.valuesToArray(s0) == [\"value1\", \"value2\"]\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.fromArray",
      "kind": "value",
      "name": "fromArray",
      "signature": "let fromArray: (array<('key, 'value)>, ~id: id<'key, 'id>) => t<'key, 'value, 'id>",
      "docstrings": ["Creates new hash map from array of pairs.\n\nReturns array of values.\n\n```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.fromArray([(1, \"value1\"), (2, \"value2\")], ~id=module(IntHash))\nBelt.HashMap.toArray(s0) == [(1, \"value1\"), (2, \"value2\")]\n```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.mergeMany",
      "kind": "value",
      "name": "mergeMany",
      "signature": "let mergeMany: (t<'key, 'value, 'id>, array<('key, 'value)>) => unit",
      "docstrings": ["```rescript\nmodule IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.mergeMany(hMap, [(1, \"1\"), (2, \"2\")])\n```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.getBucketHistogram",
      "kind": "value",
      "name": "getBucketHistogram",
      "signature": "let getBucketHistogram: t<'a, 'b, 'c> => array<int>",
      "docstrings": ["```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n  let hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(hMap, 1, \"1\")\n\n  Belt.HashMap.getBucketHistogram(hMap)\n  ```"]
    }, 
    {
      "id": "Belt.Belt_HashMap.logStats",
      "kind": "value",
      "name": "logStats",
      "signature": "let logStats: t<'a, 'b, 'c> => unit",
      "docstrings": ["```rescript\n  module IntHash = Belt.Id.MakeHashable({\n    type t = int\n    let hash = a => a\n    let eq = (a, b) => a == b\n  })\n  let hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n  Belt.HashMap.set(hMap, 1, \"1\")\n\n  Belt.HashMap.logStats(hMap)\n  ```"]
    }]
  }, 
  {
    "id": "Belt.Belt_Option",
    "kind": "moduleAlias",
    "name": "Option",
    "docstrings": ["[`Belt.Option`]()\n\n  Utilities for option data type."],
    "items": [
    {
      "id": "Belt.Belt_Option.keepU",
      "kind": "value",
      "name": "keepU",
      "signature": "let keepU: (option<'a>, (. 'a) => bool) => option<'a>",
      "docstrings": ["Uncurried version of `keep`"]
    }, 
    {
      "id": "Belt.Belt_Option.keep",
      "kind": "value",
      "name": "keep",
      "signature": "let keep: (option<'a>, 'a => bool) => option<'a>",
      "docstrings": ["If `optionValue` is `Some(value)` and `p(value) = true`, it returns `Some(value)`; otherwise returns `None`\n\n   ```rescript\n   Belt.Option.keep(Some(10), x => x > 5) /* returns `Some(10)` */\n   Belt.Option.keep(Some(4), x => x > 5) /* returns `None` */\n   Belt.Option.keep(None, x => x > 5) /* returns `None` */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.forEachU",
      "kind": "value",
      "name": "forEachU",
      "signature": "let forEachU: (option<'a>, (. 'a) => unit) => unit",
      "docstrings": ["Uncurried version of `forEach`"]
    }, 
    {
      "id": "Belt.Belt_Option.forEach",
      "kind": "value",
      "name": "forEach",
      "signature": "let forEach: (option<'a>, 'a => unit) => unit",
      "docstrings": ["If `optionValue` is `Some(value`), it calls `f(value)`; otherwise returns `()`\n\n   ```rescript\n   Belt.Option.forEach(Some(\"thing\"), x => Js.log(x)) /* logs \"thing\" */\n   Belt.Option.forEach(None, x => Js.log(x)) /* returns () */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: option<'a> => 'a",
      "docstrings": ["Raises an Error in case `None` is provided. Use with care.\n\n   ```rescript\n   Belt.Option.getExn(Some(3)) /* 3 */\n\n   Belt.Option.getExn(None) /* Raises an Error */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.getUnsafe",
      "kind": "value",
      "name": "getUnsafe",
      "signature": "let getUnsafe: option<'a> => 'a",
      "docstrings": ["`getUnsafe(x)` returns `x`\n\n   This is an unsafe operation, it assumes `x` is neither `None`\n   nor `Some(None(...)))`"]
    }, 
    {
      "id": "Belt.Belt_Option.mapWithDefaultU",
      "kind": "value",
      "name": "mapWithDefaultU",
      "signature": "let mapWithDefaultU: (option<'a>, 'b, (. 'a) => 'b) => 'b",
      "docstrings": ["Uncurried version of `mapWithDefault`"]
    }, 
    {
      "id": "Belt.Belt_Option.mapWithDefault",
      "kind": "value",
      "name": "mapWithDefault",
      "signature": "let mapWithDefault: (option<'a>, 'b, 'a => 'b) => 'b",
      "docstrings": ["If `optionValue` is of `Some(value)`,\n   this function returns that value applied with `f`, in other words `f(value)`.\n\n   If `optionValue` is `None`, the default is returned.\n\n   ```rescript\n   let someValue = Some(3)\n   someValue->Belt.Option.mapWithDefault(0, x => x + 5) /* 8 */\n\n   let noneValue = None\n   noneValue->Belt.Option.mapWithDefault(0, x => x + 5) /* 0 */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (option<'a>, (. 'a) => 'b) => option<'b>",
      "docstrings": ["Uncurried version of `map`"]
    }, 
    {
      "id": "Belt.Belt_Option.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (option<'a>, 'a => 'b) => option<'b>",
      "docstrings": ["If `optionValue` is `Some(value)` this returns `f(value)`, otherwise it returns `None`.\n\n   ```rescript\n   Belt.Option.map(Some(3), x => x * x) /* Some(9) */\n\n   Belt.Option.map(None, x => x * x) /* None */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.flatMapU",
      "kind": "value",
      "name": "flatMapU",
      "signature": "let flatMapU: (option<'a>, (. 'a) => option<'b>) => option<'b>",
      "docstrings": ["Uncurried version of `flatMap`"]
    }, 
    {
      "id": "Belt.Belt_Option.flatMap",
      "kind": "value",
      "name": "flatMap",
      "signature": "let flatMap: (option<'a>, 'a => option<'b>) => option<'b>",
      "docstrings": ["If `optionValue` is `Some(value)`, returns `f(value)`, otherwise returns\n   `None`.<br/>\n   The function `f` must have a return type of `option<'b>`.\n\n   ```rescript\n   let addIfAboveOne = value =>\n     if (value > 1) {\n       Some(value + 1)\n     } else {\n       None\n     }\n\n   Belt.Option.flatMap(Some(2), addIfAboveOne) /* Some(3) */\n\n   Belt.Option.flatMap(Some(-4), addIfAboveOne) /* None */\n\n   Belt.Option.flatMap(None, addIfAboveOne) /* None */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "signature": "let getWithDefault: (option<'a>, 'a) => 'a",
      "docstrings": ["If `optionalValue` is `Some(value)`, returns `value`, otherwise default.\n\n   ```rescript\n   Belt.Option.getWithDefault(None, \"Banana\") /* Banana */\n\n   Belt.Option.getWithDefault(Some(\"Apple\"), \"Banana\") /* Apple */\n   ```\n\n   ```rescript\n   let greet = (firstName: option<string>) =>\n     \"Greetings \" ++ firstName->Belt.Option.getWithDefault(\"Anonymous\")\n\n   Some(\"Jane\")->greet /* \"Greetings Jane\" */\n\n   None->greet /* \"Greetings Anonymous\" */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.orElse",
      "kind": "value",
      "name": "orElse",
      "signature": "let orElse: (option<'a>, option<'a>) => option<'a>",
      "docstrings": ["`orElse optionalValue otherOptional`\n\n   If `optionalValue` is `Some value`, returns `Some value`, otherwise `otherOptional`\n\n   ```\n   orElse (Some 1812) (Some 1066) = Some 1812;;\n   orElse None (Some 1066) = Some 1066;;\n   orElse None None = None;;\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.isSome",
      "kind": "value",
      "name": "isSome",
      "signature": "let isSome: option<'a> => bool",
      "docstrings": ["Returns `true` if the argument is `Some(value)`, `false` otherwise.\n\n   ```rescript\n   Belt.Option.isSome(None) /* false */\n\n   Belt.Option.isSome(Some(1)) /* true */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.isNone",
      "kind": "value",
      "name": "isNone",
      "signature": "let isNone: option<'a> => bool",
      "docstrings": ["Returns `true` if the argument is `None`, `false` otherwise.\n\n   ```rescript\n   Belt.Option.isNone(None) /* true */\n\n   Belt.Option.isNone(Some(1)) /* false */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.eqU",
      "kind": "value",
      "name": "eqU",
      "signature": "let eqU: (option<'a>, option<'b>, (. 'a, 'b) => bool) => bool",
      "docstrings": ["Uncurried version of `eq`"]
    }, 
    {
      "id": "Belt.Belt_Option.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (option<'a>, option<'b>, ('a, 'b) => bool) => bool",
      "docstrings": ["Evaluates two optional values for equality with respect to a predicate\n   function. If both `optValue1` and `optValue2` are `None`, returns `true`.\n   If one of the arguments is `Some(value)` and the other is `None`, returns\n   `false`.\n\n   If arguments are `Some(value1)` and `Some(value2)`, returns the result of\n   `predicate(value1, value2)`; the predicate function must return a bool.\n\n   ```rescript\n   let clockEqual = (a, b) => mod(a, 12) == mod(b, 12)\n\n   open Belt.Option\n\n   eq(Some(3), Some(15), clockEqual) /* true */\n\n   eq(Some(3), None, clockEqual) /* false */\n\n   eq(None, Some(3), clockEqual) /* false */\n\n   eq(None, None, clockEqual) /* true */\n   ```"]
    }, 
    {
      "id": "Belt.Belt_Option.cmpU",
      "kind": "value",
      "name": "cmpU",
      "signature": "let cmpU: (option<'a>, option<'b>, (. 'a, 'b) => int) => int",
      "docstrings": ["Uncurried version of `cmp`"]
    }, 
    {
      "id": "Belt.Belt_Option.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (option<'a>, option<'b>, ('a, 'b) => int) => int",
      "docstrings": ["`cmp(optValue1, optValue2, comparisonFunction)` compares two optional values\n   with respect to given `comparisonFunction`.\n\n   If both `optValue1` and `optValue2` are `None`, it returns `0`.\n\n   If the first argument is `Some(value1)` and the second is `None`, returns `1`\n   (something is greater than nothing).\n\n   If the first argument is `None` and the second is `Some(value2)`, returns `-1`\n   (nothing is less than something).\n\n   If the arguments are `Some(value1)` and `Some(value2)`, returns the result of\n   `comparisonFunction(value1, value2)`; comparisonFunction takes two arguments\n   and returns `-1` if the first argument is less than the second, `0` if the\n   arguments are equal, and `1` if the first argument is greater than the second.\n\n   ```rescript\n   let clockCompare = (a, b) => compare(mod(a, 12), mod(b, 12))\n\n   open Belt.Option\n\n   cmp(Some(3), Some(15), clockCompare) /* 0 */\n\n   cmp(Some(3), Some(14), clockCompare) /* 1 */\n\n   cmp(Some(2), Some(15), clockCompare) /* (-1) */\n\n   cmp(None, Some(15), clockCompare) /* (-1) */\n\n   cmp(Some(14), None, clockCompare) /* 1 */\n\n   cmp(None, None, clockCompare) /* 0 */\n   ```"]
    }]
  }, 
  {
    "id": "Belt.Belt_Result",
    "kind": "moduleAlias",
    "name": "Result",
    "docstrings": ["[`Belt.Result`]()\n\n  Utilities for result data type."],
    "items": [
    {
      "id": "Belt.Belt_Result.t",
      "kind": "type",
      "name": "t",
      "signature": "type t<'a, 'b> = Ok('a) | Error('b)",
      "docstrings": [],
      "detail": 
      {
        "kind": "variant",
        "items": [
        {
          "name": "Ok",
          "docstrings": [],
          "signature": "Ok('a)"
        }, 
        {
          "name": "Error",
          "docstrings": ["The type `Result.t(result, err)` describes a variant of two states:\n  `Ok(someResult)` represents a successful operation, whereby\n  ``Error(someError)` signals an erronous operation.\n\n  In this concrete example, we are defining our own `Result` type to reflect an HTTP like\n  query operation:\n\n  ```rescript\n  type responseError = NotAvailable | NotFound\n  type queryResult = t<string, responseError>\n\n  let failQueryUser = (username: string): queryResult => {\n    Error(NotAvailable)\n  }\n```"],
          "signature": "Error('b)"
        }]
      }
    }, 
    {
      "id": "Belt.Belt_Result.getExn",
      "kind": "value",
      "name": "getExn",
      "signature": "let getExn: t<'a, 'b> => 'a",
      "docstrings": ["`getExn(res)`: when `res` is `Ok(n)`, returns `n` when `res` is `Error(m)`, raise an exception\n\n  ```rescript\n  Belt.Result.getExn(Belt.Result.Ok(42)) == 42\n\n  Belt.Result.getExn(Belt.Result.Error(\"Invalid data\")) /* raises exception */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Result.mapWithDefaultU",
      "kind": "value",
      "name": "mapWithDefaultU",
      "signature": "let mapWithDefaultU: (t<'a, 'c>, 'b, (. 'a) => 'b) => 'b",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Result.mapWithDefault",
      "kind": "value",
      "name": "mapWithDefault",
      "signature": "let mapWithDefault: (t<'a, 'c>, 'b, 'a => 'b) => 'b",
      "docstrings": ["`mapWithDefault(res, default, f)`: When res is `Ok(n)`, returns `f(n)`,\n  otherwise `default`.\n\n  ```rescript\n  let ok = Belt.Result.Ok(42)\n  Belt.Result.mapWithDefault(ok, 0, (x) => x / 2) == 21\n\n  let error = Belt.Result.Error(\"Invalid data\")\n  Belt.Result.mapWithDefault(error, 0, (x) => x / 2) == 0\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Result.mapU",
      "kind": "value",
      "name": "mapU",
      "signature": "let mapU: (t<'a, 'c>, (. 'a) => 'b) => t<'b, 'c>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Result.map",
      "kind": "value",
      "name": "map",
      "signature": "let map: (t<'a, 'c>, 'a => 'b) => t<'b, 'c>",
      "docstrings": ["`map(res, f)`: When res is `Ok(n)`, returns `Ok(f(n))`. Otherwise returns res\n  unchanged. Function `f` takes a value of the same type as `n` and returns an\n  ordinary value.\n\n  ```rescript\n  let f = (x) => sqrt(Belt.Int.toFloat(x))\n\n  Belt.Result.map(Ok(64), f) == Ok(8.0)\n\n  Belt.Result.map(Error(\"Invalid data\"), f) == Error(\"Invalid data\")\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Result.flatMapU",
      "kind": "value",
      "name": "flatMapU",
      "signature": "let flatMapU: (t<'a, 'c>, (. 'a) => t<'b, 'c>) => t<'b, 'c>",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Result.flatMap",
      "kind": "value",
      "name": "flatMap",
      "signature": "let flatMap: (t<'a, 'c>, 'a => t<'b, 'c>) => t<'b, 'c>",
      "docstrings": ["`flatMap(res, f)`: When res is `Ok(n)`, returns `f(n)`. Otherwise, returns res\n  unchanged. Function `f` takes a value of the same type as `n` and returns a\n  `Belt.Result`.\n\n  ```rescript\n  let recip = (x) =>\n    if (x !== 0.0) {\n      Belt.Result.Ok(1.0 /. x)\n    } else {\n      Belt.Result.Error(\"Divide by zero\")\n    }\n\n  Belt.Result.flatMap(Ok(2.0), recip) == Ok(0.5)\n\n  Belt.Result.flatMap(Ok(0.0), recip) == Error(\"Divide by zero\")\n\n  Belt.Result.flatMap(Error(\"Already bad\"), recip) == Error(\"Already bad\")\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Result.getWithDefault",
      "kind": "value",
      "name": "getWithDefault",
      "signature": "let getWithDefault: (t<'a, 'b>, 'a) => 'a",
      "docstrings": ["`getWithDefault(res, defaultValue)`: If `res` is `Ok(n)`, returns `n`,\n  otherwise `default`\n\n  ```rescript\n  Belt.Result.getWithDefault(Ok(42), 0) == 42\n\n  Belt.Result.getWithDefault(Error(\"Invalid Data\"), 0) == 0\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Result.isOk",
      "kind": "value",
      "name": "isOk",
      "signature": "let isOk: t<'a, 'b> => bool",
      "docstrings": ["`isOk(res)`: Returns `true` if `res` is of the form `Ok(n)`, `false` if it is\n  the `Error(e)` variant."]
    }, 
    {
      "id": "Belt.Belt_Result.isError",
      "kind": "value",
      "name": "isError",
      "signature": "let isError: t<'a, 'b> => bool",
      "docstrings": ["`isError(res)`: Returns `true` if `res` is of the form `Error(e)`, `false` if\n  it is the `Ok(n)` variant."]
    }, 
    {
      "id": "Belt.Belt_Result.eqU",
      "kind": "value",
      "name": "eqU",
      "signature": "let eqU: (t<'a, 'c>, t<'b, 'd>, (. 'a, 'b) => bool) => bool",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Result.eq",
      "kind": "value",
      "name": "eq",
      "signature": "let eq: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => bool) => bool",
      "docstrings": ["`eq(res1, res2, f)`: Determine if two `Belt.Result` variables are equal with\n  respect to an equality function. If `res1` and `res2` are of the form `Ok(n)`\n  and `Ok(m)`, return the result of `f(n, m)`. If one of `res1` and `res2` are of\n  the form `Error(e)`, return false If both `res1` and `res2` are of the form\n  `Error(e)`, return true\n\n  ```rescript\n  let good1 = Belt.Result.Ok(42)\n\n  let good2 = Belt.Result.Ok(32)\n\n  let bad1 = Belt.Result.Error(\"invalid\")\n\n  let bad2 = Belt.Result.Error(\"really invalid\")\n\n  let mod10equal = (a, b) => mod(a, 10) === mod(b, 10)\n\n  Belt.Result.eq(good1, good2, mod10equal) == true\n\n  Belt.Result.eq(good1, bad1, mod10equal) == false\n\n  Belt.Result.eq(bad2, good2, mod10equal) == false\n\n  Belt.Result.eq(bad1, bad2, mod10equal) == true\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Result.cmpU",
      "kind": "value",
      "name": "cmpU",
      "signature": "let cmpU: (t<'a, 'c>, t<'b, 'd>, (. 'a, 'b) => int) => int",
      "docstrings": []
    }, 
    {
      "id": "Belt.Belt_Result.cmp",
      "kind": "value",
      "name": "cmp",
      "signature": "let cmp: (t<'a, 'c>, t<'b, 'd>, ('a, 'b) => int) => int",
      "docstrings": ["`cmp(res1, res2, f)`: Compare two `Belt.Result` variables with respect to a\n  comparison function. The comparison function returns -1 if the first variable\n  is \"less than\" the second, 0 if the two variables are equal, and 1 if the first\n  is \"greater than\" the second.\n\n  If `res1` and `res2` are of the form `Ok(n)` and `Ok(m)`, return the result of\n  `f(n, m)`. If `res1` is of the form `Error(e)` and `res2` of the form `Ok(n)`,\n  return -1 (nothing is less than something) If `res1` is of the form `Ok(n)` and\n  `res2` of the form `Error(e)`, return 1 (something is greater than nothing) If\n  both `res1` and `res2` are of the form `Error(e)`, return 0 (equal)\n\n  ```rescript\n  let good1 = Belt.Result.Ok(59)\n\n  let good2 = Belt.Result.Ok(37)\n\n  let bad1 = Belt.Result.Error(\"invalid\")\n\n  let bad2 = Belt.Result.Error(\"really invalid\")\n\n  let mod10cmp = (a, b) => Pervasives.compare(mod(a, 10), mod(b, 10))\n\n  Belt.Result.cmp(Ok(39), Ok(57), mod10cmp) == 1\n\n  Belt.Result.cmp(Ok(57), Ok(39), mod10cmp) == (-1)\n\n  Belt.Result.cmp(Ok(39), Error(\"y\"), mod10cmp) == 1\n\n  Belt.Result.cmp(Error(\"x\"), Ok(57), mod10cmp) == (-1)\n\n  Belt.Result.cmp(Error(\"x\"), Error(\"y\"), mod10cmp) == 0\n  ```"]
    }]
  }, 
  {
    "id": "Belt.Belt_Int",
    "kind": "moduleAlias",
    "name": "Int",
    "docstrings": ["[`Belt.Int`]()\n\n  Utilities for Int."],
    "items": [
    {
      "id": "Belt.Belt_Int.toFloat",
      "kind": "value",
      "name": "toFloat",
      "signature": "let toFloat: int => float",
      "docstrings": ["Converts a given `int` to a `float`.\n\n  ```rescript\n  Js.log(Belt.Int.toFloat(1) === 1.0) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Int.fromFloat",
      "kind": "value",
      "name": "fromFloat",
      "signature": "let fromFloat: float => int",
      "docstrings": ["Converts a given `float` to an `int`.\n\n  ```rescript\n  Js.log(Belt.Int.fromFloat(1.0) === 1) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Int.fromString",
      "kind": "value",
      "name": "fromString",
      "signature": "let fromString: string => option<int>",
      "docstrings": ["Converts a given `string` to an `int`. Returns `Some(int)` when the input is a number, `None` otherwise.\n\n  ```rescript\n  Js.log(Belt.Int.fromString(\"1\") === Some(1)) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Int.toString",
      "kind": "value",
      "name": "toString",
      "signature": "let toString: int => string",
      "docstrings": ["Converts a given `int` to a `string`. Uses the JavaScript `String` constructor under the hood.\n\n  ```rescript\n  Js.log(Belt.Int.toString(1) === \"1\") /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Int.+",
      "kind": "value",
      "name": "+",
      "signature": "let _: %rescript.typehole",
      "docstrings": ["Addition of two `int` values. Same as the addition from `Pervasives`.\n\n  ```rescript\n  open Belt.Int\n  Js.log(2 + 2 === 4) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Int.-",
      "kind": "value",
      "name": "-",
      "signature": "let _: %rescript.typehole",
      "docstrings": ["Subtraction of two `int` values. Same as the subtraction from `Pervasives`.\n\n  ```rescript\n  open Belt.Int\n  Js.log(2 - 1 === 1) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Int.*",
      "kind": "value",
      "name": "*",
      "signature": "let _: %rescript.typehole",
      "docstrings": ["Multiplication of two `int` values. Same as the multiplication from `Pervasives`.\n\n  ```rescript\n  open Belt.Int\n  Js.log(2 * 2 === 4) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Int./",
      "kind": "value",
      "name": "/",
      "signature": "let _: %rescript.typehole",
      "docstrings": ["Division of two `int` values. Same as the division from `Pervasives`.\n\n  ```rescript\n  open Belt.Int\n  Js.log(4 / 2 === 2); /* true */\n  ```"]
    }]
  }, 
  {
    "id": "Belt.Belt_Float",
    "kind": "moduleAlias",
    "name": "Float",
    "docstrings": ["[`Belt.Float`]()\n\n  Utilities for Float."],
    "items": [
    {
      "id": "Belt.Belt_Float.toInt",
      "kind": "value",
      "name": "toInt",
      "signature": "let toInt: float => int",
      "docstrings": ["Converts a given `float` to an `int`.\n\n```rescript\nJs.log(Belt.Float.toInt(1.0) === 1) /* true */\n```"]
    }, 
    {
      "id": "Belt.Belt_Float.fromInt",
      "kind": "value",
      "name": "fromInt",
      "signature": "let fromInt: int => float",
      "docstrings": ["Converts a given `int` to a `float`.\n\n  ```rescript\n  Js.log(Belt.Float.fromInt(1) === 1.0) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Float.fromString",
      "kind": "value",
      "name": "fromString",
      "signature": "let fromString: string => option<float>",
      "docstrings": ["Converts a given `string` to a `float`. Returns `Some(float)` when the input is a number, `None` otherwise.\n\n  ```rescript\n  Js.log(Belt.Float.fromString(\"1.0\") === Some(1.0)) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Float.toString",
      "kind": "value",
      "name": "toString",
      "signature": "let toString: float => string",
      "docstrings": ["Converts a given `float` to a `string`. Uses the JavaScript `String` constructor under the hood.\n\n  ```rescript\n  Js.log(Belt.Float.toString(1.0) === \"1.0\") /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Float.+",
      "kind": "value",
      "name": "+",
      "signature": "let _: %rescript.typehole",
      "docstrings": ["Addition of two `float` values.\n  Can be opened in a module to avoid dot-notation (`+.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n  ```rescript\n  open Belt.Float\n  Js.log(2.0 + 2.0 === 4.0) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Float.-",
      "kind": "value",
      "name": "-",
      "signature": "let _: %rescript.typehole",
      "docstrings": ["Subtraction of two `float` values.\n  Can be opened in a module to avoid dot-notation (`-.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n  ```rescript\n  open Belt.Float\n  Js.log(2.0 - 1.0 === 1.0) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Float.*",
      "kind": "value",
      "name": "*",
      "signature": "let _: %rescript.typehole",
      "docstrings": ["Multiplication of two `float` values.\n  Can be opened in a module to avoid dot-notation (`*.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n  ```rescript\n  open Belt.Float\n  Js.log(2.0 * 2.0 === 4.0) /* true */\n  ```"]
    }, 
    {
      "id": "Belt.Belt_Float./",
      "kind": "value",
      "name": "/",
      "signature": "let _: %rescript.typehole",
      "docstrings": ["Division of two `float` values.\n  Can be opened in a module to avoid dot-notation (`/.`), however this yields a shadow warning (Warning number 44) in the default configuration.\n\n  ```rescript\n  open Belt.Float\n  Js.log(4.0 / 2.0 === 2.0) /* true */\n  ```"]
    }]
  }]
}