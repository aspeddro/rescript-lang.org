// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Path from "path";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Process from "process";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Child_process from "child_process";

var args = Process.argv;

var args_len = args.length;

var analysis_path = args[args_len - 2 | 0];

var compiler_path = args[args_len - 1 | 0];

var lib_path = Path.join(compiler_path, "lib", "ocaml");

var public_api_modules = [
  {
    name: "Belt",
    files: [
      "belt.res",
      "belt_Array.resi",
      "belt_Float.resi",
      "belt_HashMap.resi",
      "belt_HashMapInt.resi",
      "belt_HashMapString.resi",
      "belt_HashSet.resi",
      "belt_HashSetInt.resi",
      "belt_HashSetString.resi",
      "belt_Id.resi",
      "belt_Int.resi",
      "belt_List.resi",
      "belt_Map.resi",
      "belt_MapDict.resi",
      "belt_MapInt.resi",
      "belt_MapString.resi",
      "belt_MutableMap.resi",
      "belt_MutableMapInt.resi",
      "belt_MutableMapString.resi",
      "belt_MutableQueue.resi",
      "belt_MutableSet.resi",
      "belt_MutableSetInt.resi",
      "belt_MutableSetString.resi",
      "belt_MutableStack.resi",
      "belt_Option.resi",
      "belt_Range.resi",
      "belt_Result.resi",
      "belt_Set.resi",
      "belt_SetDict.resi",
      "belt_SetInt.resi",
      "belt_SetString.resi",
      "belt_SortArray.resi",
      "belt_SortArrayInt.resi",
      "belt_SortArrayString.resi"
    ]
  },
  {
    name: "DOM",
    files: [
      "dom.res",
      "dom_storage.res",
      "dom_storage2.res"
    ]
  },
  {
    name: "JS",
    files: [
      "js.ml",
      "js_array.res",
      "js_array2.res",
      "js_bigint.res",
      "js_blob.res",
      "js_console.res",
      "js_date.res",
      "js_dict.mli",
      "js_exn.resi",
      "js_file.res",
      "js_float.res",
      "js_global.res",
      "js_int.res",
      "js_json.resi",
      "js_list.resi",
      "js_mapperRt.resi",
      "js_math.ml",
      "js_null.resi",
      "js_null_undefined.resi",
      "js_obj.res",
      "js_option.resi",
      "js_promise.res",
      "js_promise2.res",
      "js_re.res",
      "js_result.resi",
      "js_set.res",
      "js_string.ml",
      "js_string2.res",
      "js_typed_array.res",
      "js_typed_array2.res",
      "js_types.resi",
      "js_undefined.resi",
      "js_vector.resi",
      "js_weakset.res",
      "js_map.res",
      "js_weakmap.res"
    ]
  }
];

function extractDoc(file) {
  var full_path = Path.join(lib_path, file);
  var cmd = "" + analysis_path + " extractDocs " + full_path + "";
  var output = Child_process.execSync(cmd, {});
  try {
    return JSON.parse(output.toString());
  }
  catch (exn){
    return Pervasives.failwith("Failed to extract docs from: " + file);
  }
}

var Schema = {};

function decode_docstring(item) {
  var j = Js_dict.get(item, "docstrings");
  if (j === undefined) {
    return [];
  }
  var arr = Js_json.classify(Caml_option.valFromOption(j));
  if (typeof arr === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            182,
            11
          ],
          Error: new Error()
        };
  }
  if (arr.TAG === /* JSONArray */3) {
    return arr._0.map(function (s) {
                var s$1 = Js_json.classify(s);
                if (typeof s$1 === "number") {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "doc_gen.res",
                          179,
                          15
                        ],
                        Error: new Error()
                      };
                }
                if (s$1.TAG === /* JSONString */0) {
                  return s$1._0;
                }
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "doc_gen.res",
                        179,
                        15
                      ],
                      Error: new Error()
                    };
              });
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "doc_gen.res",
          182,
          11
        ],
        Error: new Error()
      };
}

function decode_string_by_field(item, field) {
  var j = Js_dict.get(item, field);
  if (j !== undefined) {
    var s = Js_json.classify(Caml_option.valFromOption(j));
    if (typeof s === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "doc_gen.res",
              194,
              11
            ],
            Error: new Error()
          };
    }
    if (s.TAG === /* JSONString */0) {
      return s._0;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            194,
            11
          ],
          Error: new Error()
        };
  } else {
    console.log(item);
    return Pervasives.failwith("Not found field: " + field + "");
  }
}

function decode_depreacted(item) {
  var j = Js_dict.get(item, "deprecated");
  if (j === undefined) {
    return ;
  }
  var j$1 = Js_json.classify(Caml_option.valFromOption(j));
  if (typeof j$1 === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            209,
            11
          ],
          Error: new Error()
        };
  }
  if (j$1.TAG === /* JSONString */0) {
    return j$1._0;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "doc_gen.res",
          209,
          11
        ],
        Error: new Error()
      };
}

function decode_record_fields(fields) {
  var fields$1 = fields.map(function (field) {
        var doc = Js_json.classify(field);
        if (typeof doc === "number") {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "doc_gen.res",
                  238,
                  11
                ],
                Error: new Error()
              };
        }
        if (doc.TAG === /* JSONObject */2) {
          var doc$1 = doc._0;
          var fieldName = decode_string_by_field(doc$1, "fieldName");
          var docstrings = decode_docstring(doc$1);
          var signature = decode_string_by_field(doc$1, "signature");
          var deprecated = decode_depreacted(doc$1);
          var value = Js_dict.get(doc$1, "optional");
          var optional;
          if (value !== undefined) {
            var match = Js_json.classify(Caml_option.valFromOption(value));
            if (typeof match === "number") {
              switch (match) {
                case /* JSONFalse */0 :
                    optional = false;
                    break;
                case /* JSONTrue */1 :
                    optional = true;
                    break;
                case /* JSONNull */2 :
                    throw {
                          RE_EXN_ID: "Assert_failure",
                          _1: [
                            "doc_gen.res",
                            230,
                            17
                          ],
                          Error: new Error()
                        };
                
              }
            } else {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "doc_gen.res",
                      230,
                      17
                    ],
                    Error: new Error()
                  };
            }
          } else {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "doc_gen.res",
                    232,
                    18
                  ],
                  Error: new Error()
                };
          }
          return {
                  fieldName: fieldName,
                  docstrings: docstrings,
                  signature: signature,
                  optional: optional,
                  deprecated: deprecated
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "doc_gen.res",
                238,
                11
              ],
              Error: new Error()
            };
      });
  return {
          TAG: 0,
          fieldDocs: fields$1,
          [Symbol.for("name")]: "Record"
        };
}

function decode_constructor_fields(fields) {
  var fields$1 = fields.map(function (field) {
        var doc = Js_json.classify(field);
        if (typeof doc === "number") {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "doc_gen.res",
                  257,
                  11
                ],
                Error: new Error()
              };
        }
        if (doc.TAG === /* JSONObject */2) {
          var doc$1 = doc._0;
          var constructorName = decode_string_by_field(doc$1, "constructorName");
          var docstrings = decode_docstring(doc$1);
          var signature = decode_string_by_field(doc$1, "signature");
          var deprecated = decode_depreacted(doc$1);
          return {
                  constructorName: constructorName,
                  docstrings: docstrings,
                  signature: signature,
                  deprecated: deprecated
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "doc_gen.res",
                257,
                11
              ],
              Error: new Error()
            };
      });
  return {
          TAG: 1,
          constructorDocs: fields$1,
          [Symbol.for("name")]: "Variant"
        };
}

function decode_detail(detail) {
  var detail$1 = Js_json.classify(detail);
  if (typeof detail$1 === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            300,
            9
          ],
          Error: new Error()
        };
  }
  if (detail$1.TAG === /* JSONObject */2) {
    var detail$2 = detail$1._0;
    var field = Js_dict.get(detail$2, "kind");
    if (field !== undefined) {
      var kind = Js_json.classify(Caml_option.valFromOption(field));
      if (typeof kind === "number") {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "doc_gen.res",
                295,
                13
              ],
              Error: new Error()
            };
      }
      if (kind.TAG === /* JSONString */0) {
        switch (kind._0) {
          case "record" :
              var field$1 = Js_dict.get(detail$2, "fieldDocs");
              if (field$1 !== undefined) {
                var arr = Js_json.classify(Caml_option.valFromOption(field$1));
                if (typeof arr === "number") {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "doc_gen.res",
                          278,
                          19
                        ],
                        Error: new Error()
                      };
                }
                if (arr.TAG === /* JSONArray */3) {
                  return decode_record_fields(arr._0);
                }
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "doc_gen.res",
                        278,
                        19
                      ],
                      Error: new Error()
                    };
              } else {
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "doc_gen.res",
                        280,
                        20
                      ],
                      Error: new Error()
                    };
              }
          case "variant" :
              var field$2 = Js_dict.get(detail$2, "constructorDocs");
              if (field$2 !== undefined) {
                var arr$1 = Js_json.classify(Caml_option.valFromOption(field$2));
                if (typeof arr$1 === "number") {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "doc_gen.res",
                          288,
                          19
                        ],
                        Error: new Error()
                      };
                }
                if (arr$1.TAG === /* JSONArray */3) {
                  return decode_constructor_fields(arr$1._0);
                }
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "doc_gen.res",
                        288,
                        19
                      ],
                      Error: new Error()
                    };
              } else {
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "doc_gen.res",
                        290,
                        20
                      ],
                      Error: new Error()
                    };
              }
          default:
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "doc_gen.res",
                    292,
                    15
                  ],
                  Error: new Error()
                };
        }
      } else {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "doc_gen.res",
                295,
                13
              ],
              Error: new Error()
            };
      }
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "doc_gen.res",
              297,
              14
            ],
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            300,
            9
          ],
          Error: new Error()
        };
  }
}

function decodeValue(item) {
  var id = decode_string_by_field(item, "id");
  var signature = decode_string_by_field(item, "signature");
  var name = decode_string_by_field(item, "name");
  var deprecated = decode_depreacted(item);
  var docstring = decode_docstring(item);
  return {
          TAG: 0,
          id: id,
          docstring: docstring,
          signature: signature,
          name: name,
          deprecated: deprecated,
          [Symbol.for("name")]: "Value"
        };
}

function decodeType(item) {
  var id = decode_string_by_field(item, "id");
  var signature = decode_string_by_field(item, "signature");
  var name = decode_string_by_field(item, "name");
  var deprecated = decode_depreacted(item);
  var docstring = decode_docstring(item);
  var field = Js_dict.get(item, "detail");
  var detail = field !== undefined ? decode_detail(Caml_option.valFromOption(field)) : undefined;
  return {
          TAG: 1,
          id: id,
          docstring: docstring,
          signature: signature,
          name: name,
          deprecated: deprecated,
          detail: detail,
          [Symbol.for("name")]: "Type"
        };
}

function decodeModuleAlias(item) {
  var id = decode_string_by_field(item, "id");
  var signature = decode_string_by_field(item, "signature");
  var name = decode_string_by_field(item, "name");
  var docstring = decode_docstring(item);
  return {
          TAG: 3,
          _0: {
            id: id,
            docstring: docstring,
            name: name,
            signature: signature
          },
          [Symbol.for("name")]: "ModuleAlias"
        };
}

function decodeModule(item) {
  var id = decode_string_by_field(item, "id");
  var name = decode_string_by_field(item, "name");
  var deprecated = decode_depreacted(item);
  var docstring = decode_docstring(item);
  var items = Js_dict.get(item, "items");
  var items$1;
  if (items !== undefined) {
    var arr = Js_json.classify(Caml_option.valFromOption(items));
    if (typeof arr === "number") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "doc_gen.res",
              341,
              11
            ],
            Error: new Error()
          };
    }
    if (arr.TAG === /* JSONArray */3) {
      items$1 = arr._0.map(decodeItem);
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "doc_gen.res",
              341,
              11
            ],
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            343,
            12
          ],
          Error: new Error()
        };
  }
  return {
          TAG: 2,
          _0: {
            id: id,
            docstring: docstring,
            deprecated: deprecated,
            name: name,
            items: items$1
          },
          [Symbol.for("name")]: "Module"
        };
}

function decodeItem(item) {
  var value = Js_json.classify(item);
  if (typeof value === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            368,
            9
          ],
          Error: new Error()
        };
  }
  if (value.TAG === /* JSONObject */2) {
    var value$1 = value._0;
    var kind = Js_dict.get(value$1, "kind");
    if (kind === undefined) {
      return Pervasives.failwith("Cannot found `kind` field");
    }
    var type_ = Js_json.classify(Caml_option.valFromOption(kind));
    if (typeof type_ === "number") {
      return Pervasives.failwith("Expected `kind` field");
    }
    if (type_.TAG !== /* JSONString */0) {
      return Pervasives.failwith("Expected `kind` field");
    }
    var type_$1 = type_._0;
    switch (type_$1) {
      case "module" :
          return decodeModule(value$1);
      case "moduleAlias" :
          return decodeModuleAlias(value$1);
      case "type" :
          return decodeType(value$1);
      case "value" :
          return decodeValue(value$1);
      default:
        return Pervasives.failwith("Not implemented " + type_$1 + "");
    }
  } else {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            368,
            9
          ],
          Error: new Error()
        };
  }
}

function topLevelModule(json) {
  var mod = Js_json.classify(json);
  if (typeof mod === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "doc_gen.res",
            399,
            9
          ],
          Error: new Error()
        };
  }
  if (mod.TAG === /* JSONObject */2) {
    var mod$1 = mod._0;
    var name = decode_string_by_field(mod$1, "name");
    var deprecated = decode_depreacted(mod$1);
    var docstring = decode_docstring(mod$1);
    var items = Js_dict.get(mod$1, "items");
    var items$1;
    if (items !== undefined) {
      var arr = Js_json.classify(Caml_option.valFromOption(items));
      if (typeof arr === "number") {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "doc_gen.res",
                390,
                15
              ],
              Error: new Error()
            };
      }
      if (arr.TAG === /* JSONArray */3) {
        items$1 = arr._0.map(decodeItem);
      } else {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "doc_gen.res",
                390,
                15
              ],
              Error: new Error()
            };
      }
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "doc_gen.res",
              393,
              16
            ],
            Error: new Error()
          };
    }
    return {
            name: name,
            deprecated: deprecated,
            docstring: docstring,
            items: items$1
          };
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "doc_gen.res",
          399,
          9
        ],
        Error: new Error()
      };
}

export {
  args ,
  args_len ,
  analysis_path ,
  compiler_path ,
  lib_path ,
  public_api_modules ,
  extractDoc ,
  Schema ,
  decode_docstring ,
  decode_string_by_field ,
  decode_depreacted ,
  decode_record_fields ,
  decode_constructor_fields ,
  decode_detail ,
  decodeValue ,
  decodeType ,
  decodeModuleAlias ,
  decodeModule ,
  decodeItem ,
  topLevelModule ,
}
/* args Not a pure module */
